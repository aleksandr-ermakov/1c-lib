// BSLLS:CognitiveComplexity-off

#Область OneScript
// BSLLS:UnusedLocalVariable-off
Перем СериализаторXDTO; // Для тестирования
// BSLLS:UnusedLocalVariable-on
#КонецОбласти // OneScript

#Область ОписанияТипов

// Объединяет несколько описаний типов в одно.
// При необходимости, расширяет доступные квалификаторы.
//
// Параметры:
//	ОписаниеТиповА	 - ОписаниеТипов - Описание типов.
//	ОписаниеТиповБ	 - ОписаниеТипов - Описание типов.
//
// Возвращаемое значение:
//	ОписаниеТипов - Результирующее описание типов.
//		Включает в себя типы из обоих входящих описаний.
//		Результатом с описанием произвольного типа (без перечисления типов)
//		всегда будет описание произвольного типа.
//
Функция ОбъединениеОписанийТипов(ОписаниеТиповА, ОписаниеТиповБ) Экспорт
	
	МассивОписаний = Новый Массив;
	МассивОписаний.Добавить(ОписаниеТиповА);
	МассивОписаний.Добавить(ОписаниеТиповБ);
	
	Если НЕ ЗначениеЗаполнено(ОписаниеТиповА.Типы())
		ИЛИ НЕ ЗначениеЗаполнено(ОписаниеТиповБ.Типы()) Тогда
		Возврат Новый ОписаниеТипов;
	КонецЕсли;
	
	ВсеТипы = Новый Массив;
	
	КвалификаторыЧисла = Неопределено;
	КвалификаторыСтроки = Неопределено;
	КвалификаторыДаты = Неопределено;
	КвалификаторыДвоичныхДанных = Неопределено;
	
	Для Каждого ТекущееОписаниеТипов Из МассивОписаний Цикл
		
		Для Каждого ТекущийТип Из ТекущееОписаниеТипов.Типы() Цикл
			ВсеТипы.Добавить(ТекущийТип);
		КонецЦикла;
		
		Если ТекущееОписаниеТипов.СодержитТип(Тип("Число")) Тогда
			ТекКвалификаторыЧисла = ТекущееОписаниеТипов.КвалификаторыЧисла;
			Если КвалификаторыЧисла = Неопределено Тогда
				КвалификаторыЧисла = ТекКвалификаторыЧисла;
			Иначе
				РазрядностьДробнойЧасти = Макс(
						КвалификаторыЧисла.РазрядностьДробнойЧасти,
						ТекКвалификаторыЧисла.РазрядностьДробнойЧасти
					);
				Если КвалификаторыЧисла.Разрядность * ТекКвалификаторыЧисла.Разрядность = 0 Тогда
					Разрядность = 0;
				Иначе
					РазрядностьЦелойЧасти = Макс(
							КвалификаторыЧисла.Разрядность - КвалификаторыЧисла.РазрядностьДробнойЧасти,
							ТекКвалификаторыЧисла.Разрядность - ТекКвалификаторыЧисла.РазрядностьДробнойЧасти
						);
					Разрядность = РазрядностьЦелойЧасти + РазрядностьДробнойЧасти;
				КонецЕсли;
				Знак = КвалификаторыЧисла.ДопустимыйЗнак;
				Если Знак <> ТекКвалификаторыЧисла.ДопустимыйЗнак Тогда
					Знак = ДопустимыйЗнак.Любой;
				КонецЕсли;
				КвалификаторыЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти, Знак);
			КонецЕсли;
		КонецЕсли;
		
		Если ТекущееОписаниеТипов.СодержитТип(Тип("Строка")) Тогда
			ТекКвалификаторыСтроки = ТекущееОписаниеТипов.КвалификаторыСтроки;
			Если КвалификаторыСтроки = Неопределено Тогда
				КвалификаторыСтроки = ТекКвалификаторыСтроки;
			Иначе
				Если КвалификаторыСтроки.Длина * ТекКвалификаторыСтроки.Длина = 0 Тогда
					Длина = 0;
				Иначе
					Длина = Макс(КвалификаторыСтроки.Длина, ТекКвалификаторыСтроки.Длина);
				КонецЕсли;
				Ограничение = КвалификаторыСтроки.ДопустимаяДлина;
				Если Ограничение <> ТекКвалификаторыСтроки.ДопустимаяДлина Тогда
					Ограничение = ДопустимаяДлина.Переменная;
				КонецЕсли;
				КвалификаторыСтроки = Новый КвалификаторыСтроки(Длина, Ограничение);
			КонецЕсли;
		КонецЕсли;
		
		Если ТекущееОписаниеТипов.СодержитТип(Тип("Дата")) Тогда
			ТекКвалификаторыДаты = ТекущееОписаниеТипов.КвалификаторыДаты;
			Если КвалификаторыДаты = Неопределено Тогда
				КвалификаторыДаты = ТекКвалификаторыДаты;
			Иначе
				Части = КвалификаторыДаты.ЧастиДаты;
				Если Части <> ТекКвалификаторыДаты.ЧастиДаты Тогда
					Части = ЧастиДаты.ДатаВремя;
				КонецЕсли;
				КвалификаторыДаты = Новый КвалификаторыДаты(Части);
			КонецЕсли;
		КонецЕсли;
		
		Если ТекущееОписаниеТипов.СодержитТип(Тип("ДвоичныеДанные")) Тогда
			ТекКвалификаторыДвоичныхДанных = ТекущееОписаниеТипов.КвалификаторыДвоичныхДанных;
			Если КвалификаторыДвоичныхДанных = Неопределено Тогда
				КвалификаторыДвоичныхДанных = ТекКвалификаторыДвоичныхДанных;
			Иначе
				Если КвалификаторыДвоичныхДанных.Длина * ТекКвалификаторыДвоичныхДанных.Длина = 0 Тогда
					Длина = 0;
				Иначе
					Длина = Макс(КвалификаторыДвоичныхДанных.Длина, ТекКвалификаторыДвоичныхДанных.Длина);
				КонецЕсли;
				Ограничение = КвалификаторыДвоичныхДанных.ДопустимаяДлина;
				Если Ограничение <> ТекКвалификаторыДвоичныхДанных.ДопустимаяДлина Тогда
					Ограничение = ДопустимаяДлина.Переменная;
				КонецЕсли;
				КвалификаторыДвоичныхДанных = Новый КвалификаторыДвоичныхДанных(Длина, Ограничение);
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	
	НовоеОписаниеТипов = Новый ОписаниеТипов(
			ВсеТипы,
			КвалификаторыЧисла,
			КвалификаторыСтроки,
			КвалификаторыДаты,
			КвалификаторыДвоичныхДанных
		);
	
	Возврат НовоеОписаниеТипов;
	
КонецФункции // ОбъединениеОписанийТипов()

// Выполняет пересечение описаний типов в одно описание.
// При необходимости, сокращает доступные квалификаторы.
//
// Параметры:
//	ОписаниеТиповА	 - ОписаниеТипов - Описание типов.
//	ОписаниеТиповБ	 - ОписаниеТипов - Описание типов.
//
// Возвращаемое значение:
//	ОписаниеТипов - Результирующее описание типов.
//		Включает в себя типы, присутствующие в обоих входящих описаниях.
//		Не включает несовместимые типы, присутствующие в обоих описаниях.
//		Например, Даты(ЧастиДаты.Дата) ∧ Дата(ЧастиДаты.Время) = ∅
//		или Число(N, 0) ∧ Число(N, N) = ∅.
//		В квалификаторах строк сохраняется фиксированная длина только
//		если таковая использовалась для обоих исходных типов (итоговая длина не может увеличиться).
//
Функция ПересечениеОписанийТипов(ОписаниеТиповА, ОписаниеТиповБ) Экспорт
	
	МассивОписаний = Новый Массив;
	МассивОписаний.Добавить(ОписаниеТиповА);
	МассивОписаний.Добавить(ОписаниеТиповБ);
	
	Если НЕ ЗначениеЗаполнено(ОписаниеТиповА.Типы()) Тогда
		Возврат Новый ОписаниеТипов(
			ОписаниеТиповБ, , ,
			ОписаниеТиповБ.КвалификаторыЧисла,
			ОписаниеТиповБ.КвалификаторыСтроки,
			ОписаниеТиповБ.КвалификаторыДаты,
			ОписаниеТиповБ.КвалификаторыДвоичныхДанных
		);
	КонецЕсли;
	Если НЕ ЗначениеЗаполнено(ОписаниеТиповБ.Типы()) Тогда
		Возврат Новый ОписаниеТипов(
			ОписаниеТиповА, , ,
			ОписаниеТиповА.КвалификаторыЧисла,
			ОписаниеТиповА.КвалификаторыСтроки,
			ОписаниеТиповА.КвалификаторыДаты,
			ОписаниеТиповА.КвалификаторыДвоичныхДанных
		);
	КонецЕсли;
	
	ВсеТипы = Новый Массив;
	
	КвалификаторыЧисла = Неопределено;
	КвалификаторыСтроки = Неопределено;
	КвалификаторыДаты = Неопределено;
	КвалификаторыДвоичныхДанных = Неопределено;
	
	Для Каждого ТекущийТип Из ОписаниеТиповА.Типы() Цикл
		
		Если НЕ ОписаниеТиповБ.СодержитТип(ТекущийТип) Тогда
			Продолжить;
		КонецЕсли;
		
		Если ТекущийТип = Тип("Число") Тогда
			КвалификаторыА = ОписаниеТиповА.КвалификаторыЧисла;
			КвалификаторыБ = ОписаниеТиповБ.КвалификаторыЧисла;
			МинРазрядность = Мин(КвалификаторыА.Разрядность, КвалификаторыБ.Разрядность);
			МаксРазрядность = Макс(КвалификаторыА.Разрядность, КвалификаторыБ.Разрядность);
			МинРазрядностьДробнойЧасти = Мин(КвалификаторыА.РазрядностьДробнойЧасти,
					КвалификаторыБ.РазрядностьДробнойЧасти);
			Если КвалификаторыА.Разрядность * КвалификаторыБ.Разрядность = 0 Тогда
				Разрядность = МаксРазрядность;
			Иначе
				Разрядность = МинРазрядность;
			КонецЕсли;
			Если КвалификаторыА.Разрядность = 0 Тогда
				РазрядностьДробнойЧасти = КвалификаторыБ.РазрядностьДробнойЧасти;
			ИначеЕсли КвалификаторыБ.Разрядность = 0 Тогда
				РазрядностьДробнойЧасти = КвалификаторыА.РазрядностьДробнойЧасти;
			Иначе
				РазрядностьДробнойЧасти = МинРазрядностьДробнойЧасти;
			КонецЕсли;
			#Область Контроль
			Если Разрядность <> 0 И МинРазрядность > 0 Тогда
				// Проверка частного случая, когда в одном числе только целая часть,
				// а в другом - только дробная.
				ЕстьЦелаяА = Булево(КвалификаторыА.Разрядность - КвалификаторыА.РазрядностьДробнойЧасти);
				ЕстьЦелаяБ = Булево(КвалификаторыБ.Разрядность - КвалификаторыБ.РазрядностьДробнойЧасти);
				ЕстьДробнаяА = Булево(КвалификаторыА.РазрядностьДробнойЧасти);
				ЕстьДробнаяБ = Булево(КвалификаторыБ.РазрядностьДробнойЧасти);
				Если ЕстьЦелаяА <> ЕстьДробнаяА И ЕстьЦелаяА <> ЕстьЦелаяБ И ЕстьЦелаяБ <> ЕстьДробнаяБ Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			#КонецОбласти // Контроль
			Если КвалификаторыА.ДопустимыйЗнак <> КвалификаторыБ.ДопустимыйЗнак Тогда
				Знак = ДопустимыйЗнак.Неотрицательный;
			Иначе
				Знак = ДопустимыйЗнак.Любой;
			КонецЕсли;
			КвалификаторыЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти, Знак);
		КонецЕсли;
		
		Если ТекущийТип = Тип("Строка") Тогда
			КвалификаторыА = ОписаниеТиповА.КвалификаторыСтроки;
			КвалификаторыБ = ОписаниеТиповБ.КвалификаторыСтроки;
			Если КвалификаторыА.Длина * КвалификаторыБ.Длина = 0 Тогда
				Длина = Макс(КвалификаторыА.Длина, КвалификаторыБ.Длина);
			Иначе
				Длина = Мин(КвалификаторыА.Длина, КвалификаторыБ.Длина);
			КонецЕсли;
			Если КвалификаторыА.ДопустимаяДлина = ДопустимаяДлина.Фиксированная
				И КвалификаторыБ.ДопустимаяДлина = ДопустимаяДлина.Фиксированная Тогда
				Ограничение = ДопустимаяДлина.Фиксированная;
			Иначе
				Ограничение = ДопустимаяДлина.Переменная;
			КонецЕсли;
			КвалификаторыСтроки = Новый КвалификаторыСтроки(Длина, Ограничение);
		КонецЕсли;
		
		Если ТекущийТип = Тип("Дата") Тогда
			КвалификаторыА = ОписаниеТиповА.КвалификаторыДаты;
			КвалификаторыБ = ОписаниеТиповБ.КвалификаторыДаты;
			ВариантыЧастейДаты = Новый Массив;
			#Область Контроль
			// Проверка, когда в одном только часть даты, в другом - только время.
			ВариантыЧастейДаты.Добавить(ЧастиДаты.ДатаВремя);
			ВариантыЧастейДаты.Добавить(ЧастиДаты.Дата);
			ВариантыЧастейДаты.Добавить(ЧастиДаты.Время);
			МинИндексВарианта = Мин(
					ВариантыЧастейДаты.Найти(КвалификаторыА.ЧастиДаты),
					ВариантыЧастейДаты.Найти(КвалификаторыБ.ЧастиДаты)
				);
			МаксИндексВарианта = Макс(
					ВариантыЧастейДаты.Найти(КвалификаторыА.ЧастиДаты),
					ВариантыЧастейДаты.Найти(КвалификаторыБ.ЧастиДаты)
				);
			Если МинИндексВарианта = МаксИндексВарианта Тогда
				Части = ВариантыЧастейДаты[МинИндексВарианта];
			ИначеЕсли МинИндексВарианта = 0 Тогда
				Части = ВариантыЧастейДаты[МаксИндексВарианта];
			Иначе
				Продолжить;
			КонецЕсли;
			#КонецОбласти // Контроль
			КвалификаторыДаты = Новый КвалификаторыДаты(Части);
		КонецЕсли;
		
		Если ТекущийТип = Тип("ДвоичныеДанные") Тогда
			КвалификаторыА = ОписаниеТиповА.КвалификаторыДвоичныхДанных;
			КвалификаторыБ = ОписаниеТиповБ.КвалификаторыДвоичныхДанных;
			Если КвалификаторыА.Длина * КвалификаторыБ.Длина = 0 Тогда
				Длина = Макс(КвалификаторыА.Длина, КвалификаторыБ.Длина);
			Иначе
				Длина = Мин(КвалификаторыА.Длина, КвалификаторыБ.Длина);
			КонецЕсли;
			Если КвалификаторыА.ДопустимаяДлина <> КвалификаторыБ.ДопустимаяДлина Тогда
				Ограничение = ДопустимаяДлина.Фиксированная;
			Иначе
				Ограничение = ДопустимаяДлина.Любая;
			КонецЕсли;
			КвалификаторыДвоичныхДанных = Новый КвалификаторыДвоичныхДанных(Длина, Ограничение);
		КонецЕсли;
		
		ВсеТипы.Добавить(ТекущийТип);
		
	КонецЦикла;
	
	ОписаниеТипов = Новый ОписаниеТипов(
			ВсеТипы,
			КвалификаторыЧисла,
			КвалификаторыСтроки,
			КвалификаторыДаты,
			КвалификаторыДвоичныхДанных
		);
	
	Возврат ОписаниеТипов;
	
КонецФункции // ПересечениеОписанийТипов()

// Создает описание типов по значению.
//
// Параметры:
//  Значение - Произвольный	 - Значение, по типу которого формируется описание.
// 
// Возвращаемое значение:
//  ОписаниеТипов - Получанное описание типов.
//
Функция ОписаниеТиповПоЗначению(Знач Значение) Экспорт
	
	Типы = Новый Массив;
	Типы.Добавить(ТипЗнч(Значение));
	Возврат Новый ОписаниеТипов(Типы);

КонецФункции // ОписаниеТиповПоЗначению()

// Формирует объект ОписаниеТипов из строкового перечисления типов.
//
// Параметры:
//	ОписаниеТиповСтрокой - Строка - Строка с перечислением типов.
//		Типы разделяются точкой с запятой или переводом строки.
//		Параметры квалификаторов можно записывать как в полной, так и в краткой форме.
//	Разделитель - Строка - Строка символов, каждый из которых является индивидуальным разделителем.
//		Нельзя использовать в качестве разделителей точку и круглые скобки.
//
// Возвращаемое значение:
//	ОписаниеТипов - Полученное описание типов.
//
// Примеры:
//	ОписаниеТиповПоСтроке("Число(12, 2, Неотрицательный); СправочникСсылка.Номенклатура", ";");
//	ОписаниеТиповПоСтроке("Строка(24, ДопустимаяДлина.Фиксированная)");
//
Функция ОписаниеТиповПоСтроке(Знач ОписаниеТиповСтрокой, Знач Разделитель = ";") Экспорт
	
	Если ПустаяСтрока(ОписаниеТиповСтрокой) Тогда
		Возврат Новый ОписаниеТипов();
	КонецЕсли;

	#Область Проверки
	
	Если СтрНайти(Разделитель, ".") ИЛИ СтрНайти(Разделитель, "(") ИЛИ СтрНайти(Разделитель, ")") Тогда
		ВызватьИсключение "Недопустимый разделитель";
	КонецЕсли;
	
	УровеньСкобок = 0;
	РазделительСодержитЗапятую = СтрНайти(Разделитель, ",");
	НуженРазделительВместоЗапятой = Ложь;
	РазделительВместоЗапятой = Символы.ПС;
	Для НомерСимвола = 1 По СтрДлина(ОписаниеТиповСтрокой) Цикл
		ТекущийСимвол = Сред(ОписаниеТиповСтрокой, НомерСимвола, 1);
		Если ТекущийСимвол = "(" Тогда
			УровеньСкобок = УровеньСкобок + 1;
		КонецЕсли;
		Если ТекущийСимвол = ")" Тогда
			УровеньСкобок = УровеньСкобок - 1;
		КонецЕсли;
		Если ТекущийСимвол = "," И УровеньСкобок = 0 Тогда
			Если РазделительСодержитЗапятую Тогда
				ОписаниеТиповСтрокой = Лев(ОписаниеТиповСтрокой, НомерСимвола - 1)
					+ РазделительВместоЗапятой
					+ Сред(ОписаниеТиповСтрокой, НомерСимвола + 1);
				НуженРазделительВместоЗапятой = Истина;
			Иначе
				ВызватьИсключение СтрШаблон("Ошибка формата: Неожиданный разделитель. Номер символа %1", НомерСимвола);
			КонецЕсли;
		КонецЕсли;
		Если УровеньСкобок > 1 Тогда
			ВызватьИсключение СтрШаблон("Ошибка формата: Вложенные скобки недопустимы. Номер символа %1", НомерСимвола);
		КонецЕсли;
		Если УровеньСкобок < 0 Тогда
			ВызватьИсключение СтрШаблон("Ошибка формата: Неверные круглые скобки. Номер символа %1", НомерСимвола);
		КонецЕсли;
	КонецЦикла;
	Если НуженРазделительВместоЗапятой Тогда
		Разделитель = СтрЗаменить(Разделитель, ",", РазделительВместоЗапятой);
	КонецЕсли;
	
	#КонецОбласти // Проверки
	
	Подстроки = СтрРазделить(ОписаниеТиповСтрокой, Разделитель);
	
	ВсеОписанияТипов = Новый Массив;
	
	Для Каждого Подстрока Из Подстроки Цикл
		Попытка
			ОписаниеТипа = ОписаниеТипаПоСтроке(Подстрока);
			ВсеОписанияТипов.Добавить(ОписаниеТипа);
		Исключение
			// Типа может не существовать в метаданных.
			Продолжить;
		КонецПопытки;
	КонецЦикла;
	
	Если ВсеОписанияТипов.Количество() = 1 Тогда
		Возврат ВсеОписанияТипов[0];
	КонецЕсли;
	
	ОписаниеТипов = ВсеОписанияТипов[0];
	Для Индекс = 1 По ВсеОписанияТипов.ВГраница() Цикл
		ОписаниеТипов = ОбъединениеОписанийТипов(ОписаниеТипов, ВсеОписанияТипов[Индекс]);
	КонецЦикла;
	
	Возврат ОписаниеТипов;
	
КонецФункции // ОписаниеТиповПоСтроке()

// Формирует объект ОписаниеТипов из строкового описания типа.
//
// Параметры:
//	ОписаниеТиповСтрокой - Строка - Строка с описанием типа.
//		Параметры квалификаторов можно записывать как в полной, так и в краткой форме.
//
// Возвращаемое значение:
//	ОписаниеТипов - Полученное описание типов.
//
// Примеры:
//	ОписаниеТипаПоСтроке("Число(12, 2, Неотрицательный)")
//	ОписаниеТипаПоСтроке("Число(12, 2, ДопустимыйЗнак.Неотрицательный)")
//
Функция ОписаниеТипаПоСтроке(Знач ОписаниеТипаСтрокой) Экспорт
	
	Если ПустаяСтрока(ОписаниеТипаСтрокой) Тогда
		Возврат Новый ОписаниеТипов();
	КонецЕсли;
	
	ОписаниеТипаСтрокой = СокрЛП(ОписаниеТипаСтрокой);
	
	ПозицияОткрывающейСкобки = СтрНайти(ОписаниеТипаСтрокой, "(");
	Если ПозицияОткрывающейСкобки = 0 Тогда // Примитивный тип без квалификаторов, либо объектный тип.
		Возврат Новый ОписаниеТипов(ОписаниеТипаСтрокой);
	КонецЕсли;
	
	ПозицияЗакрывающейСкобки = СтрНайти(ОписаниеТипаСтрокой, ")");
	СодержимоеСкобок = Сред(ОписаниеТипаСтрокой,
			ПозицияОткрывающейСкобки + 1,
			ПозицияЗакрывающейСкобки - ПозицияОткрывающейСкобки - 1);
	ПараметрыСтроками = СтрРазделить(СодержимоеСкобок, ",");
	Для Индекс = 0 По ПараметрыСтроками.ВГраница() Цикл
		ПараметрыСтроками[Индекс] = СокрЛП(ПараметрыСтроками[Индекс]);
	КонецЦикла;
	
	ИмяТипа = СокрЛП(Лев(ОписаниеТипаСтрокой, ПозицияОткрывающейСкобки - 1));
	Если ПараметрыСтроками.Количество() = 0 Тогда // Примитивный тип с пустыми скобками.
		Возврат Новый ОписаниеТипов(ИмяТипа);
	КонецЕсли;
	
	Если СтрНайти(Врег("Число, Number"), ВРег(ИмяТипа)) Тогда
		
		ИндексКвалификатора = 1; // Индекс в параметрах конструктора Новый ОписаниеТипов();
		ТипКвалификатора = Тип("КвалификаторыЧисла");
		СвойстваКвалификатора = СтрРазделить("Разрядность, РазрядностьДробнойЧасти, ДопустимыйЗнак", ", ", Ложь);
		
	ИначеЕсли СтрНайти(Врег("Строка, String"), ВРег(ИмяТипа)) Тогда
		
		ИндексКвалификатора = 2;
		ТипКвалификатора = Тип("КвалификаторыСтроки");
		СвойстваКвалификатора = СтрРазделить("Длина, ДопустимаяДлина", ", ", Ложь);
		
	ИначеЕсли СтрНайти(Врег("Дата, Date"), ВРег(ИмяТипа)) Тогда
		
		ИндексКвалификатора = 3;
		ТипКвалификатора = Тип("КвалификаторыДаты");
		СвойстваКвалификатора = СтрРазделить("ЧастиДаты", ", ", Ложь);
		
	ИначеЕсли СтрНайти(Врег("ДвоичныеДанные, BinaryData"), ВРег(ИмяТипа)) Тогда
		
		ИндексКвалификатора = 4;
		ТипКвалификатора = Тип("КвалификаторыДвоичныхДанных");
		СвойстваКвалификатора = СтрРазделить("Длина, ДопустимаяДлина", ", ", Ложь);
		
	Иначе
		ВызватьИсключение СтрШаблон("Ошибка определения типа по строке: %1", ОписаниеТипаСтрокой);
		
	КонецЕсли;
	
	Попытка
		
		ОбразецКвалификатора = Новый(ТипКвалификатора);
		Параметров = СвойстваКвалификатора.Количество();
		ПараметрыКвалификатора = Новый Массив(Параметров);
		ТипыПараметров = Новый Массив(Параметров);
		Для Индекс = 0 По СвойстваКвалификатора.ВГраница() Цикл
			ЗначениеПараметра = ОбразецКвалификатора[СвойстваКвалификатора[Индекс]];
			ПараметрыКвалификатора[Индекс] = ЗначениеПараметра;
			ТипыПараметров[Индекс] = ТипЗнч(ЗначениеПараметра);
		КонецЦикла;
		
		// ПараметрыКвалификатора:
		Для Индекс = 0 По ТипыПараметров.ВГраница() Цикл
			Если ПараметрыСтроками.ВГраница() >= Индекс И НЕ ПустаяСтрока(ПараметрыСтроками[Индекс]) Тогда
				ПараметрСтрокой = ПараметрыСтроками[Индекс];
				Если СтрНайти(ПараметрСтрокой, ".") Тогда
					ЗначениеПараметра = Вычислить(ПараметрСтрокой);
				Иначе
					ЗначениеПараметра = XMLЗначение(ТипыПараметров[Индекс], ПараметрСтрокой);
				КонецЕсли;
				ПараметрыКвалификатора[Индекс] = ЗначениеПараметра;
			КонецЕсли;
		КонецЦикла;
		
		Квалификатор = Новый(ТипКвалификатора, ПараметрыКвалификатора);
		
		ПараметрыКонструктора = Новый Массив(5);
		ПараметрыКонструктора[0] = ИмяТипа;
		ПараметрыКонструктора[ИндексКвалификатора] = Квалификатор;
		ОписаниеТипов = Новый("ОписаниеТипов", ПараметрыКонструктора);
		
		Возврат ОписаниеТипов;
		
	Исключение
		ВызватьИсключение СтрШаблон("Ошибка формирования типа по строке: %1", ОписаниеТипаСтрокой);
		
	КонецПопытки;
	
	Возврат Новый ОписаниеТипов;
	
КонецФункции // ОписаниеТипаПоСтроке()

// Проверяет соответствие описаний типов
//
// Параметры:
//	ОписаниеТиповА			 - ОписаниеТипов
//	ОписаниеТиповБ			 - ОписаниеТипов
//	ПроверятьКвалификаторы	 - Булево	 - Кроме входящих описаний типов проверяются квалификаторы простых типов
//
// Возвращаемое значение:
//	Булево - Описания типов совпадают
//
Функция ОписанияТиповСовпадают(ОписаниеТиповА, ОписаниеТиповБ, ПроверятьКвалификаторы = Истина) Экспорт
	
	ТипыА = ОписаниеТиповА.Типы();
	ТипыБ = ОписаниеТиповБ.Типы();
	
	Если ТипыА.Количество() <> ТипыБ.Количество() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для Каждого ТипА Из ОписаниеТиповА.Типы() Цикл
		Если НЕ ОписаниеТиповБ.СодержитТип(ТипА) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ТипБ Из ОписаниеТиповБ.Типы() Цикл
		Если НЕ ОписаниеТиповА.СодержитТип(ТипБ) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Если НЕ ПроверятьКвалификаторы Тогда
		Возврат Истина;
	КонецЕсли;
	
	ТипыКвалификаторы = Новый Структура;
	ТипыКвалификаторы.Вставить("Дата", "КвалификаторыДаты");
	ТипыКвалификаторы.Вставить("ДвоичныеДанные", "КвалификаторыДвоичныхДанных");
	ТипыКвалификаторы.Вставить("Строка", "КвалификаторыСтроки");
	ТипыКвалификаторы.Вставить("Число", "КвалификаторыЧисла");
	Для Каждого ТипКвалификатор Из ТипыКвалификаторы Цикл
		ИмяТипа = ТипКвалификатор.Ключ;
		ИмяКвалификатора = ТипКвалификатор.Значение;
		Если ОписаниеТиповА.СодержитТип(Тип(ИмяТипа))
			И НЕ КвалификаторыТиповСовпадают(
				ОписаниеТиповА[ИмяКвалификатора],
				ОписаниеТиповБ[ИмяКвалификатора]) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции // ОписанияТиповСовпадают()

// Проверяет совпадение квалификаторов типов
//
// Параметры:
//	КвалификаторыА	 - КвалификаторыДаты
//					 - КвалификаторыДвоичныхДанных
//					 - КвалификаторыСтроки
//					 - КвалификаторыЧисла
//	КвалификаторыБ	 - КвалификаторыДаты
//					 - КвалификаторыДвоичныхДанных
//					 - КвалификаторыСтроки
//					 - КвалификаторыЧисла
//
// Варианты вызова:
//	КвалификаторыТиповСовпадают(КвалификаторыДаты, КвалификаторыДаты)						 - Проверка квалификаторов даты
//	КвалификаторыТиповСовпадают(КвалификаторыДвоичныхДанных, КвалификаторыДвоичныхДанных)	 - Проверка квалификаторов строки
//	КвалификаторыТиповСовпадают(КвалификаторыСтроки, КвалификаторыСтроки)					 - Проверка квалификаторов двоичных данных
//	КвалификаторыТиповСовпадают(КвалификаторыЧисла, КвалификаторыЧисла)						 - Проверка квалификаторов числа
//
// Возвращаемое значение:
//   Булево   - Квалификаторы совпадают
//
Функция КвалификаторыТиповСовпадают(КвалификаторыА, КвалификаторыБ) Экспорт
	
	Если ТипЗнч(КвалификаторыА) <> ТипЗнч(КвалификаторыБ) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	КвА = КвалификаторыА;
	КвБ = КвалификаторыБ;
	
	Если ТипЗнч(КвалификаторыА) = Тип("КвалификаторыДаты") Тогда
		
		КвалификаторыСовпадают = КвА.ЧастиДаты = КвБ.ЧастиДаты;
		
	ИначеЕсли ТипЗнч(КвалификаторыА) = Тип("КвалификаторыДвоичныхДанных")
		ИЛИ ТипЗнч(КвалификаторыА) = Тип("КвалификаторыСтроки") Тогда
		
		КвалификаторыСовпадают = КвА.Длина = КвБ.Длина
			И КвА.ДопустимаяДлина = КвБ.ДопустимаяДлина;
		
	ИначеЕсли ТипЗнч(КвалификаторыА) = Тип("КвалификаторыЧисла") Тогда
		
		КвалификаторыСовпадают = КвА.ДопустимыйЗнак = КвБ.ДопустимыйЗнак
			И КвА.Разрядность = КвБ.Разрядность
			И КвА.РазрядностьДробнойЧасти = КвБ.РазрядностьДробнойЧасти;
		
	Иначе
		
		ВызватьИсключение "Непредвиденные параметры";
		
	КонецЕсли;
	
	Возврат КвалификаторыСовпадают;
	
КонецФункции // КвалификаторыТиповСовпадают()

// Сравнивает типы в составе описаний типов
// Без учета квалификаторов
//
// Параметры:
//	ОписаниеТиповА	 - ОписаниеТипов			 - Первое описание типов для сравнения
//					 - Массив Из ОписаниеТипов	 - Для сравнения трёх и более типов
//	ОписаниеТиповБ	 - ОписаниеТипов			 - Второе описание типов для сравнения.
//												Не используется, если ОписаниеТиповА - это Массив
//
// Возвращаемое значение:
//	Соответствие:
//		* Ключ		 - ОписаниеТипов - Описание типов, поданное в параметре функции
//		* Значение	 - Массив Из Тип - Типы, присутствующие в этом описании, и отсутствующие в другом (любом из других)
//
// Варианты вызова:
//	СравнитьОписанияТипов(ОписаниеТипов, ОписаниеТипов) - Сравнение двух описаний типов
//	СравнитьОписанияТипов(Массив)						- Сравнивает трёх и более описаний типов
//
Функция СравнитьОписанияТипов(ОписаниеТиповА, ОписаниеТиповБ = Неопределено) Экспорт
	
	Если ТипЗнч(ОписаниеТиповА) = Тип("Массив") Тогда
		ОписанияТипов = ОписаниеТиповА;
	Иначе
		ОписанияТипов = Новый Массив;
		ОписанияТипов.Добавить(ОписаниеТиповА);
		ОписанияТипов.Добавить(ОписаниеТиповБ);
	КонецЕсли;
	
	Если ОписанияТипов.Количество() < 2 Тогда
		ВызватьИсключение "Описаний для сравнения должно быть 2 или более";
	КонецЕсли;
	
	СобственныеТипыОписаний = Новый Соответствие;
	Для Каждого ОписаниеТипов Из ОписанияТипов Цикл
		СобственныеТипыОписаний.Вставить(ОписаниеТипов, Новый Массив);
	КонецЦикла;
	
	Для Каждого ТекущееОписаниеТипов Из ОписанияТипов Цикл
		ТипыТекущегоОписания = ТекущееОписаниеТипов.Типы();
		СобственныеТипыОписания = СобственныеТипыОписаний[ТекущееОписаниеТипов];
		Для Каждого ДругоеОписаниеТипов Из ОписанияТипов Цикл
			Если ТекущееОписаниеТипов = ДругоеОписаниеТипов Тогда
				Продолжить;
			КонецЕсли;
			ТипыДругогоОписания = ДругоеОписаниеТипов.Типы();
			Для Каждого ТипТекущегоОписания Из ТипыТекущегоОписания Цикл
				Если ТипыДругогоОписания.Найти(ТипТекущегоОписания) = Неопределено
					И СобственныеТипыОписания.Найти(ТипТекущегоОписания) = Неопределено Тогда
					СобственныеТипыОписания.Добавить(ТипТекущегоОписания);
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
	
	Возврат СобственныеТипыОписаний;
	
КонецФункции // СравнитьОписанияТипов()

// Сравнивает описания типов и формирует текстовое представление результата
//
// Параметры:
//	ОписаниеТиповА - ОписаниеТипов
//	ОписаниеТиповБ - ОписаниеТипов
//
// Возвращаемое значение:
//	Строка - Табличное представление результата сравнения
//
Функция СравнитьОписанияТиповСформироватьРезультатТекст(ОписаниеТиповА, ОписаниеТиповБ) Экспорт
	
	Если ТипЗнч(ОписаниеТиповА) = Тип("Массив") Тогда
		ОписанияТипов = ОписаниеТиповА;
	Иначе
		ОписанияТипов = Новый Массив;
		ОписанияТипов.Добавить(ОписаниеТиповА);
		ОписанияТипов.Добавить(ОписаниеТиповБ);
	КонецЕсли;
	
	РезультатСравнения = СравнитьОписанияТипов(ОписаниеТиповА, ОписаниеТиповБ);
	
	ВсеТипы = Новый СписокЗначений;
	Для Каждого ОписаниеТипов Из ОписанияТипов Цикл
		СобственныеТипыОписания = РезультатСравнения[ОписаниеТипов];
		Для Каждого Тип Из СобственныеТипыОписания Цикл
			Если ВсеТипы.НайтиПоЗначению(Тип) = Неопределено Тогда
				ВсеТипы.Добавить(Тип, Строка(Тип));
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	ЕстьРазличия = ЗначениеЗаполнено(ВсеТипы);
	Если НЕ ЕстьРазличия Тогда
		Возврат "Типы в составе описаний совпадают";
	КонецЕсли;
	
	ВсеТипы.СортироватьПоПредставлению();
	
	СоставТаблицы = Новый Массив;
	СоставСтроки = Новый Массив;
	Заголовок = "Тип \ Описание типов";
	СоставСтроки.Добавить(Заголовок);
	Для НомерТипа = 1 По ОписанияТипов.Количество() Цикл
		СоставСтроки.Добавить(Строка(НомерТипа));
	КонецЦикла;
	СоставТаблицы.Добавить(СоставСтроки);
	
	Для Каждого ЭлементСписка Из ВсеТипы Цикл
		Тип = ЭлементСписка.Значение;
		ПредставлениеТипа = ЭлементСписка.Представление;
		СоставСтроки = Новый Массив;
		СоставСтроки.Добавить(ПредставлениеТипа);
		Для Каждого ОписаниеТипов Из ОписанияТипов Цикл
			ТипЕстьВОписании = РезультатСравнения[ОписаниеТипов].Найти(Тип) <> Неопределено;
			СоставСтроки.Добавить(?(ТипЕстьВОписании, "+", "-"));
		КонецЦикла;
		СоставТаблицы.Добавить(СоставСтроки);
	КонецЦикла;
	
	ОтбиватьТабами = Ложь;
	ШиринаТаба = 4;
	
	МаксШиринаКолонки = 0;
	Для Каждого СоставСтроки Из СоставТаблицы Цикл
		МаксШиринаКолонки = Макс(МаксШиринаКолонки, СтрДлина(СоставСтроки[0]));
	КонецЦикла;
	
	Если ОтбиватьТабами Тогда
		
		ШиринаКолонкиТабов = Цел(МаксШиринаКолонки / ШиринаТаба) + ?(МаксШиринаКолонки % ШиринаТаба, 1, 0);
		ФиксШиринаКолонки = ШиринаКолонкиТабов * ШиринаТаба;
		Для Каждого СоставСтроки Из СоставТаблицы Цикл
			СодержимоеКолонки = СоставСтроки[0];
			ШиринаКолонки = СтрДлина(СодержимоеКолонки);
			РазницаШирины = ФиксШиринаКолонки - ШиринаКолонки;
			ДобавитьТабов = Цел(РазницаШирины / ШиринаТаба) + ?(РазницаШирины % ШиринаТаба, 1, 0);
			Для Номер = 1 По ДобавитьТабов Цикл
				СодержимоеКолонки = СодержимоеКолонки + Символы.Таб;
			КонецЦикла;
			СоставСтроки[0] = СодержимоеКолонки;
		КонецЦикла;
		
	Иначе // Выравнивание неразрывными пробелами
		
		Для Каждого СоставСтроки Из СоставТаблицы Цикл
			СодержимоеКолонки = СоставСтроки[0];
			ШиринаКолонки = СтрДлина(СодержимоеКолонки);
			РазницаШирины = МаксШиринаКолонки - ШиринаКолонки;
			Для Номер = 1 По РазницаШирины Цикл
				СодержимоеКолонки = СодержимоеКолонки + Символы.НПП;
			КонецЦикла;
			СоставСтроки[0] = СодержимоеКолонки;
		КонецЦикла;
		
	КонецЕсли;
	
	ПредставлениеТаблицы = Новый Массив;
	РазделительКолонок = " | ";
	Для Каждого СоставСтроки Из СоставТаблицы Цикл
		ПредставлениеТаблицы.Добавить(СтрСоединить(СоставСтроки, РазделительКолонок));
	КонецЦикла;
	ПредставлениеТаблицы = СтрСоединить(ПредставлениеТаблицы, Символы.ПС);
	
	Возврат ПредставлениеТаблицы;
	
КонецФункции // СравнитьОписанияТиповСформироватьРезультатТекст()

#КонецОбласти

#Область ПримитивныеТипы

// Выделяет время из даты
//
// Параметры: 
//	Дата - Дата - Исходная дата.
//
// Возвращаемое значение:
//	Дата - Время
//
Функция ВремяИзДаты(Дата) Экспорт
	
	Возврат '00010101' + (Дата - НачалоДня(Дата));

КонецФункции

// Вычитает один период из другого.
//
// Параметры:
//  УменьшаемыйДатаНачала	 - Дата	 - Граница уменьшаемого периода.
//  УменьшаемыйДатаОкончания - Дата	 - Граница уменьшаемого периода.
//  ВычитаемыйДатаНачала	 - Дата	 - Граница вычитаемого периода.
//  ВычитаемыйДатаОкончания - Дата	 - Граница вычитаемого периода.
// 
// Возвращаемое значение:
//  Массив из Структура - Один или несколько периодов, полученные вычитанием. Элементы:
//		* ДатаНачала	 - Дата - Граница результирующего периода. 
//		* ДатаОкончания	 - Дата - Граница результирующего периода. 
//
Функция ВычестьПериод(УменьшаемыйДатаНачала, УменьшаемыйДатаОкончания, ВычитаемыйДатаНачала, ВычитаемыйДатаОкончания) Экспорт 
	
	#Область ПроверкаПараметров      
	
	Если ТипЗнч(УменьшаемыйДатаНачала) <> Тип("Дата") Тогда
		ВызватьИсключение "Параметр УменьшаемыйДатаНачала: Ожидается дата.";
	КонецЕсли;
	Если ТипЗнч(УменьшаемыйДатаОкончания) <> Тип("Дата") Тогда
		ВызватьИсключение "Параметр УменьшаемыйДатаОкончания: Ожидается дата.";
	КонецЕсли;
	Если ТипЗнч(ВычитаемыйДатаНачала) <> Тип("Дата") Тогда
		ВызватьИсключение "Параметр ВычитаемыйДатаНачала: Ожидается дата.";
	КонецЕсли;
	Если ТипЗнч(ВычитаемыйДатаОкончания) <> Тип("Дата") Тогда
		ВызватьИсключение "Параметр ВычитаемыйДатаОкончания: Ожидается дата.";
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(УменьшаемыйДатаНачала) Тогда
		ВызватьИсключение "Параметр УменьшаемыйДатаНачала: Значение не заполнено.";
	КонецЕсли;
	Если Не ЗначениеЗаполнено(УменьшаемыйДатаОкончания) Тогда
		ВызватьИсключение "Параметр УменьшаемыйДатаОкончания: Значение не заполнено.";
	КонецЕсли;
	Если Не ЗначениеЗаполнено(ВычитаемыйДатаНачала) Тогда
		ВызватьИсключение "Параметр ВычитаемыйДатаНачала: Значение не заполнено.";
	КонецЕсли;
	Если Не ЗначениеЗаполнено(ВычитаемыйДатаОкончания) Тогда
		ВызватьИсключение "Параметр ВычитаемыйДатаОкончания: Значение не заполнено.";
	КонецЕсли;     
	
	Если УменьшаемыйДатаНачала > УменьшаемыйДатаОкончания Тогда
		ВызватьИсключение "Неверно указан уменьшаемый период.";	
	КонецЕсли;
	Если ВычитаемыйДатаНачала > ВычитаемыйДатаОкончания Тогда
		ВызватьИсключение "Неверно указан вычитаемый период.";	
	КонецЕсли;
	
	#КонецОбласти // ПроверкаПараметров
	
	Результаты = Новый Массив;
	Если ВычитаемыйДатаНачала <= УменьшаемыйДатаНачала И УменьшаемыйДатаНачала <= ВычитаемыйДатаОкончания Тогда	// Вычитаемый перекрывает уменьшаемый
		Возврат Новый Массив;
	ИначеЕсли УменьшаемыйДатаНачала <= ВычитаемыйДатаНачала И ВычитаемыйДатаОкончания <= УменьшаемыйДатаОкончания Тогда	// Вычитаемый внутри уменьшаемого.
		Если УменьшаемыйДатаНачала < ВычитаемыйДатаНачала Тогда
			Результаты.Добавить(Новый Структура("ДатаНачала, ДатаОкончания", УменьшаемыйДатаНачала, ВычитаемыйДатаНачала));		
		КонецЕсли;
		Если ВычитаемыйДатаОкончания < УменьшаемыйДатаОкончания Тогда
			Результаты.Добавить(Новый Структура("ДатаНачала, ДатаОкончания", ВычитаемыйДатаОкончания, УменьшаемыйДатаОкончания));		
		КонецЕсли;
	ИначеЕсли ВычитаемыйДатаОкончания <= УменьшаемыйДатаНачала Или УменьшаемыйДатаОкончания <= ВычитаемыйДатаНачала Тогда	// Не пересекаются
		Результаты.Добавить(Новый Структура("ДатаНачала, ДатаОкончания", УменьшаемыйДатаНачала, УменьшаемыйДатаОкончания));		
	ИначеЕсли ВычитаемыйДатаНачала < УменьшаемыйДатаНачала И ВычитаемыйДатаОкончания < УменьшаемыйДатаОкончания Тогда	// Перекрытие слева.
		Результаты.Добавить(Новый Структура("ДатаНачала, ДатаОкончания", ВычитаемыйДатаОкончания, УменьшаемыйДатаОкончания));		
	ИначеЕсли УменьшаемыйДатаНачала < ВычитаемыйДатаНачала И УменьшаемыйДатаОкончания < ВычитаемыйДатаОкончания Тогда	// Перекрытие справа.
		Результаты.Добавить(Новый Структура("ДатаНачала, ДатаОкончания", УменьшаемыйДатаНачала, ВычитаемыйДатаНачала));		
	Иначе
		ВызватьИсключение "Неожиданное поведение";		
	КонецЕсли;	
	
	Возврат Результаты;

КонецФункции // ВычестьПериод()    

// Вычитает одни периоды из других.
//
// Параметры:
//  УменьшаемыеПериоды	 - Массив из Структура	 - Уменьшаемые периоды. Элементы:
//  	* ДатаНачала	 - Дата	 - Начало интервала периода
//  	* ДатаОкончания	 - Дата	 - Конец интервала периода.
//  ВычитаемыеПериоды	 - Массив из Структура	 - Аналогично УменьшаемыеПериоды.
// 
// Возвращаемое значение:
//  Массив из Структура - Результат вычитания периодов. Поля:
//  	* ДатаНачала	 - Дата	 - Начало интервала периода
//  	* ДатаОкончания	 - Дата	 - Конец интервала периода.
//
Функция ВычестьПериоды(УменьшаемыеПериоды, ВычитаемыеПериоды) Экспорт

	ПериодыРазвернуто = Новый Массив;  
	Для Каждого УменьшаемыйПериод Из УменьшаемыеПериоды Цикл
		Для каждого ВычитаемыйПериод Из ВычитаемыеПериоды Цикл
			РезультатПоПериоду = ВычестьПериод(
				УменьшаемыйПериод.ДатаНачала,
				УменьшаемыйПериод.ДатаОкончания,
				ВычитаемыйПериод.ДатаНачала,
				ВычитаемыйПериод.ДатаОкончания
			);
			Для каждого Период Из РезультатПоПериоду Цикл
				ПериодыРазвернуто.Добавить(Период);
			КонецЦикла; 
		КонецЦикла; 		
	КонецЦикла;                      
	
	УникальныеПериоды = Новый Массив;
	УникальностьПериодов = Новый Соответствие;
	Для каждого Период Из ПериодыРазвернуто Цикл
		Ветка = УникальностьПериодов[Период.ДатаНачала];
		Если Ветка = Неопределено Тогда
			Ветка = Новый Соответствие;
			УникальностьПериодов[Период.ДатаНачала] = Ветка;
		КонецЕсли;                               
		Лист = Ветка[Период.ДатаОкончания];
		Если Лист = Неопределено Тогда
			УникальныеПериоды.Добавить(Период);
			Ветка[Период.ДатаОкончания] = Период;
		Иначе
			Продолжить;
		КонецЕсли;
	КонецЦикла;     
	
	Возврат УникальныеПериоды;

КонецФункции // ()

// Получает дату с точностью до секунды
//
// Параметры:
//	Дата - Дата - Исходная дата
//
// Возвращаемое значение:
//	Дата
//
Функция ДатаБезМиллисекунд(Дата) Экспорт
	
	Возврат Дата(Год(Дата), Месяц(Дата), День(Дата), Час(Дата), Минута(Дата), Секунда(Дата));
	
КонецФункции // ДатаБезМиллисекунд()

// Объединяет указанную дату и время
//
// Параметры:
//	Дата	 - Дата - Часть даты (время отбрасывается).
//	Время	 - Дата - Часть времени (дата отбрасывается).
//
// Возвращаемое значение:
//	Дата - Указанные дата и время.
//
Функция ДатаВремя(Знач Дата, Знач Время) Экспорт

	Дата = НачалоДня(Дата);
	Время = '00010101' + (Время - НачалоДня(Время));

	Возврат Дата + (Время - '00010101');
	
КонецФункции

// Округляет число до ближайшего большего целого.
//
// Параметры:
//	Число - Число - Исходное число.
//	
// Возвращаемое значение:
//	Число - Округлённое число.
//
Функция ОкрВверх(Число) Экспорт
	
	Возврат Цел(Число) + Число(Булево(Число % 1)) * ?(Число < 0, -1, 0);

КонецФункции // ОкрВверх()

// Проверяет, является тип примитивным.
//
// Параметры:
//  Тип						 - Тип		 - Проверяемый тип
//  СчитатьТипПримитивным	 - Булево	 - Если Истина - то Тип причисляется к примитивным типам.
//
// Возвращаемое значение:
//  Булево
//
Функция ЭтоПримитивныйТип(Тип, СчитатьТипПримитивным = Истина) Экспорт
	
	Возврат Тип = Тип("Неопределено")
		ИЛИ Тип = Тип("Null")
		ИЛИ Тип = Тип("Число")
		ИЛИ Тип = Тип("Строка")
		ИЛИ Тип = Тип("Дата")
		ИЛИ Тип = Тип("Булево")
		ИЛИ Тип = Тип("Тип") И СчитатьТипПримитивным;
	
КонецФункции // ЭтоПримитивныйТип()

// Разбивает заданный период на периоды с заданной периодичностью
//
// Параметры:
//	Период	 - СтандартныйПериод - Разделяемый период
//	Периодичность	 - Строка - Вид периода.
//		Возможные значения:
//		* Минута
//		* Час
//		* День
//		* Неделя
//		* Месяц
//		* Год
//
// Возвращаемое значение:
//	Массив - Массив периодов в результате разделения. Элемент: СтандартныйПериод
//
// Пример:
//	РазделитьНаПериоды(Новый СтандартныйПериод(ВариантСтандартногоПериода.ЭтотКвартал), "Месяц"); // Вернёт массив стандартных периодов - месяцов квартала
//
Функция РазделитьНаПериоды(Период, Периодичность = "Месяц")
	
	НачалоТекущегоПериода = '00010101';
	НачалоПоследнегоПериода = '00010101';
	
	Если Периодичность = "Минута" Тогда
		НачалоТекущегоПериода = НачалоМинуты(Период.ДатаНачала);
		НачалоПоследнегоПериода = НачалоМинуты(Период.ДатаОкончания);
	ИначеЕсли Периодичность = "Час" Тогда
		НачалоТекущегоПериода = НачалоЧаса(Период.ДатаНачала);
		НачалоПоследнегоПериода = НачалоЧаса(Период.ДатаОкончания);
	ИначеЕсли Периодичность = "День" Тогда
		НачалоТекущегоПериода = НачалоДня(Период.ДатаНачала);
		НачалоПоследнегоПериода = НачалоДня(Период.ДатаОкончания);
	ИначеЕсли Периодичность = "Неделя" Тогда
		НачалоТекущегоПериода = НачалоНедели(Период.ДатаНачала);
		НачалоПоследнегоПериода = НачалоНедели(Период.ДатаОкончания);
	ИначеЕсли Периодичность = "Месяц" Тогда
		НачалоТекущегоПериода = НачалоМесяца(Период.ДатаНачала);
		НачалоПоследнегоПериода = НачалоМесяца(Период.ДатаОкончания);
	ИначеЕсли Периодичность = "Год" Тогда
		НачалоТекущегоПериода = НачалоГода(Период.ДатаНачала);
		НачалоПоследнегоПериода = НачалоГода(Период.ДатаОкончания);
	Иначе
		ВызватьИсключение "Неверно указан период";
	КонецЕсли;
	
	ГраницыПериодов = Новый Массив;
	
	Пока НачалоТекущегоПериода <= НачалоПоследнегоПериода Цикл
		
		Если Периодичность = "Минута" Тогда
			КонецТекущегоПериода = КонецМинуты(НачалоТекущегоПериода);
		ИначеЕсли Периодичность = "Час" Тогда
			КонецТекущегоПериода = КонецЧаса(НачалоТекущегоПериода);
		ИначеЕсли Периодичность = "День" Тогда
			КонецТекущегоПериода = КонецДня(НачалоТекущегоПериода);
		ИначеЕсли Периодичность = "Неделя" Тогда
			КонецТекущегоПериода = КонецНедели(НачалоТекущегоПериода);
		ИначеЕсли Периодичность = "Месяц" Тогда
			КонецТекущегоПериода = КонецМесяца(НачалоТекущегоПериода);
		ИначеЕсли Периодичность = "Год" Тогда
			КонецТекущегоПериода = КонецГода(НачалоТекущегоПериода);
		Иначе
			ВызватьИсключение "Что-то пошло не так";
		КонецЕсли;
		
		ТекущийПериод = Новый СтандартныйПериод(
				Макс(НачалоТекущегоПериода, Период.ДатаНачала),
				Мин(КонецТекущегоПериода, Период.ДатаОкончания)
			);
		ГраницыПериодов.Добавить(ТекущийПериод);
		
		НачалоТекущегоПериода = КонецТекущегоПериода + 1;
		
	КонецЦикла;
	
	Возврат ГраницыПериодов;
	
КонецФункции // РазделитьНаПериоды()

// Изменяет переданные даты так, чтобы расположить их в хронологическом порядке.
//
// Параметры:
//	ИсходныеДаты	 - Массив из Дата - Массив неупорядоченных дат.
//	Период			 - Строка - Период, которого следует придерживаться в изменении дат.
//								Возможные значения: "Минута", "Час", "День", "Месяц", "Год".
//								Измененные даты не будут выходить за этот период.
//
// Возвращаемое значение:
//	Массив из Дата - массив упорядоченных дат.
//		Каждая дата массива - это дата исходного массива, но измененная таким образом,
//		чтобы все даты в массиве шли по возрастанию.
//
Функция РаспределитьДатыПоХронологии(Знач ИсходныеДаты, Знач Период = "") Экспорт
	
	Если ТипЗнч(ИсходныеДаты) <> Тип("Массив") Тогда
		ВызватьИсключение "Параметр ИсходныеДаты: Ожидается тип Массив";
	КонецЕсли;
	
	КоличествоДат = ИсходныеДаты.Количество();
	Если КоличествоДат = 0 Тогда
		Возврат Новый Массив;
	КонецЕсли;
	
	ДатыПоХронологии = Новый Массив(КоличествоДат);
	
	ВидПериодаЛюбой = 0;
	ВидПериодаМинута = 1;
	ВидПериодаЧас = 2;
	ВидПериодаДень = 3;
	ВидПериодаМесяц = 4;
	ВидПериодаГод = 5;
	
	ШагСменыДат = 1; // В секундах
	
	#Область ГраницыПериода
	
	Если Период = "" Тогда
		ВидПериода = ВидПериодаЛюбой;
	ИначеЕсли ВРег(Период) = ВРег("День") Тогда
		ВидПериода = ВидПериодаДень;
	ИначеЕсли ВРег(Период) = ВРег("Месяц") Тогда
		ВидПериода = ВидПериодаМесяц;
	ИначеЕсли ВРег(Период) = ВРег("Год") Тогда
		ВидПериода = ВидПериодаГод;
	ИначеЕсли ВРег(Период) = ВРег("Час") Тогда
		ВидПериода = ВидПериодаЧас;
	ИначеЕсли ВРег(Период) = ВРег("Минута") Тогда
		ВидПериода = ВидПериодаМинута;
	Иначе
		ВызватьИсключение "Параметр Период: Неожиданное значение";
	КонецЕсли;
	
	ПроверятьГраницыПериода = (ВидПериода <> ВидПериодаЛюбой); // Для проверки выхода даты за день/месяц/год
	
	#КонецОбласти // ГраницыПериода
	
	НаправлениеОбходаВперед = 1;
	НаправлениеОбходаНазад = -1;
	
	МинИсходнаяДата = ИсходныеДаты[0];
	МаксИсходнаяДата = ИсходныеДаты[0];
	МаксимальныйИндекс = ИсходныеДаты.ВГраница();
	Для Индекс = 0 По МаксимальныйИндекс Цикл
		ИсходнаяДата = ИсходныеДаты[Индекс];
		Если ТипЗнч(ИсходнаяДата) <> Тип("Дата") Тогда
			ВызватьИсключение СтрШаблон(
				"Параметр ИсходныеДаты[%1]: Ожидается тип Дата",
				XMLСтрока(Индекс)
			);
		КонецЕсли;
		ДатыПоХронологии[Индекс] = ИсходныеДаты[Индекс];
		МинИсходнаяДата = Мин(МинИсходнаяДата, ИсходнаяДата);
		МаксИсходнаяДата = Макс(МаксИсходнаяДата, ИсходнаяДата);
	КонецЦикла;
	
	#Область ГраницыДат
	
	МинГраницыДат = Новый Соответствие; // Для контроля допустимого общего периода дат
	МаксГраницыДат = Новый Соответствие; // {ИсходнаяДата; Допустимая верхняя/нижняя дата}
	
	Если ПроверятьГраницыПериода Тогда
		
		// Для каждой даты назначаем индивидуальные границы смещения,
		// чтобы не передвинуть её в другой период.
		
		ГраницыПериодов = Новый Соответствие; // {НачалоПериода; ОкончаниеПериода}
		НачалоПериодаДат = Новый Соответствие; // {ИсходнаяДата; НачалоПериода}
		ФактическаяЕмкостьПериодов = Новый Соответствие; // {НачалоПериода; Количество исходных дат в периоде}
		
		НачалоПериодаПредыдущейДаты = Неопределено;
		
		// Определяем принадлежность дат к периодам:
		Для Каждого ИсходнаяДата Из ИсходныеДаты Цикл
			
			НачалоПериода = НачалоПериодаДат[ИсходнаяДата];
			Если НачалоПериода = Неопределено Тогда
				Если ВидПериода = ВидПериодаДень Тогда
					НачалоПериода = НачалоДня(ИсходнаяДата);
					ОкончаниеПериода = КонецДня(ИсходнаяДата);
				ИначеЕсли ВидПериода = ВидПериодаМесяц Тогда
					НачалоПериода = НачалоМесяца(ИсходнаяДата);
					ОкончаниеПериода = КонецМесяца(ИсходнаяДата);
				ИначеЕсли ВидПериода = ВидПериодаГод Тогда
					НачалоПериода = НачалоГода(ИсходнаяДата);
					ОкончаниеПериода = КонецГода(ИсходнаяДата);
				ИначеЕсли ВидПериода = ВидПериодаЧас Тогда
					НачалоПериода = НачалоЧаса(ИсходнаяДата);
					ОкончаниеПериода = КонецЧаса(ИсходнаяДата);
				ИначеЕсли ВидПериода = ВидПериодаМинута Тогда
					НачалоПериода = НачалоМинуты(ИсходнаяДата);
					ОкончаниеПериода = КонецМинуты(ИсходнаяДата);
				Иначе
					ВызватьИсключение "Неожиданное поведение";
				КонецЕсли;
				ГраницыПериодов[НачалоПериода] = ОкончаниеПериода;
				НачалоПериодаДат[ИсходнаяДата] = НачалоПериода;
			Иначе
				ОкончаниеПериода = ГраницыПериодов[НачалоПериода];
			КонецЕсли;
			
			ФактЕмкостьПериода = ФактическаяЕмкостьПериодов[НачалоПериода];
			Если ФактЕмкостьПериода = Неопределено Тогда
				ФактЕмкостьПериода = 0;
			КонецЕсли;
			ФактическаяЕмкостьПериодов[НачалоПериода] = ФактЕмкостьПериода + 1;
			
			// Проверка возможности переноса даты в другой период:
			Если НачалоПериодаПредыдущейДаты <> Неопределено
				И НачалоПериодаПредыдущейДаты > НачалоПериода Тогда
				ВызватьИсключение СтрШаблон(
					"Невозможно отсортировать даты по периоду %1: Даты расположены в убывающих периодах",
					ТРег(Период));
			КонецЕсли;
			НачалоПериодаПредыдущейДаты = НачалоПериода;
			
		КонецЦикла;
		
		// Определяем фактические границы периодов
		Для Каждого ГраницаПериода Из ГраницыПериодов Цикл
			
			НачалоПериода = ГраницаПериода.Ключ;
			ОкончаниеПериода = ГраницаПериода.Значение;
			МаксЕмкостьПериода = Цел((ОкончаниеПериода - НачалоПериода) / ШагСменыДат) + 1;
			ФактЕмкостьПериода = ФактическаяЕмкостьПериодов[НачалоПериода];
			Если ФактЕмкостьПериода > МаксЕмкостьПериода Тогда
				ВызватьИсключение "Слишком много дат, чтобы разместить в периоде " + ТРег(Период);
			КонецЕсли;
			
		КонецЦикла;
		
		// Отдельно решаем, как быть с граничными датами.
		Для Каждого НачалоПериодаДаты Из НачалоПериодаДат Цикл
			
			ИсходнаяДата = НачалоПериодаДаты.Ключ;
			НачалоПериода = НачалоПериодаДаты.Значение;
			ОкончаниеПериода = ГраницыПериодов[НачалоПериода];
			ФактЕмкостьПериода = ФактическаяЕмкостьПериодов[НачалоПериода];
			КоличествоШаговСменыДат = (ФактЕмкостьПериода - 1);
			ДиапазонДат = КоличествоШаговСменыДат * ШагСменыДат;
			
			Если МинИсходнаяДата > НачалоПериода И МаксИсходнаяДата < ОкончаниеПериода Тогда
				
				// Все исходные даты помещаются в один период.
				// Раздвигаем окно допустимых дат сначала к концу периода, затем к началу.
				
				МаксГраницаДаты = Мин(Макс(МаксИсходнаяДата, МинИсходнаяДата + ДиапазонДат), ОкончаниеПериода);
				МинГраницаДаты = Макс(Мин(МинИсходнаяДата, МаксГраницаДаты - ДиапазонДат), НачалоПериода);
				
			ИначеЕсли МинИсходнаяДата > НачалоПериода Тогда
				МинГраницаДаты = Мин(МинИсходнаяДата, ОкончаниеПериода - ДиапазонДат);
				МаксГраницаДаты = ОкончаниеПериода;
				
			ИначеЕсли ОкончаниеПериода > МаксИсходнаяДата Тогда
				МинГраницаДаты = НачалоПериода;
				МаксГраницаДаты = Макс(МаксИсходнаяДата, НачалоПериода + ДиапазонДат);
				
			Иначе
				МинГраницаДаты = НачалоПериода;
				МаксГраницаДаты = ОкончаниеПериода;
				
			КонецЕсли;
			
			МинГраницыДат[ИсходнаяДата] = МинГраницаДаты;
			МаксГраницыДат[ИсходнаяДата] = МаксГраницаДаты;
			
		КонецЦикла;
		
	Иначе
		МинимальнаяДата = МинИсходнаяДата;
		МаксимальнаяДата = Макс(МаксИсходнаяДата, МинИсходнаяДата + (КоличествоДат - 1) * ШагСменыДат);
		Для Каждого ИсходнаяДата Из ИсходныеДаты Цикл
			МинГраницыДат[ИсходнаяДата] = МинимальнаяДата;
			МаксГраницыДат[ИсходнаяДата] = МаксимальнаяДата;
		КонецЦикла;
	КонецЕсли;
	
	#КонецОбласти // ГраницыДат
	
	#Область ОсновнойОбход
	
	Индекс = 0;
	НаправлениеОбхода = НаправлениеОбходаВперед;
	Пока Истина Цикл
		
		ИсходнаяДата = ИсходныеДаты[Индекс];
		ТекущаяДата = ДатыПоХронологии[Индекс];
		МинГраницаДаты = МинГраницыДат[ИсходнаяДата];
		МаксГраницаДаты = МаксГраницыДат[ИсходнаяДата];
		
		ЭтоОбходВперед = (НаправлениеОбхода = НаправлениеОбходаВперед);
		
		ЭтоПервыйЭлемент = (Индекс = ?(ЭтоОбходВперед, 0, МаксимальныйИндекс));
		ЭтоПоследнийЭлемент = (Индекс = ?(ЭтоОбходВперед, МаксимальныйИндекс, 0));
		
		Если ЭтоПервыйЭлемент Тогда
			МассивДатОтсортирован = Истина;
			ПредыдущаяДата = ?(ЭтоОбходВперед,
					МинГраницаДаты - ШагСменыДат,
					МаксГраницаДаты + ШагСменыДат);
		Иначе
			ПредыдущаяДата = ДатыПоХронологии[Индекс - 1 * НаправлениеОбхода];
		КонецЕсли;
		Если ЭтоПоследнийЭлемент Тогда
			СледующаяДата = ?(ЭтоОбходВперед,
					МаксГраницаДаты,
					МинГраницаДаты);
		Иначе
			СледующаяДата = ДатыПоХронологии[Индекс + 1 * НаправлениеОбхода];
			Если ((ТекущаяДата - СледующаяДата) * НаправлениеОбхода) > 0 Тогда
				ТекущаяДата = СледующаяДата;
			КонецЕсли;
		КонецЕсли;
		
		Если ((ТекущаяДата - СледующаяДата) * НаправлениеОбхода) > 0 Тогда
			ТекущаяДата = СледующаяДата;
		КонецЕсли;
		
		// Нижняя граница или предыдущий элемент
		ЭлементОтсортирован = ((ТекущаяДата - ПредыдущаяДата) * НаправлениеОбхода) > 0; // Верно для обоих обходов
		Если НЕ ЭлементОтсортирован Тогда
			ТекущаяДата = ПредыдущаяДата + ШагСменыДат * НаправлениеОбхода;
		КонецЕсли;
		
		Если ТекущаяДата <> ДатыПоХронологии[Индекс] Тогда
			// Запоминаем дату, потом повторим проверку
			ДатыПоХронологии[Индекс] = ТекущаяДата;
			Продолжить;
		КонецЕсли;
		
		// Верхняя граница
		НадоРазвернутьОбход = Ложь;
		ГраницаДаты = ?(ЭтоОбходВперед, МаксГраницаДаты, МинГраницаДаты);
		ТекущаяДатаВыходитЗаГраницу = ((ТекущаяДата - ГраницаДаты) * НаправлениеОбхода) > 0;
		Если ТекущаяДатаВыходитЗаГраницу Тогда
			ДатыПоХронологии[Индекс] = ГраницаДаты;
			МассивДатОтсортирован = Ложь;
		КонецЕсли;
		
		// Последний элемент и условие выхода из цикла
		Если ЭтоПоследнийЭлемент Тогда
			Если МассивДатОтсортирован Тогда
				Прервать; // Всё отсортировали.
			Иначе
				НадоРазвернутьОбход = Истина;
			КонецЕсли;
		КонецЕсли;
		
		Если НадоРазвернутьОбход Тогда
			МассивДатОтсортирован = Ложь;
			НаправлениеОбхода = ?(ЭтоОбходВперед, НаправлениеОбходаНазад, НаправлениеОбходаВперед);
			Продолжить; // Чтобы повторно обработать этот элемент
		КонецЕсли;
		
		Индекс = Индекс + 1 * НаправлениеОбхода;
		
	КонецЦикла;
	
	#КонецОбласти // ОсновнойОбход
	
	Возврат ДатыПоХронологии;
	
КонецФункции // РаспределитьДатыПоХронологии()

// Размещает события в доступных окнах периода.
//
// Параметры:
//  События		 - Соответствие	 - Элементы:
//		* Ключ		 - Произвольный	 - Событие для размещения.
//		* Значение	 - Число		 - Длительность события в секундах.
//	Периоды		 - Массив из Структура - Доступные периоды. Элементы:
//  	* ДатаНачала	 - Дата	 - Начало интервала периода
//  	* ДатаОкончания	 - Дата	 - Конец интервала периода.
// 
// Возвращаемое значение:
//  Соответствие - Размещенные элементы. Элементы:
//		* Ключ		 - Соответствует ключу исходного события.
//		* Значение	 - Дата - Дата начала размещенного события.
//		Если элемент разместить не удалось, он не будет присутствовать в коллекции.
//
Функция РазместитьСобытияВПериодах(Знач События, Периоды) Экспорт
	
	Если Не ЗначениеЗаполнено(События) Или Не ЗначениеЗаполнено(Периоды) Тогда
		Возврат Новый Соответствие;
	КонецЕсли;
	
	ПараметрыПериодов = Новый Массив;
	Для ИндексПериода = 0 По Периоды.Вграница() Цикл 
		Период = Периоды[ИндексПериода];
		Если Не ЗначениеЗаполнено(Период.ДатаНачала) Тогда
			ВызватьИсключение СтрШаблон("Период [%1]: Не заполнена ДатаНачала.", ИндексПериода);
		КонецЕсли;
		Если Не ЗначениеЗаполнено(Период.ДатаОкончания) Тогда
			ВызватьИсключение СтрШаблон("Период [%1]: Не заполнена ДатаОкончания.", ИндексПериода);
		КонецЕсли;
		Если Период.ДатаНачала > Период.ДатаОкончания Тогда
			ВызватьИсключение СтрШаблон("Период [%1]: Неверно указан период.", ИндексПериода);
		КонецЕсли;
		Длительность = Период.ДатаОкончания - Период.ДатаНачала;
		ПараметрыПериода = Новый Структура;
		ПараметрыПериода.Вставить("ДатаНачала",		 Период.ДатаНачала);
		ПараметрыПериода.Вставить("ДатаОкончания",	 Период.ДатаОкончания);
		ПараметрыПериода.Вставить("Вершина",		 ПараметрыПериода.ДатаНачала);	// Дата начала остатка периода
		ПараметрыПериода.Вставить("ДоступныйОбъем",	 Длительность);					// Доступный остаток периода в секундах.
		
		ПараметрыПериодов.Добавить(ПараметрыПериода);
	КонецЦикла;   
	
	// Сортируем события по длительности, чтобы первыми разместить наиболее продолжительные:
	СобытияПоУбываниюДлительности = Новый СписокЗначений;
	ИдентификаторыСобытий = Новый Соответствие;
	Для каждого Событие Из События Цикл
		Идентификатор = Строка(Новый УникальныйИдентификатор);     
		ИдентификаторыСобытий[Идентификатор] = Событие.Ключ;
		СобытияПоУбываниюДлительности.Добавить(Событие.Значение, Идентификатор);
	КонецЦикла;
	СобытияПоУбываниюДлительности.СортироватьПоЗначению(НаправлениеСортировки.Убыв); 
	
	РазмещениеСобытий = Новый Соответствие;
	
	// Распределяем события по методу Best Fit: События помещаются в тот интервал, где останется минимум свободного места:
	Для каждого ТекущееСобытие Из СобытияПоУбываниюДлительности Цикл
		ДлительностьСобытия = ТекущееСобытие.Значение;
		МинимальныйОстаток = Неопределено;
		ИндексПериодаРазмещения = Неопределено;
		Для ИндексПериода = 0 По ПараметрыПериодов.ВГраница() Цикл
			ПараметрыПериода = ПараметрыПериодов[ИндексПериода];
			РасчетныйОстаток = ПараметрыПериода.ДоступныйОбъем - ДлительностьСобытия;
			Если РасчетныйОстаток >= 0 И (МинимальныйОстаток = Неопределено Или РасчетныйОстаток < МинимальныйОстаток) Тогда
				ИндексПериодаРазмещения = ИндексПериода;
				МинимальныйОстаток = РасчетныйОстаток
			КонецЕсли;
		КонецЦикла;   
		Если ИндексПериодаРазмещения <> Неопределено Тогда
			ПараметрыПериода = ПараметрыПериодов[ИндексПериодаРазмещения]; 
			
			Событие = ИдентификаторыСобытий[ТекущееСобытие.Представление];
			РазмещениеСобытий[Событие] = ПараметрыПериода.Вершина;
			
			ПараметрыПериода.ДоступныйОбъем = МинимальныйОстаток;
			ПараметрыПериода.Вершина = ПараметрыПериода.Вершина + ДлительностьСобытия;
		КонецЕсли;
	КонецЦикла; 	                                       
	
	Возврат РазмещениеСобытий;
	
КонецФункции // РазместитьСобытияВПериодах()

// Определяет, является ли год високосным.
//
// Параметры:
//	Год	- Дата, Число - Проверяемая дата или год.
//
// Возвращаемое значение:
//	Булево	 - Истина, если год является високосным.
//
Функция ЭтоВисокосныйГод(Знач Год) Экспорт
	
	// см. https://learn.microsoft.com/ru-ru/office/troubleshoot/excel/determine-a-leap-year
	
	Если ТипЗнч(Год) = Тип("Дата") Тогда
		Год = Год(Год);
	КонецЕсли;
	Если ТипЗнч(Год) <> Тип("Число") Тогда
		ВызватьИсключение "Параметр Год: Ожидается тип Дата или Число";
	КонецЕсли;
	
	Возврат (Год % 4 = 0) И НЕ (Год % 100 = 0 И Год % 400 > 0);
	
КонецФункции

#КонецОбласти // ПримитивныеТипы

#Область Объекты

// Проверяет наличие свойства у произвольного объекта.
//
// Параметры:
//  Объект		 - Произвольный	 - Объект со свойствами.
//  ИмяСвойства	 - Строка		 - Имя проверяемого свойства.
//
// Возвращаемое значение:
//   Булево   - Истина, если свойство присутствует в объекте.
//
Функция ЕстьСвойство(Объект, ИмяСвойства) Экспорт

	Если ТипЗнч(Объект) = Тип("Структура") Тогда
		Возврат Объект.Свойство(ИмяСвойства);
	КонецЕсли;

	ЗначениеЕслиСвойстваНет = Новый УникальныйИдентификатор();
	Проверка = Новый Структура(ИмяСвойства, ЗначениеЕслиСвойстваНет);
	ЗаполнитьЗначенияСвойств(Проверка, Объект);

	Возврат Проверка[ИмяСвойства] <> ЗначениеЕслиСвойстваНет;

КонецФункции // ЕстьСвойство

// Получает свойство объекта по имени, не вызывая исключение.
//
// Параметры:
//  Объект				 - Произвольный	 - Объект со свойствами.
// 	ИмяСвойства			 - Строка - Имя проверяемого свойства. 
// 						Может быть указано как составной путь через точку, либо индекс элемента коллекции.
//						Например, "Свойство[0].Поле".
//  ИмяСвойства			 - Строка		 - Имя проверяемого свойства. 
//	ЗначениеПоУмолчанию	 - Произвольный	 - Возвращаемое значение, если свойство объекта отсутствует.
//
// Возвращаемое значение:
//   Произвольный	- Значение свойства объекта, или ЗначениеПоУмолчанию, если свойства нет.
//
Функция ЗначениеСвойства(Объект, Знач ИмяСвойства, ЗначениеПоУмолчанию = Неопределено) Экспорт

	Разделители = "[.";
	ЕстьРазделители = СтрНайти(ИмяСвойства, ".") Или СтрНайти(ИмяСвойства, "[");

	ПростойРежим = Не ЕстьРазделители;
	Если ПростойРежим Тогда

		Если ЕстьСвойство(Объект, ИмяСвойства) Тогда
			Возврат Объект[ИмяСвойства];
		КонецЕсли;

	Иначе

		ИмяИлиИндекс = Неопределено; 
		ЭтоИндекс = СтрНачинаетсяС(ИмяСвойства, "[");
		Если Не ЭтоИндекс Тогда
			ИмяИлиИндекс = "";
			Для НомерСимвола = 1 По СтрДлина(ИмяСвойства) Цикл
				Символ = Сред(ИмяСвойства, НомерСимвола, 1); 
				Если СтрНайти(Разделители, Символ) Тогда
					Прервать;
				КонецЕсли;
				ИмяИлиИндекс = ИмяИлиИндекс + Символ;
			КонецЦикла;
			Если ЕстьСвойство(Объект, ИмяИлиИндекс) Тогда
			КонецЕсли;
			ОстатокПути = Сред(ИмяСвойства, НомерСимвола + 1);
		Иначе
			ПозицияЗакрывающейСкобки = СтрНайти(ИмяСвойства, "]");
			Если ПозицияЗакрывающейСкобки = 0 Тогда
				ВызватьИсключение "Параметр ИмяСвойства: Не найдено закрывающей скобки в имени свойства";
			КонецЕсли;
			ИндексСтрокой = Сред(ИмяСвойства, 2, ПозицияЗакрывающейСкобки - 2);
			ИмяИлиИндекс = Число(ИндексСтрокой);
			ОстатокПути = Сред(ИмяСвойства, ПозицияЗакрывающейСкобки + 1);
		КонецЕсли;

		Если ИмяИлиИндекс = Неопределено Тогда
			ВызватьИсключение СтрШаблон(
				"Параметр ИмяСвойства: Не найдено имя или индекс свойства в строке %1",
				XMLСтрока(ИмяСвойства));
		КонецЕсли;

		Значение = Объект[ИмяИлиИндекс];
		ОстатокПути = Сред(ИмяСвойства, НомерСимвола + 1);
		Если Не ПустаяСтрока(ОстатокПути) Тогда
			Возврат ЗначениеСвойства(Объект[ИмяИлиИндекс], ОстатокПути, ЗначениеПоУмолчанию);
		Иначе
			Возврат Значение;		
		КонецЕсли;

	КонецЕсли;
	
	Возврат ЗначениеПоУмолчанию;

КонецФункции

// Переносит свойства источника приемнику по произвольным ключам.
//
// Параметры:
//	Приемник - Произвольный  - Объект-приемник.
//	Источник - Произвольный  - Объект-источник.
//	Свойства - Структура	 - Ключи источника и приемника. Элементы:
//				* Ключ		 - Строка		 - Имя свойства приемника.
//				* Значение	 - Произвольный	 - Ключ Источника.
//			 - Соответствие	 - Ключи источника и приемника. Элементы:
//				* Ключ		 - Произвольный	 - Ключ Приемника.
//				* Значение	 - Произвольный	 - Ключ Источника.
//
// Варианты вызова:
//	ПеренестиЗначенияСвойств(Произвольный, Произвольный, Структура)		 - Перенос свойств по строковым ключам
//	ПеренестиЗначенияСвойств(Произвольный, Произвольный, Соответствие)	 - Перенос свойств по индексам,
//																			 или ключам произвольного типа.
//
Процедура ПеренестиЗначенияСвойств(Приемник, Источник, Свойства) Экспорт
	
	Если ТипЗнч(Свойства) <> Тип("Структура")
		И ТипЗнч(Свойства) <> Тип("Соответствие") Тогда
		ВызватьИсключение "Параметр Свойства: Ожидается: Структура, Соответствие";
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(Свойства) Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Свойство Из Свойства Цикл
		КлючИсточника = Свойство.Значение;
		КлючПриемника = Свойство.Ключ;
		Приемник[КлючПриемника] = Источник[КлючИсточника];
	КонецЦикла;
	
КонецПроцедуры // ПеренестиЗначенияСвойств()

// Получает всех родителей элемента рекурсивно.
// Например, все родители элемента формы или строки дерева.
//
// Параметры:
//	Элемент 			 - Произвольный	 - Элемент, имеющий поле родителя.
//	СвойствоРодитель	 - Строка		 - Имя свойства элемента, содержащего ссылку на родителя.
//	СлужебныеПараметры	 - Произвольный	 - Служебные параметры.
//
// Возвращаемое значение:
//	Массив из Произвольный - Родители элемента в порядке удаления. Первый элемент - непосредственный родитель.
//		Примитивные типы, такие как Неопределено, не считаются родителями, и не включаются в возвращаемое значение.
//
Функция Родители(Элемент, СвойствоРодитель = "Родитель", СлужебныеПараметры = Неопределено) Экспорт
	
	Если СлужебныеПараметры = Неопределено Тогда
		ПримитивныеТипы = Новый Массив;
		ПримитивныеТипы.Добавить(Тип("Неопределено"));
		ПримитивныеТипы.Добавить(Тип("Число"));
		ПримитивныеТипы.Добавить(Тип("Строка"));
		ПримитивныеТипы.Добавить(Тип("Дата"));
		ПримитивныеТипы.Добавить(Тип("Булево"));
		ПримитивныеТипы.Добавить(Тип("УникальныйИдентификатор"));
		ПримитивныеТипы = Новый ОписаниеТипов(ПримитивныеТипы);
		СлужебныеПараметры = Новый Структура;
		СлужебныеПараметры.Вставить("ПримитивныеТипы", ПримитивныеТипы);
	КонецЕсли;

	Родители = Новый Массив;

	СлучайныйИдентификатор = Новый УникальныйИдентификатор();
	ЗначениеРодитель = Новый Структура(СвойствоРодитель, СлучайныйИдентификатор);
	Попытка
		ЗаполнитьЗначенияСвойств(ЗначениеРодитель, Элемент);
	Исключение
		Возврат Родители;	// Элемент не содержит полей.
	КонецПопытки;
	ЕстьРодитель = ЗначениеРодитель[СвойствоРодитель] <> СлучайныйИдентификатор;
	Если ЕстьРодитель Тогда

		Родитель = ЗначениеРодитель[СвойствоРодитель];
		РодительЭтоПримитивный = СлужебныеПараметры.ПримитивныеТипы.СодержитТип(ТипЗнч(Родитель));
		Если РодительЭтоПримитивный Тогда
			Возврат Родители;	// Их быть не может.
		КонецЕсли;
	
		Родители.Добавить(Родитель);
		Для каждого Предок Из Родители(Родитель) Цикл
			Родители.Добавить(Предок);
		КонецЦикла;

	КонецЕсли;

	Возврат Родители;

КонецФункции

#КонецОбласти // Объекты

#Область Коллекции

#Область Агрегаты

// Вычисляет агрегатную функцию по значениям поля коллекции.
//
// Параметры:
//	Коллекция			 - Произвольный	 - Коллекция, для которой доступен обход "Для Каждого ... Из ... Цикл"
//	АгрегатнаяФункция	 - Строка	 - Агрегатная функция. Допустимые значения:
//		* Сумма					- Сравниваются числа. Для пустой коллекции возвращает 0.
//		* Среднее				- Сравниваются числа. Для пустой коллекции возвращает 0.
//		* Минимум				- На клиенте сравнивает только примитивные типы, на сервере - см. СравнениеЗначений.
//		* Максимум				- см. Минимум. Для пустой коллекции возвращает Неопределено.
//		* Количество			- Для пустой коллекции возвращает 0.
//		* КоличествоРазличных	- Для пустой коллекции возвращает 0.
//		* Любой					- Проверяются только значения типа Булево. Для пустой коллекции возвращает Ложь.
//		* Каждый				- Проверяются только значения типа Булево. Для пустой коллекции возвращает Ложь.
//	Поле				 - Строка	 - Имя поля коллекции
//						 - Число	 - Индекс поля коллекции
//						Может быть не указано, если в качестве коллекции выступает Массив
//						В этом случае, агрегат рассчитывается по элементам переданного массива.
//
// Возвращаемое значение:
//	Произвольный - Значение агрегата.
//
Функция Агрегат(Знач Коллекция, АгрегатнаяФункция = "Сумма", Поле = Неопределено) Экспорт

	Если ТипЗнч(Поле) = Тип("Строка") Или ТипЗнч(Поле) = Тип("Число") Тогда
		Значения = Новый Массив;
		Для Каждого ЭлементКоллекции Из Коллекция Цикл
			Значения.Добавить(ЭлементКоллекции[Поле]);
		КонецЦикла;
	ИначеЕсли Поле = Неопределено Тогда
		Если ТипЗнч(Коллекция) = Тип("Массив") Тогда
			Значения = Коллекция;
		Иначе
			ВызватьИсключение "Параметр Поле: Ожидается значение.";
		КонецЕсли;
	Иначе
		ВызватьИсключение "Параметр Поле: Неожиданный тип значения.";
	КонецЕсли;

	Если ТипЗнч(Значения) <> Тип("Массив") Тогда
		ВызватьИсключение "Параметр Значения: Ожидается Массив";
	КонецЕсли;
	
	АгрегатнаяФункцияВрег = ВРег(АгрегатнаяФункция);
	
	Если АгрегатнаяФункцияВрег = "СУММА" Тогда
		Возврат Сумма(Значения);

	ИначеЕсли АгрегатнаяФункцияВрег = "СРЕДНЕЕ" Тогда
		Возврат Среднее(Значения);

	ИначеЕсли АгрегатнаяФункцияВрег = "МИНИМУМ"  Тогда
		Возврат Минимум(Значения);

	ИначеЕсли АгрегатнаяФункцияВрег = "МАКСИМУМ"  Тогда
		Возврат Максимум(Значения);

	ИначеЕсли АгрегатнаяФункцияВрег = "КОЛИЧЕСТВО" Тогда
		Возврат Количество(Значения);

	ИначеЕсли АгрегатнаяФункцияВрег = "КОЛИЧЕСТВОРАЗЛИЧНЫХ" Тогда
		Возврат КоличествоРазличных(Значения);

	ИначеЕсли АгрегатнаяФункцияВрег = "ЛЮБОЙ" Тогда
		Возврат Любой(Значения);

	ИначеЕсли АгрегатнаяФункцияВрег = "КАЖДЫЙ" Тогда
		Возврат Каждый(Значения);

	Иначе
		ВызватьИсключение "Параметр АгрегатнаяФункция: Непредвиденное значение";

	КонецЕсли;

	Возврат Неопределено;
		
КонецФункции // АгрегатКоллекции()

// Рассчитывает сумму числовых элементов массива.
//
// Параметры: 
//	Значения - Массив - Массив значений.
//
// Возвращаемое значение:
//	Число - Для пустой коллекции возвращается 0.
//
Функция Сумма(Значения) Экспорт

	Сумма = 0;
	Для Каждого ТекущееЗначение Из Значения Цикл
		Если ТипЗнч(ТекущееЗначение) = Тип("Число") Тогда
			Сумма = Сумма + ТекущееЗначение;
		КонецЕсли;
	КонецЦикла; 

	Возврат Сумма;

КонецФункции

// Рассчитывает среднее значение числовых элементов массива.
//
// Параметры: 
//	Значения - Массив - Массив значений.
//
// Возвращаемое значение:
//	Число - Для пустой коллекции возвращается 0.
//
Функция Среднее(Значения) Экспорт

	Сумма = 0;
	КоличествоЗначений = 0;
	Для Каждого ТекущееЗначение Из Значения Цикл
		Если ТипЗнч(ТекущееЗначение) = Тип("Число") Тогда
			Сумма = Сумма + ТекущееЗначение;
			КоличествоЗначений = КоличествоЗначений + 1;
		КонецЕсли;
	КонецЦикла;
	Среднее = ?(КоличествоЗначений = 0, 0, Сумма / КоличествоЗначений);

	Возврат Среднее; 

КонецФункции

// Рассчитывает минимальное значение элементов массива.
//
// Параметры: 
//	Значения		 - Массив				 - Массив значений.
//	ОбъектСравнения	 - СравнениеЗначений	 - Если задан, то:
//		* объекты сравниваются по идентификатору;
//		* моменты времени сравниваются по дате и идентификатору объекта;
//		* элементы остальных типов сравниваются по строковому представлению.
//
// Возвращаемое значение:
//	Число, Строка, Дата, Булево - Для пустой коллекции возвращается Неопределено.
//
Функция Минимум(Значения, ОбъектСравнения = Неопределено) Экспорт

	Если Не ЗначениеЗаполнено(Значения) Тогда
		Возврат Неопределено;
	КонецЕсли;

	Минимум = Значения[0];
	ИспользоватьСравнениеЗначений = Ложь;

	#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	ИспользоватьСравнениеЗначений = (ТипЗнч(ОбъектСравнения) = Тип("СравнениеЗначений"));
	#КонецЕсли

	Если ИспользоватьСравнениеЗначений Тогда
		Для Каждого ТекущееЗначение Из Значения Цикл
			РезультатСравнения = ОбъектСравнения.Сравнить(ТекущееЗначение, Минимум);
			Если РезультатСравнения < 0 Тогда
				Минимум = ТекущееЗначение;
			КонецЕсли;
		КонецЦикла;
	Иначе	
		Для Каждого ТекущееЗначение Из Значения Цикл
			Минимум = Мин(Минимум, ТекущееЗначение);
		КонецЦикла;
	КонецЕсли;

	Возврат Минимум;

КонецФункции

// Рассчитывает максимальное значение элементов массива.
//
// Параметры: 
//	Значения		 - Массив				 - Массив значений.
//	ОбъектСравнения	 - СравнениеЗначений	 - Если задан, то:
//		* объекты сравниваются по идентификатору;
//		* моменты времени сравниваются по дате и идентификатору объекта;
//		* элементы остальных типов сравниваются по строковому представлению.
//
// Возвращаемое значение:
//	Число, Строка, Дата, Булево - Для пустой коллекции возвращается Неопределено. Для сервера, см. СравнениеЗначений.
//
Функция Максимум(Значения, ОбъектСравнения = Неопределено) Экспорт

	Если Не ЗначениеЗаполнено(Значения) Тогда
		Возврат Неопределено;
	КонецЕсли;

	Максимум = Значения[0];
	ИспользоватьСравнениеЗначений = Ложь;

	#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	ИспользоватьСравнениеЗначений = (ТипЗнч(ОбъектСравнения) = Тип("СравнениеЗначений"));
	#КонецЕсли

	Если ИспользоватьСравнениеЗначений Тогда
		Для Каждого ТекущееЗначение Из Значения Цикл
			РезультатСравнения = ОбъектСравнения.Сравнить(ТекущееЗначение, Максимум);
			Если РезультатСравнения > 0 Тогда
				Максимум = ТекущееЗначение;
			КонецЕсли;
		КонецЦикла;
	Иначе	
		Для Каждого ТекущееЗначение Из Значения Цикл
			Максимум = Макс(Максимум, ТекущееЗначение);
		КонецЦикла;
	КонецЕсли;

	Возврат Максимум;

КонецФункции

// Рассчитывает количество элементов коллекции.
//
// Параметры: 
//	Коллекция	 - Массив, Произвольный - Коллекция элементов, или Массив значений.
//
// Возвращаемое значение:
//	Число - Количество элементов коллекции.
//
Функция Количество(Коллекция) Экспорт

	Если ТипЗнч(Коллекция) = Тип("Массив") Тогда
		ЭлементыКоллекции = Коллекция;
	Иначе
		ЭлементыКоллекции = Новый Массив;
		Для каждого ЭлементКоллекции Из Коллекция Цикл
			ЭлементыКоллекции.Добавить(ЭлементКоллекции);
		КонецЦикла;
	КонецЕсли;

	Возврат ЭлементыКоллекции.Количество();

КонецФункции

// Рассчитывает количество различных элементов массива.
//
// Параметры: 
//	Значения - Массив - Массив значений.
//
// Возвращаемое значение:
//	Число - Количество различных элементов массива.
//
Функция КоличествоРазличных(Значения) Экспорт

	ЕстьНеопределено = Ложь;
	РазличныеЗначения = Новый Соответствие;
	Для Каждого ТекущееЗначение Из Значения Цикл
		РазличныеЗначения.Вставить(ТекущееЗначение);
		Если ТекущееЗначение = Неопределено Тогда
			ЕстьНеопределено = Истина;
		КонецЕсли;
	КонецЦикла;
	КоличествоРазличных = РазличныеЗначения.Количество() + ?(ЕстьНеопределено, 1, 0);

	Возврат КоличествоРазличных; 

КонецФункции

// Проверяет, содержится ли булево значение Истина в массиве.
//
// Параметры: 
//	Значения - Массив - Массив значений.
//
// Возвращаемое значение:
//	Булево - В коллекции содержится Булево = Истина.
//
Функция Любой(Значения) Экспорт

	Возврат Значения.Найти(Истина) <> Неопределено;

КонецФункции

// Проверяет, все ли булевы значения в массиве равны Истина.
//
// Параметры: 
//	Значения - Массив - Массив значений.
//
// Возвращаемое значение:
//	Булево - В коллекции все значения типа Булево равны Истина.
//
Функция Каждый(Значения) Экспорт

	Каждый = Значения.Найти(Истина) <> Неопределено И Значения.Найти(Ложь) = Неопределено;
	
	Возврат Каждый; 

КонецФункции

#КонецОбласти // Агрегаты

#Область Деревья

// Получает коллекцию подчиненных элементов
//
// Параметры:
//  Узел - ДанныеФормыДерево, ДанныеФормыЭлементДерева, ДеревоЗначений, СтрокаДереваЗначений - Узел или корень дерева
//
// Возвращаемое значение:
//   - ДанныеФормыКоллекцияЭлементовДерева, КоллекцияСтрокДереваЗначений
//
Функция ВетвиДерева(Узел)
	
	ЭтоЭлементДереваФормы = ТипЗнч(Узел) = Тип("ДанныеФормыЭлементДерева")
		ИЛИ ТипЗнч(Узел) = Тип("ДанныеФормыДерево");
	
	Возврат ?(ЭтоЭлементДереваФормы, Узел.ПолучитьЭлементы(), Узел.Строки)
	
КонецФункции // ВетвиДерева()

// Получает конечные элементы предоставленной коллекции
//
// Параметры:
//  Узел - ДанныеФормыДерево, ДанныеФормыЭлементДерева
//		 - ДеревоЗначений, СтрокаДереваЗначений
//
// Возвращаемое значение:
//   - Массив из ДанныеФормыЭлементДерева
//	 - Массив из СтрокаДереваЗначений
//
Функция ЛистьяДерева(Узел) Экспорт
	
	ВозвращаемоеЗначение = Новый Массив;
	Ветви = ВетвиДерева(Узел);
	Если ЗначениеЗаполнено(Ветви) Тогда
		Для Каждого Ветвь Из Ветви Цикл
			Для Каждого Лист Из ЛистьяДерева(Ветвь) Цикл
				ВозвращаемоеЗначение.Добавить(Лист);
			КонецЦикла;
		КонецЦикла;
	Иначе
		ВозвращаемоеЗначение.Добавить(Узел);
	КонецЕсли;
	
	Возврат ВозвращаемоеЗначение;
	
КонецФункции // ЛистьяДерева()

// Получает рекурсивно все элементы, подчиненные переданному узлу дерева.
//
// Параметры:
//  Узел - ДанныеФормыДерево, ДанныеФормыЭлементДерева
//		 - ДеревоЗначений, СтрокаДереваЗначений
//
// Возвращаемое значение:
//   - Массив из ДанныеФормыЭлементДерева
//	 - Массив из СтрокаДереваЗначений
//
Функция УзлыДерева(Узел) Экспорт

	ВозвращаемоеЗначение = Новый Массив;
	Для каждого Ветвь Из ВетвиДерева(Узел) Цикл
		ВозвращаемоеЗначение.Добавить(Ветвь);
		Для каждого УзелВетви Из УзлыДерева(Ветвь) Цикл
			ВозвращаемоеЗначение.Добавить(УзелВетви);
		КонецЦикла;
	КонецЦикла;
	
	Возврат ВозвращаемоеЗначение;
	
КонецФункции

// Получает конечные элементы предоставленной коллекции согласно отбору.
//
// Параметры:
//  Узел			 - ДанныеФормыДерево, ДанныеФормыЭлементДерева
//					 - ДеревоЗначений, СтрокаДереваЗначений
//	ПараметрыОтбора	 - Структура - Параметры отбора получаемых листьев дерева.
//
// Возвращаемое значение:
//   - Массив из ДанныеФормыЭлементДерева
//	 - Массив из СтрокаДереваЗначений
//
Функция НайтиЛистьяДерева(Узел, ПараметрыОтбора) Экспорт
	
	ВозвращаемоеЗначение = Новый Массив;
	Коллекция = ВетвиДерева(Узел);
	Если ЗначениеЗаполнено(Коллекция) Тогда
		Для Каждого Ветвь Из Коллекция Цикл
			Для Каждого Лист Из НайтиЛистьяДерева(Ветвь, ПараметрыОтбора) Цикл
				ВозвращаемоеЗначение.Добавить(Лист);
			КонецЦикла;
		КонецЦикла;
	Иначе
		УзелСоответствуетОтбору = Истина;
		Для Каждого Элемент Из ПараметрыОтбора Цикл
			Если Узел[Элемент.Ключ] <> Элемент.Значение Тогда
				УзелСоответствуетОтбору = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если УзелСоответствуетОтбору Тогда
			ВозвращаемоеЗначение.Добавить(Узел);
		КонецЕсли;
	КонецЕсли;
	
	Возврат ВозвращаемоеЗначение;
	
КонецФункции // НайтиЛистьяДерева()

// Осуществляет поиск значения в дереве в указанных колонках коллекции строк дерева.
//
// Параметры:
//	Узлы	 - ДанныеФормыКоллекцияЭлементовДерева, КоллекцияСтрокДереваЗначений - Область поиска
//	Значение - Произвольный - Искомое значение
//	Колонки	 - Строка - Список имен колонок, в которых будет осуществляться поиск, разделенных запятыми.
//						Если параметр не указан, поиск осуществляется по всем колонкам дерева.
//	ВключатьПодчиненные - Булево - Определяет, будут ли участвовать в поиске строки подчиненных коллекций.
//
// Возвращаемое значение:
//	- ДанныеФормыЭлементДерева, СтрокаДереваЗначений - Найденный узел
//	- Неопределено									 - Если узел не найден
//
Функция НайтиУзелДерева(Узлы, Значение, Колонки = "", ВключатьПодчиненные = Истина) Экспорт
	
	#Если Сервер Тогда
	Если ТипЗнч(Узлы) = Тип("СтрокаДереваЗначений") Тогда
		Возврат Узлы.Найти(Значение, Колонки, ВключатьПодчиненные);
	КонецЕсли;
	#КонецЕсли
	
	Если ТипЗнч(Узлы) <> Тип("ДанныеФормыКоллекцияЭлементовДерева") Тогда
		ВызватьИсключение "Параметр Узлы: Ожидается тип ДанныеФормыКоллекцияЭлементовДерева, СтрокаДереваЗначений";
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(Узлы) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ИскатьПоВсемКолонкам = Ложь;
	Если ТипЗнч(Колонки) = Тип("Строка") Тогда
		ИскатьПоВсемКолонкам = ПустаяСтрока(Колонки);
	Иначе
		ВызватьИсключение "Параметр Колонки: Ожидается тип Строка";
	КонецЕсли;
	Если НЕ ИскатьПоВсемКолонкам Тогда
		ИменаКолонок = СтрРазделить(Колонки, ", ", Ложь);
	КонецЕсли;
	
	ЭлементыДерева = Новый Массив;
	Для Каждого Узел Из Узлы Цикл
		ЭлементыДерева.Добавить(Узел);
	КонецЦикла;
	
	Для Каждого ЭлементДерева Из ЭлементыДерева Цикл
		Если ИскатьПоВсемКолонкам Тогда
			Для Каждого Свойство Из ЭлементДерева Цикл
				Если Свойство = Значение Тогда
					Возврат ЭлементДерева;
				КонецЕсли;
			КонецЦикла;
		Иначе
			Для Каждого ИмяКолонки Из ИменаКолонок Цикл
				Если ЭлементДерева[ИмяКолонки] = Значение Тогда
					Возврат ЭлементДерева;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		Если ВключатьПодчиненные Тогда
			Для Каждого Ветвь Из ЭлементДерева.ПолучитьЭлементы() Цикл
				ЭлементыДерева.Добавить(Ветвь);
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции // НайтиУзелДерева()

// Заполняет пометки дерева от текущего узла до корня.
// Работает как с булевыми пометками, так и с пометками с тремя состояниями.
//
// Параметры:
//	Узел			 - ДанныеФормыЭлементДерева, СтрокаДереваЗначений - Узел дерева
//	Поле			 - Строка - Заполняемое поле.
//
Процедура ЗаполнитьПометкиДереваВверх(Узел, Поле = "Пометка") Экспорт
	
	ЕстьПомеченные = Ложь;
	ЕстьНеПомеченные = Ложь;
	Ветви = ВетвиДерева(Узел);
	Если ЗначениеЗаполнено(Ветви) Тогда
		Для Каждого Ветвь Из Ветви Цикл
			ЕстьПомеченные = ЕстьПомеченные ИЛИ Ветвь[Поле];
			ЕстьНеПомеченные = ЕстьНеПомеченные ИЛИ НЕ Ветвь[Поле];
			Если ЕстьПомеченные И ЕстьНеПомеченные Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если ЕстьПомеченные И ЕстьНеПомеченные Тогда
			Узел[Поле] = 2;
		ИначеЕсли ЕстьПомеченные Тогда
			Узел[Поле] = 1;
		Иначе
			Узел[Поле] = 0;
		КонецЕсли;
	КонецЕсли;
	
	Родитель = РодительУзлаДерева(Узел);
	Если Родитель <> Неопределено Тогда
		ЗаполнитьПометкиДереваВверх(Родитель, Поле);
	КонецЕсли;
	
КонецПроцедуры // ЗаполнитьПометкиДереваВверх()

// Устанавливает пометки дерева от текущего узла до листьев.
//
// Параметры:
//	Узел			 - ДанныеФормыЭлементДерева, СтрокаДереваЗначений - Узел дерева
//	Пометка			 - Булево	 - Пометка.
//	Поле			 - Строка	 - Заполняемое поле.
//
Процедура УстановитьПометкиДереваВниз(Узел, Пометка, Поле = "Пометка") Экспорт
	
	Узел[Поле] = Булево(Пометка);
	
	Ветви = ВетвиДерева(Узел);
	Для Каждого Ветвь Из Ветви Цикл
		УстановитьПометкиДереваВниз(Ветвь, Пометка, Поле);
	КонецЦикла;
	
КонецПроцедуры // УстановитьПометкиДереваВниз()

// Получает родителя узла дерева
//
// Параметры:
//	Узел - ДанныеФормыЭлементДерева, СтрокаДереваЗначений
//
// Возвращаемое значение:
//	- ДанныеФормыЭлементДерева, СтрокаДереваЗначений - Родитель узла.
//	- Неопределено - Для узлов верхнего уровня
//
Функция РодительУзлаДерева(Узел) Экспорт
	
	Если ТипЗнч(Узел) = Тип("ДанныеФормыЭлементДерева") Тогда
		Возврат Узел.ПолучитьРодителя();

	#Если Сервер Тогда // BSLLS:UnreachableCode-off
	ИначеЕсли ТипЗнч(Узел) = Тип("СтрокаДереваЗначений") Тогда
		Возврат Узел.Родитель;
	#КонецЕсли

	Иначе
		ВызватьИсключение "Параметр Узел: Ожидается ДанныеФормыЭлементДерева, СтрокаДереваЗначений";

	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции // РодительУзлаДерева()

// Проверяет, является ли Узел элементом древовидной коллекции
//
// Параметры:
//  Узел - Произвольный - Узел или корень дерева
//
// Возвращаемое значение:
//   Булево - Истина, если узел имеет тип ДанныеФормыЭлементДерева или СтрокаДереваЗначений.
//
Функция ЭтоУзелДерева(Узел)

	ЭтоУзелДерева = ТипЗнч(Узел) = Тип("ДанныеФормыЭлементДерева");

	#Если Сервер Тогда
	ЭтоУзелДерева = ЭтоУзелДерева ИЛИ ТипЗнч(Узел) = Тип("СтрокаДереваЗначений");
	#КонецЕсли

	Возврат ЭтоУзелДерева;

КонецФункции // ЭтоУзелДерева()

// Проверяет, является ли Узел листом древовидной коллекции
//
// Параметры:
//  Узел - ДанныеФормыДерево, ДанныеФормыЭлементДерева, Произвольный - Узел дерева
//
// Возвращаемое значение:
//   Булево - Признак того что проверяемый узел не имеет дочерних узлов.
//
Функция ЭтоЛистДерева(Узел)
	
	Если ТипЗнч(Узел) = Тип("ДанныеФормыЭлементДерева") Тогда
		Возврат НЕ ЗначениеЗаполнено(Узел.ПолучитьЭлементы());
	КонецЕсли;
	
	#Если Сервер Тогда
	Если ТипЗнч(Узел) = Тип("СтрокаДереваЗначений") Тогда
		Возврат НЕ ЗначениеЗаполнено(Узел.Строки);
	КонецЕсли;
	#КонецЕсли
	
	Возврат Ложь;
	
КонецФункции // ЭтоЛистДерева()

// Проверяет, является ли Узел элементом древовидной коллекции формы
//
// Параметры:
//  Узел - ДанныеФормыДерево, ДанныеФормыЭлементДерева, ДеревоЗначений, СтрокаДереваЗначений - Узел или корень дерева
//
// Возвращаемое значение:
//   - Булево
//
Функция ЭтоЭлементДереваФормы(Узел)
	
	Возврат ТипЗнч(Узел) = Тип("ДанныеФормыЭлементДерева")
		ИЛИ ТипЗнч(Узел) = Тип("ДанныеФормыДерево")
		
КонецФункции // ЭтоЭлементДереваФормы()

// Получает поля листьев дерева
//
// Параметры:
//  Узел						 - ДанныеФормыДерево, ДанныеФормыЭлементДерева	 - Исходный узел.
//  Поля						 - Строка										 - Имена получаемых полей.
//  Отбор						 - Структура									 - Отбор узлов для получения.
//
// Возвращаемое значение:
//  Массив - Структуры данных
//
Функция ПоляЛистьевДерева(Узел, Поля = "", Отбор = Неопределено) Экспорт
		
		ЕстьОтбор = Отбор <> Неопределено;
	
	КоллекцияДанных = Новый Массив;
	КоллекцияПодчиненных = ВетвиДерева(Узел);
	
	Листья = ?(ЕстьОтбор, КоллекцияПодчиненных.НайтиСтроки(Отбор, Истина), ЛистьяДерева(Узел));
	
	Для Каждого Лист Из Листья Цикл
		Если ЕстьОтбор И НЕ ЭтоЛистДерева(Лист) Тогда
			Продолжить;
		КонецЕсли; // По Отбору могут быть подобраны узлы, имеющие подчиненные элементы.
		СтруктураДанных = Новый Структура(Поля);
		ЗаполнитьЗначенияСвойств(СтруктураДанных, Лист);
		КоллекцияДанных.Добавить(СтруктураДанных);
	КонецЦикла;
	
	Возврат КоллекцияДанных;
	
КонецФункции // ПоляЛистьевДерева()

// Получает поля элементов дерева
//
// Параметры:
//  Узел						 - ДанныеФормыДерево, ДанныеФормыЭлементДерева	 -
//  Поля						 - Строка										 - Имена полей, через запятую
//  Отбор						 - Структура									 - Какие элементы опрашиваются
//
// Возвращаемое значение:
//  Массив - Структуры данных
//
Функция ПоляДанныхДереваРекурсивно(Узел, Поля = "Идентификатор, ИдентификаторСтроки", Отбор = Неопределено) Экспорт
	
	КоллекцияДанных = Новый Массив;
	
	Если ЭтоУзелДерева(Узел) И ЭлементСоответствуетОтбору(Узел, Отбор) Тогда
		СтруктураДанных = Новый Структура(Поля);
		ЗаполнитьЗначенияСвойств(СтруктураДанных, Узел);
		Если СтруктураДанных.Свойство("ИдентификаторСтроки") И ЭтоЭлементДереваФормы(Узел) Тогда
			СтруктураДанных.ИдентификаторСтроки = Узел.ПолучитьИдентификатор();
		КонецЕсли;
		КоллекцияДанных.Добавить(СтруктураДанных);
	КонецЕсли;
	
	Коллекция = ВетвиДерева(Узел);
	
	Для Каждого Ветвь Из Коллекция Цикл
		ДанныеПодчиненных = ПоляДанныхДереваРекурсивно(Ветвь, Поля, Отбор);
		Для Каждого СтруктураДанных Из ДанныеПодчиненных Цикл
			КоллекцияДанных.Добавить(СтруктураДанных);
		КонецЦикла;
	КонецЦикла;
	
	Возврат КоллекцияДанных;
	
КонецФункции // ПоляДанныхДереваРекурсивно()

// Проверяет элемент данных на соответствие Отбору.
//
// Параметры:
//  Элемент	 - Произвольный	 - Произвольная коллекция, к которой возможно обращение по имени поля.
//							 Например, СтрокаДереваЗначений.
//  Отбор	 - Структура	 - Накладываемый Отбор.
//							 Поля Отбора должны присутствовать в проверяемом элементе.
//							 Если Неопределено - элемент считается соответствующим Отбору.
//
// Возвращаемое значение:
//  Булево - Истина, если элемент соответствует Отбору или Отбор не определён
//
Функция ЭлементСоответствуетОтбору(Знач Элемент, Знач Отбор = Неопределено) Экспорт
	
	Если Отбор = Неопределено Тогда
		Возврат Истина;
	КонецЕсли;
	
	Для Каждого ЭлементОтбора Из Отбор Цикл
		Если Элемент[ЭлементОтбора.Ключ] <> ЭлементОтбора.Значение Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции // ЭлементСоответствуетОтбору()

// Проверяет принадлежность узла дерева родителю.
//
// Параметры:
//	Узел	 - ДанныеФормыЭлементДерева, СтрокаДереваЗначений	 - Проверяемый узел.
//	Группа	 - ДанныеФормыЭлементДерева, СтрокаДереваЗначений	 - Родительский узел.
//			 - Массив 											 - Несколько родительских узлов. 
//
// Возвращаемое значение:
//	Булево - Если узел находится в иерархии одного из перечисленных узлов.
//
Функция УзелДереваВИерархии(Знач Узел, Знач Группа) Экспорт

	Если Не ЭтоУзелДерева(Узел) Тогда
		ВызватьИсключение "Параметр Узел: Неожиданный тип значения"
	КонецЕсли;
	
	Если ЭтоУзелДерева(Группа) Тогда
		МассивГрупп = Новый Массив;
		МассивГрупп.Добавить(Группа);
	ИначеЕсли ТипЗнч(Группа) = Тип("Массив") Тогда
		МассивГрупп = Группа;
	Иначе
		ВызватьИсключение "Параметр Группа: Неожиданный тип значения";
	КонецЕсли;

	Если МассивГрупп.Найти(Узел) <> Неопределено Тогда
		Возврат Истина;
	КонецЕсли;
	
	ТекущийРодитель = Узел;
	Пока ТекущийРодитель <> Неопределено Цикл
		Если МассивГрупп.Найти(ТекущийРодитель) <> Неопределено Тогда
			Возврат Истина;
		КонецЕсли;
		ТекущийРодитель = РодительУзлаДерева(ТекущийРодитель);
	КонецЦикла;

	Возврат Ложь;

КонецФункции // УзелДереваВИерархии()

#КонецОбласти // Деревья

#Область Массив

// Преобразует коллекцию в двумерный массив (массив массивов)
//
// Параметры:
//  ИсходнаяКоллекция		 - Произвольный	 - Любая коллекция, доступная для обхода "Для каждого ... Цикл".
//  РазмерВложенногоМассива	 - Число		 - Максимальное количество элементов вложенного массива.
//
// Возвращаемое значение:
//  Массив - Результирующий массив.
//
Функция ДвумерныйМассивИзКоллекции(Знач ИсходнаяКоллекция, Знач РазмерВложенногоМассива = 1)
	
	МаксИндексВложенногоМассива = РазмерВложенногоМассива - 1;
	ДвумерныйМассив = Новый Массив;
	ИндексВложенногоМассива = -1;
	Для Каждого ТекущийЭлемент Из ИсходнаяКоллекция Цикл
		ИндексВложенногоМассива = ИндексВложенногоМассива + 1;
		Если ИндексВложенногоМассива > МаксИндексВложенногоМассива Тогда ИндексВложенногоМассива = 0 КонецЕсли;
		Если ИндексВложенногоМассива = 0 Тогда
			ВложенныйМассив = Новый Массив;
			ДвумерныйМассив.Добавить(ВложенныйМассив);
		КонецЕсли;
		ВложенныйМассив.Добавить(ТекущийЭлемент);
	КонецЦикла;
	
	Возврат ДвумерныйМассив;
	
КонецФункции // ДвумерныйМассивИзКоллекции

// Проверяет наличие пересечения массивов
//
// Параметры:
//	ПервыйМассив	 - Массив
//	ВторойМассив	 - Массив
//
// Возвращаемое значение:
//	Булево	 - Истина, если есть хотя бы один общий элемент.
//
Функция ЕстьПересечениеМассивов(ПервыйМассив, ВторойМассив) Экспорт
	
	Для Каждого ТекущийЭлемент Из ПервыйМассив Цикл
		Если ВторойМассив.Найти(ТекущийЭлемент) <> Неопределено Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции // ЕстьПересечениеМассивов

// Возвращает заполненные значения из переданного массива.
//
// Параметры:
//	Массив - Массив
//
// Возвращаемое значение:
//	Массив - Заполненные значения в порядке следования в исходном массиве.
//
Функция ЗаполненныеЗначенияМассива(Массив) Экспорт
	
	МассивЗаполненных = Новый Массив;
	Для Каждого Значение Из Массив Цикл
		Если ЗначениеЗаполнено(Значение) Тогда
			МассивЗаполненных.Добавить(Массив);
		КонецЕсли;
	КонецЦикла;
	Возврат МассивЗаполненных;
	
КонецФункции // ЗаполненныеЗначенияМассива()

// Ищет элемент в массиве по направлению с конца массива.
//
// Параметры:
//  Массив	 - Массив		 - Массив, по которому производится поиск.
//  Значение - Произвольный	 - Искомое значение.
// 
// Возвращаемое значение:
//  Число, Неопределено - Если элемент найден, возвращается его индекс. Если элемент не найден, возвращается Неопределено.
//
Функция НайтиПоследнийЭлементМассива(Массив, Значение) Экспорт
	
	Для ОбратныйИндекс = -Массив.ВГраница() По 0 Цикл
		Индекс = -ОбратныйИндекс;
		Если Массив[Индекс] = Значение Тогда
			Возврат Индекс;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции // НайтиПоследнийЭлементМассива()

// Формирует массив и помещает в него переданное значение
//
// Параметры:
//	Значение - Произвольный
//
// Возвращаемое значение:
//	Массив
//
Функция МассивИзЗначения(Значение) Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Значение);
	Возврат Массив;
	
КонецФункции

// BSLLS:NumberOfOptionalParams-off
// BSLLS:NumberOfParams-off
// BSLLS:MissingParameterDescription-off

// Формирует массив из заданных значений
//
// Параметры:
//	Элемент0..N	 - Произвольный - Элемент для помещения в массив
//
// Возвращаемое значение:
//	Массив
//
// Примеры:
//	МассивЗначений(1, 2, 3);	// {1, 2, 3}
//	МассивЗначений(1, Null, 3, Null); // {1, Null, 3} // Последний Null всегда отбрасывается
//
Функция МассивЗначений(
		Элемент0 = Null,
		Элемент1 = Null,
		Элемент2 = Null,
		Элемент3 = Null,
		Элемент4 = Null,
		Элемент5 = Null,
		Элемент6 = Null,
		Элемент7 = Null,
		Элемент8 = Null,
		Элемент9 = Null) Экспорт
	
	КоличествоПараметровФункции = 10;
	ПустойЭлемент = Null;
	
	Массив = Новый Массив;
	
	ДобавляемЭлементы = Ложь;
	Для ОбратныйИндексПараметра = -КоличествоПараметровФункции + 1 По 0 Цикл
		ИндексПараметра = -ОбратныйИндексПараметра;
		ИндексСтрокой = XMLСтрока(ИндексПараметра);
		ТекущийЭлемент = Вычислить(СтрШаблон("Элемент%1", ИндексСтрокой));
		ДобавляемЭлементы = ДобавляемЭлементы ИЛИ (ТекущийЭлемент <> ПустойЭлемент);
		Если ДобавляемЭлементы Тогда
			Массив.Вставить(0, ТекущийЭлемент);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Массив;
	
	
КонецФункции // МассивЗначений

// Формирует массив со всеми элементами коллекции
//
// Параметры:
//  Коллекция - Произвольный - Коллекция, в которой доступен обход «Для Каждого ... »
//
// Возвращаемое значение:
//   Массив - Элементы коллекции
//
Функция МассивИзКоллекции(Коллекция) Экспорт
	
	МассивЭлементов = Новый Массив;
	Для Каждого ЭлементКоллекции Из Коллекция Цикл
		МассивЭлементов.Добавить(ЭлементКоллекции);
	КонецЦикла;

	Возврат МассивЭлементов;

КонецФункции // МассивИзКоллекции()

// BSLLS:NumberOfOptionalParams-on
// BSLLS:NumberOfParams-on
// BSLLS:MissingParameterDescription-on

// Проверяет, отсортирован ли массив.
//
// Параметры:
//	Массив						 - Массив - Проверяемый массив
//	ПоУбыванию					 - Булево - Если Истина, проверяется сортировка по убыванию.
//	СравниватьПоИдентификаторам	 - Булево - Сравнивать объекты впо идентификаторам.
//											Если Истина, для проверки используется объект СравнениеЗначений.
//											Доступен только на сервере.
//
// Возвращаемое значение:
//	Булево - Истина, если переданный массив отсортирован.
//
Функция МассивОтсортирован(Массив, Знач ПоУбыванию = Ложь, Знач СравниватьПоИдентификаторам = Ложь) Экспорт
	
	Если ТипЗнч(Массив) <> Тип("Массив") Тогда
		ВызватьИсключение "Параметр Массив: Ожидается тип Массив";
	КонецЕсли;
	
	МинимальноСортируемоеКоличество = 2;
	Если Массив.Количество() < МинимальноСортируемоеКоличество Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если СравниватьПоИдентификаторам Тогда
		#Если Клиент Тогда
		ВызватьИсключение "Сравнение по идентификаторам поддерживается только на сервере";
		#Иначе
		
		Сравнение = Новый СравнениеЗначений;
		КоэффициентНаправления = ?(ПоУбыванию, -1, 1);
		Для Индекс = 1 По Массив.ВГраница() Цикл
			РезультатСравнения = Сравнение.Сравнить(Массив[Индекс], Массив[Индекс - 1]) * КоэффициентНаправления;
			Если РезультатСравнения < 0 Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		Возврат Истина;
		
		#КонецЕсли
	КонецЕсли;
	
	Направление = ?(ПоУбыванию, НаправлениеСортировки.Убыв, НаправлениеСортировки.Возр);
	СписокСортировки = Новый СписокЗначений;
	СписокСортировки.ЗагрузитьЗначения(Массив);
	СписокСортировки.СортироватьПоЗначению(Направление);
	
	Для Индекс = 0 По Массив.ВГраница() Цикл
		Если Массив[Индекс] <> СписокСортировки[Индекс].Значение Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции // МассивОтсортирован()

// Создаёт массив, содержащий N экземпляров переданного значения.
//
// Параметры:
//	Значение - Произвольный
//	Количество - Число - Количество экземпляров значения в массиве.
//
// Возвращаемое значение:
//	Массив
//
Функция МассивОдинаковыхЗначений(Значение, Количество = 1) Экспорт
	Массив = Новый Массив(Количество);
	Для Индекс = 0 По Массив.ВГРаница() Цикл
		Массив[Индекс] = Значение;
	КонецЦикла;
	Возврат Массив;
КонецФункции

// Раскладывает строку на массив символов
//
// Параметры:
//	ИсходнаяСтрока - Строка
//
// Возвращаемое значение:
//	Массив из Строка
//
Функция МассивСимволовИзСтроки(ИсходнаяСтрока) Экспорт
	
	ДлинаСтроки = СтрДлина(ИсходнаяСтрока);
	МассивСимволов = Новый Массив(ДлинаСтроки);
	Для Индекс = 0 По ДлинаСтроки - 1 Цикл
		МассивСимволов.Установить(Индекс, Сред(ИсходнаяСтрока, Индекс + 1, 1));
	КонецЦикла;
	
	Возврат МассивСимволов;
	
КонецФункции // МассивСимволовИзСтроки()

// Проверяет равенство массивов.
// Массивы равны, когда:
// - Количество элементов совпадает
// - Все элементы массива совпадают
//
// Параметры:
//	ПервыйМассив - Массив
//	ВторойМассив - Массив
//	ТекстОшибки	 - Строка - Текст сообщения об ошибке
//
// Возвращаемое значение:
//	Булево - Истина, если массивы равны.
//
Функция МассивыСовпадают(ПервыйМассив, ВторойМассив, ТекстОшибки = "") Экспорт
	
	Если ТипЗнч(ПервыйМассив) <> Тип("Массив") Тогда
		ВызватьИсключение "Параметр ПервыйМассив: Ожидается массив";
	КонецЕсли;
	Если ТипЗнч(ВторойМассив) <> Тип("Массив") Тогда
		ВызватьИсключение "Параметр ВторойМассив: Ожидается массив";
	КонецЕсли;
	
	Если ПервыйМассив = ВторойМассив Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПервыйМассив.Количество() <> ВторойМассив.Количество() Тогда
		ПервоеКоличествоСтрокой = XMLСтрока(ПервыйМассив.Количество());
		ВтороеКоличествоСтрокой = XMLСтрока(ВторойМассив.Количество());
		ТекстОшибки = СтрШаблон(
				"Количество элементов различается:
				|%1 <> %2",
				ПервоеКоличествоСтрокой,
				ВтороеКоличествоСтрокой
			);
		Возврат Ложь;
	КонецЕсли;
	
	Для Индекс = 0 По ПервыйМассив.ВГраница() Цикл
		ПервоеЗначение = ПервыйМассив[Индекс];
		ВтороеЗначение = ВторойМассив[Индекс];
		Если ПервоеЗначение <> ВтороеЗначение Тогда
			ИндексСтрокой = XMLСтрока(Индекс);
			ТипПервогоЗначения = ТипЗнч(ПервоеЗначение);
			ТипВторогоЗначения = ТипЗнч(ВтороеЗначение);
			ТекстОшибки = СтрШаблон(
					"Значения элемента [%1] различаются:
					|%2 (%3) <> %4 (%5)",
					ИндексСтрокой,
					ПервоеЗначение,
					ТипПервогоЗначения,
					ВтороеЗначение,
					ТипВторогоЗначения
				);
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции // МассивыСовпадают()

// Обеспечивает значения в массиве. Добавляет отсутствующие значения.
// Новые значения добавляются в конец массива.
// Дублирующиеся добавляемые значения будут созданы однократно.
//
// Параметры:
//  ИсходныйМассив 	 - Массив - Обрабатываемый массив
//  Значения		 - Массив - Обеспечиваемые значения.
//
Процедура ОбеспечитьЗначенияМассива(ИсходныйМассив, Значения) Экспорт

	Входимость = Новый Соответствие;
	Для каждого Значение Из Значения Цикл
		Входимость[Значение] = Ложь;
	КонецЦикла;                           
	
	Для каждого Значение Из ИсходныйМассив Цикл
		Если Входимость[Значение] = Ложь Тогда
			Входимость[Значение] = Истина;
		КонецЕсли;		
	КонецЦикла;                           
	
	Для каждого Значение Из Значения Цикл
		Если Входимость[Значение] = Ложь Тогда
			ИсходныйМассив.Добавить(Значение);
			Входимость[Значение] = Истина;	// Чтобы исключить дубли.
		КонецЕсли;		
	КонецЦикла; 

КонецПроцедуры // ОбеспечитьЗначенияМассива()  

// Находит общие элементы для двух массивов
//
// Параметры:
//	ПервыйМассив	 - Массив
//	ВторойМассив	 - Массив
//
// Возвращаемое значение:
//	Массив	 - Общие элементы в порядке следования в коллекции ПервыйМассив
//
Функция ПересечениеМассивов(ПервыйМассив, ВторойМассив) Экспорт
	
	Пересечение = Новый Массив;
	
	Если НЕ ЗначениеЗаполнено(ПервыйМассив) ИЛИ НЕ ЗначениеЗаполнено(ВторойМассив) Тогда
		Возврат Пересечение;
	КонецЕсли;
	
	Для Каждого ТекущийЭлемент Из ПервыйМассив Цикл
		Если ВторойМассив.Найти(ТекущийЭлемент) <> Неопределено Тогда
			Пересечение.Добавить(ТекущийЭлемент);
			Продолжить;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Пересечение;
	
КонецФункции // ПересечениеМассивов

// Вычисляет разность массивов.
//
// Параметры:
//	УменьшаемыйМассив	 - Массив - Первый массив в сравнении.
//	ВычитаемыйМассив	 - Массив - Второй массив в сравнении.
//
// Возвращаемое значение:
//	Массив	- Элементы из УменьшаемыйМассив, отсутствующие в ВычитаемыйМассив.
//
Функция РазностьМассивов(УменьшаемыйМассив, ВычитаемыйМассив) Экспорт

	Если ТипЗнч(УменьшаемыйМассив) <> Тип("Массив") Тогда
		ВызватьИсключение "Параметр УменьшаемыйМассив: Ожидается тип Массив";
	КонецЕсли;

	Если ТипЗнч(ВычитаемыйМассив) <> Тип("Массив") Тогда
		ВызватьИсключение "Параметр ВычитаемыйМассив: Ожидается тип Массив";
	КонецЕсли;

	Разность = Новый Массив;

	Для Каждого Элемент Из УменьшаемыйМассив Цикл
		Если ВычитаемыйМассив.Найти(Элемент) = Неопределено Тогда
			Разность.Добавить(Элемент);
		КонецЕсли;
	КонецЦикла;

	Возврат Разность;

КонецФункции

// Сворачивает массив.
// Работает в разы быстрее функции БСП ОбщегоНазначенияКлиентСервер.СвернутьМассив()
//
// Параметры:
//  ИсходныйМассив				  - Массив - Исходный массив.
//  СохранитьПорядокЭлементов	  - Булево - Если Истина, порядок элементов будет сохранён, дубли удалены.
//
// Возвращаемое значение:
//   Массив   - Свёрнутый массив.
//
Функция СвернутьМассив(ИсходныйМассив, СохранитьПорядокЭлементов = Ложь) Экспорт
	
	Если Не СохранитьПорядокЭлементов Тогда

		Соответствие = Новый Соответствие;
		Для Каждого Значение Из ИсходныйМассив Цикл
			Соответствие.Вставить(Значение);
		КонецЦикла;
		СвернутыйМассив = Новый Массив;
		Если ИсходныйМассив.Найти(Неопределено) <> Неопределено Тогда
			СвернутыйМассив.Добавить(Неопределено);
		КонецЕсли;
		Для Каждого КлючЗначение Из Соответствие Цикл
			СвернутыйМассив.Добавить(КлючЗначение);
		КонецЦикла;

	Иначе

		Соответствие = Новый Соответствие;
		СвернутыйМассив = Новый Массив;
		НеопределеноОбработано = Ложь;
		Для каждого Значение Из ИсходныйМассив Цикл
			Если Соответствие[Значение] = Неопределено Тогда
				Если Значение = Неопределено Тогда
					Если НеопределеноОбработано Тогда
						Продолжить;
					Иначе
						НеопределеноОбработано = Истина;
					КонецЕсли;
				КонецЕсли;
				СвернутыйМассив.Добавить(Значение);
				Соответствие[Значение] = Истина;
			КонецЕсли;
		КонецЦикла;

	КонецЕсли;

	Возврат СвернутыйМассив;
	
КонецФункции // СвернутьМассив()

// Вырезает элементы из массива, и на их место вставляет новые элементы.
//
// Параметры:
//  Массив				 - Массив	 - Массив, из которого вырезаются/вставляются элементы.
//  Индекс				 - Число	 - Индекс первого удаляемого элемента, а также вставки элементов.
//  КоличествоУдаляемых	 - Число	 - Количество удаляемых элементов массива.
//  Вставка				 - Массив, Произвольный	 - Вставляемые элементы.
//										Если указано значение типа, отличного от Массив, оно будет вставлено по указанному указанному индексу.
//										Если требуется вставить Массив или Неопределено в качестве элемента - следует передать его в качестве вложенного в массив.
//
// Возвращаемое значение:
//  Массив - Удаленные элементы
//
Функция СраститьМассив(Массив, Индекс = 0, КоличествоУдаляемых = 0, Вставка = Неопределено) Экспорт
	
	Удаленные = Новый Массив;
	ОсталосьУдалить = КоличествоУдаляемых;
	
	Пока ОсталосьУдалить Цикл
		Удаленные.Добавить(Массив[Индекс]);
		Массив.Удалить(Индекс);
		ОсталосьУдалить = ОсталосьУдалить - 1;
	КонецЦикла;
	
	Если Вставка <> Неопределено Тогда
		
		Если ТипЗнч(Вставка) = Тип("Массив") Тогда
			Для Каждого Элемент Из Вставка Цикл
				Массив.Вставить(Индекс, Элемент);
			КонецЦикла;
		Иначе
			Массив.Вставить(Индекс, Вставка);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Удаленные;

КонецФункции // СраститьМассив()

// Удаляет значение из массива.
//
// Параметры:
//  Массив 	 - Массив		 - Обрабатываемый массив
//  Значение - Произвольный	 - Значение к удалению.
//
// Возвращаемое значение: 
//	Массив - Обновленный массив после удаления значения.
//
Функция УдалитьЗначениеИзМассива(Массив, Значение) Экспорт
	
	НовыйМассив = Новый Массив;  
	Для каждого ТекущееЗначение Из Массив Цикл
		Если ТекущееЗначение <> Значение Тогда
			НовыйМассив.Добавить(ТекущееЗначение);		
		КонецЕсли;		
	КонецЦикла; 
	
	Возврат НовыйМассив;

КонецФункции

// Удаляет значения из массива.
//
// Параметры:
//  Массив 	 - Массив - Обрабатываемый массив
// Значения - Массив - Значения к удалению.
//
// Возвращаемое значение: 
//	Массив - Обновленный массив после удаления значений.
//
Функция УдалитьЗначенияИзМассива(Массив, Значения) Экспорт

	Входимость = Новый Соответствие;
	Для каждого Значение Из Значения Цикл
		Входимость[Значение] = Истина;
	КонецЦикла;                      
	
	НовыйМассив = Новый Массив;  
	Для каждого Значение Из Массив Цикл
		Если Входимость[Значение] <> Истина Тогда
			НовыйМассив.Добавить(Значение);		
		КонецЕсли;		
	КонецЦикла; 
	
	Возврат НовыйМассив;

КонецФункции // УдалитьЗначенияМассива()

// Удаляет незаполненные значения из массива.
// Заполненность значений проверяется методом ЗначениеЗаполнено()
//
// Параметры:
//	Массив				 - Массив из Произвольный - Массив элементов.
//	ИгнорируемыеЗначения - Массив из Произвольный - Значения, которые следует оставить при проверке
//
Процедура УдалитьНезаполненныеЗначенияМассива(Массив, Знач ИгнорируемыеЗначения = Неопределено)
	
	Если ИгнорируемыеЗначения = Неопределено Тогда
		ИгнорируемыеЗначения = Новый Массив;
	КонецЕсли;

	НовыйМассив = Новый Массив;
	Для каждого Значение Из Массив Цикл
		Если Не ЗначениеЗаполнено(Значение) 
			И ИгнорируемыеЗначения.Найти(Значение) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		НовыйМассив.Добавить(Значение);
	КонецЦикла;

	Массив = НовыйМассив;
	
КонецПроцедуры // УдалитьНезаполненныеЗначенияМассива()

#КонецОбласти // Массив

#Область Соответствие

// см. ДополнитьКлючиИЗначения()
//
Процедура ДополнитьСоответствие(Соответствие, ДополнительныеЭлементы, Замещать = Ложь) Экспорт
	ДополнитьКлючиИЗначения(Соответствие, ДополнительныеЭлементы, Замещать);
КонецПроцедуры // ДополнитьСтруктуру()

// Проверяет равенство структур.
// Соответствия равны, когда:
// - Совпадают все ключи и значения элементов.
//
// Параметры:
//	ПервоеСоответствие	 - Соответствие
//	ВтороеСоответствие	 - Соответствие
//	ТекстОшибки		 - Строка	 - Текст ошибки
//
// Возвращаемое значение:
//	Булево - Истина, если Соответствия равны.
//
Функция СоответствияРавны(ПервоеСоответствие, ВтороеСоответствие, ТекстОшибки = "") Экспорт
	
	Если ТипЗнч(ПервоеСоответствие) <> Тип("Соответствие") Тогда
		ВызватьИсключение "Параметр ПервоеСоответствие: Ожидается тип Соответствие";
	КонецЕсли;
	Если ТипЗнч(ВтороеСоответствие) <> Тип("Соответствие") Тогда
		ВызватьИсключение "Параметр ВтороеСоответствие: Ожидается тип Соответствие";
	КонецЕсли;
	
	Если ПервоеСоответствие = ВтороеСоответствие Тогда
		Возврат Истина;
	КонецЕсли;
	
	ТекстыОшибки = Новый Массив;
	
	Если ПервоеСоответствие.Количество() <> ВтороеСоответствие.Количество() Тогда
		ТекстыОшибки.Добавить("Количество элементов различается.");
	КонецЕсли;
	
	КонтрольноеСоответствие = Новый Соответствие;
	Для Каждого Элемент Из ПервоеСоответствие Цикл
		КонтрольноеСоответствие[Элемент.Ключ] = Новый УникальныйИдентификатор;
	КонецЦикла;
	Для Каждого Элемент Из ВтороеСоответствие Цикл
		КонтрольноеСоответствие[Элемент.Ключ] = Новый УникальныйИдентификатор;
	КонецЦикла;
	КопияПервогоСоответствия = Новый Соответствие;
	КопияВторогоСоответствия = Новый Соответствие;
	Для Каждого Элемент Из КонтрольноеСоответствие Цикл
		КопияПервогоСоответствия[Элемент.Ключ] = Элемент.Значение;
		КопияВторогоСоответствия[Элемент.Ключ] = Элемент.Значение;
	КонецЦикла;
	Для Каждого Элемент Из ПервоеСоответствие Цикл
		КопияПервогоСоответствия[Элемент.Ключ] = Элемент.Значение;
	КонецЦикла;
	Для Каждого Элемент Из ВтороеСоответствие Цикл
		КопияПервогоСоответствия[Элемент.Ключ] = Элемент.Значение;
	КонецЦикла;
	
	Для Каждого Элемент Из ВтороеСоответствие Цикл
		Ключ = Элемент.Ключ;
		ТипКлюча = ТипЗнч(Ключ);
		Если ПервоеСоответствие[Ключ] = КонтрольноеСоответствие[Ключ] Тогда
			ТекстыОшибки.Добавить(СтрШаблон("ПервоеСоответствие: Отсутствует ключ [%1] (%2)", Ключ, ТипКлюча));
		КонецЕсли;
	КонецЦикла;
	Для Каждого Элемент Из ПервоеСоответствие Цикл
		Ключ = Элемент.Ключ;
		ТипКлюча = ТипЗнч(Ключ);
		Если ВтороеСоответствие[Ключ] = КонтрольноеСоответствие[Ключ] Тогда
			ТекстыОшибки.Добавить(СтрШаблон("ВтороеСоответствие: Отсутствует ключ [%1] (%2)", Ключ, ТипКлюча));
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ПервыйЭлемент Из ПервоеСоответствие Цикл
		Ключ = ПервыйЭлемент.Ключ;
		ТипКлюча = ТипЗнч(Ключ);
		ПервоеЗначение = ПервыйЭлемент.Значение;
		ВтороеЗначение = ВтороеСоответствие[Ключ];
		Если КопияВторогоСоответствия[Ключ] <> КонтрольноеСоответствие[Ключ]
			И ПервоеЗначение <> ВтороеЗначение Тогда
			ТипПервогоЗначения = ТипЗнч(ПервоеЗначение);
			ТипВторогоЗначения = ТипЗнч(ВтороеЗначение);
			ТекстыОшибки.Добавить(
				СтрШаблон(
					"Различаются значения по ключу [%1] (%2):
					|%3 (%4) <> %5 (%6)",
					Ключ,
					ТипКлюча,
					ПервоеЗначение,
					ТипПервогоЗначения,
					ВтороеЗначение,
					ТипВторогоЗначения
				)
			);
		КонецЕсли;
	КонецЦикла;
	
	ТекстОшибки = СтрСоединить(ТекстыОшибки, Символы.ПС);
	Если ЗначениеЗаполнено(ТекстОшибки) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции // СоответствияРавны()

#КонецОбласти // Соответствие

#Область Структура

// см. ДополнитьКлючиИЗначения()
//
Процедура ДополнитьСтруктуру(Структура, ДополнительныеЭлементы, Замещать = Ложь) Экспорт
	ДополнитьКлючиИЗначения(Структура, ДополнительныеЭлементы, Замещать);
КонецПроцедуры // ДополнитьСтруктуру()

// Проверяет наличие свойства структуры.
// Если оно присутствует, возвращает его.
// Если отсутствует -- создаёт.
//
// Параметры:
//	Структура	 - Структура	 - Проверяемая структура.
//	Ключ		 - Строка		 - Искомый ключ
//	Значение	 - Произвольный	 - Ожидаемое значение.
//								 Если ключ присутствует в структуре, будет установлено из ключа
// Возвращаемое значение:
//	Произвольный - Значение по ключу структуры, или значение параметра Значение, если ключ отсутствует.
//
Функция ОбеспечитьСвойствоСтруктуры(Структура, Ключ, Значение = Неопределено) Экспорт
	
	Если ТипЗнч(Структура) <> Тип("Структура") Тогда
		ВызватьИсключение "Параметр Структура: Ожидается тип Структура";
	КонецЕсли;
	
	Если НЕ Структура.Свойство(Ключ) Тогда
		Структура.Вставить(Ключ, Значение);
	Иначе
		Значение = Структура[Ключ];
	КонецЕсли;
	
	Возврат Структура[Ключ];
	
КонецФункции // ОбеспечитьСвойствоСтруктуры()

// Проверяет равенство структур.
// Структуры равны, когда:
// - Совпадают все ключи и значения элементов.
//
// Параметры:
//	ПерваяСтруктура	 - Структура
//	ВтораяСтруктура	 - Структура
//	ТекстОшибки		 - Строка	 - Текст ошибки
//
// Возвращаемое значение:
//	Булево - Истина, если структуры равны.
//
Функция СтруктурыРавны(ПерваяСтруктура, ВтораяСтруктура, ТекстОшибки = "") Экспорт
	
	Если ТипЗнч(ПерваяСтруктура) <> Тип("Структура") Тогда
		ВызватьИсключение "Параметр ПерваяСтруктура: Ожидается тип Структура";
	КонецЕсли;
	Если ТипЗнч(ВтораяСтруктура) <> Тип("Структура") Тогда
		ВызватьИсключение "Параметр ВтораяСтруктура: Ожидается тип Структура";
	КонецЕсли;
	
	Если ПерваяСтруктура = ВтораяСтруктура Тогда
		Возврат Истина;
	КонецЕсли;
	
	ТекстыОшибки = Новый Массив;
	
	Если ПерваяСтруктура.Количество() <> ВтораяСтруктура.Количество() Тогда
		ТекстыОшибки.Добавить("Количество элементов различается.");
	КонецЕсли;
	
	Для Каждого Элемент Из ВтораяСтруктура Цикл
		Ключ = Элемент.Ключ;
		Если НЕ ПерваяСтруктура.Свойство(Ключ) Тогда
			ТекстыОшибки.Добавить(СтрШаблон("ПерваяСтруктура: Отсутствует ключ %1", Ключ));
		КонецЕсли;
	КонецЦикла;
	Для Каждого Элемент Из ПерваяСтруктура Цикл
		Ключ = Элемент.Ключ;
		Если НЕ ВтораяСтруктура.Свойство(Ключ) Тогда
			ТекстыОшибки.Добавить(СтрШаблон("ВтораяСтруктура: Отсутствует ключ %1", Ключ));
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ПервыйЭлемент Из ПерваяСтруктура Цикл
		Ключ = ПервыйЭлемент.Ключ;
		ПервоеЗначение = ПервыйЭлемент.Значение;
		ВтороеЗначение = Неопределено;
		Если ВтораяСтруктура.Свойство(Ключ, ВтороеЗначение)
			И ПервоеЗначение <> ВтороеЗначение Тогда
			ТипПервогоЗначения = ТипЗнч(ПервоеЗначение);
			ТипВторогоЗначения = ТипЗнч(ВтороеЗначение);
			ТекстыОшибки.Добавить(
				СтрШаблон(
					"Различаются значения элемента %1:
					|%2 (%3) <> %4 (%5)",
					Ключ,
					ПервоеЗначение,
					ТипПервогоЗначения,
					ВтороеЗначение,
					ТипВторогоЗначения
				)
			);
		КонецЕсли;
	КонецЦикла;
	
	ТекстОшибки = СтрСоединить(ТекстыОшибки, Символы.ПС);
	Если ЗначениеЗаполнено(ТекстОшибки) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции // СтруктурыРавны()

#КонецОбласти // Структура

#Область Индексирование

// Добавляет элемент колелкции в индекс колелкции
//
// Параметры:
//	ЭлементКоллекции	 - Произвольный - Элемент с именоваными полями.
//	ИндексКоллекции		 - см. ПостроитьИндексКоллекции()
//	ЗначенияПолейИндекса - Структура - Служебный параметр.
//
Процедура ДобавитьВИндексКоллекции(ИндексКоллекции, ЭлементКоллекции, ЗначенияПолейИндекса = Неопределено)
	
	ТекущийСлой = ИндексКоллекции.Индекс;
	Для Индекс = 0 По ИндексКоллекции.Поля.ВГРаница() Цикл
		ПолеИндекса = ИндексКоллекции.Поля[Индекс];
		Если ЗначенияПолейИндекса = Неопределено Тогда
			ЗначениеПоля = ЭлементКоллекции[ПолеИндекса];
		Иначе
			ЗначениеПоля = ЗначенияПолейИндекса[ПолеИндекса];
		КонецЕсли;
		СлойПоЗначению = ТекущийСлой[ЗначениеПоля];
		Если СлойПоЗначению = Неопределено Тогда
			Если Индекс = ИндексКоллекции.Поля.ВГРаница() Тогда
				СлойПоЗначению = Новый Массив;	// Конечные элементы
			Иначе	
				СлойПоЗначению = Новый Соответствие;
			КонецЕсли;
			ТекущийСлой[ЗначениеПоля] = СлойПоЗначению;
		КонецЕсли;
		ТекущийСлой = СлойПоЗначению;
	КонецЦикла;

	КонечныеЭлементы = СлойПоЗначению;	// Массив элементов коллекции
	Если КонечныеЭлементы.Найти(ЭлементКоллекции) = Неопределено Тогда
		КонечныеЭлементы.Добавить(ЭлементКоллекции);
	КонецЕсли;

	Если ЗначенияПолейИндекса = Неопределено Тогда	// Добавляем обычный элемент
		// Поочерёдно заменяем каждое из полей индекса на Неопределено,
		// и добавляем полученное в индекс.
		// Таким образом, организуем поиск по неполному составу полей.
		КоличествоПолейИндекса = ИндексКоллекции.Поля.Количество();	
		Для КомбинацияПодмен = 1 По Pow(2, КоличествоПолейИндекса) Цикл
			ПоляИндексаСтрокой = ИндексКоллекции.ПоляСтрокой;
			ЗначенияПолейИндекса = Новый Структура(ПоляИндексаСтрокой);
			ЗаполнитьЗначенияСвойств(ЗначенияПолейИндекса, ЭлементКоллекции, ПоляИндексаСтрокой);
			Для ИндексПоляБита = 0 По КоличествоПолейИндекса - 1 Цикл
				Если ПроверитьБит(КомбинацияПодмен, ИндексПоляБита) Тогда
					ЗначенияПолейИндекса.Вставить(ИндексКоллекции.Поля[ИндексПоляБита], Неопределено);
				КонецЕсли;
			КонецЦикла;
			ДобавитьВИндексКоллекции(ИндексКоллекции, ЭлементКоллекции, ЗначенияПолейИндекса);
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры

// Формирует параметры поиска по индексу коллекции.
//
// Параметры: 
//	ИндексКоллекции	 - Структура	 - см. ПостроитьИндексКоллекции()
//	ЭлементКоллекции - Произвольный	 - Объект с полями, по которому формируются параметры поиска.
//
// Возвращаемое значение:
//	Структура - Поля для поиска по индексу. Ключи структуры соответствуют полям индекса.
//
Функция ПараметрыПоискаПоИндексуКоллекции(ИндексКоллекции, ЭлементКоллекции = Неопределено) Экспорт

	ПоляСтрокой = ИндексКоллекции.ПоляСтрокой;
	ПараметрыПоиска = Новый Структура(ПоляСтрокой);
	Если ЭлементКоллекции <> Неопределено Тогда
		ЗаполнитьЗначенияСвойств(ПараметрыПоиска, ЭлементКоллекции, ПоляСтрокой);
	КонецЕсли;

	Возврат ПараметрыПоиска; 
	
КонецФункции

// Строит индекс коллекции для использования с методом НайтиЭлементыКоллекцииПоИндексу()
//
// Параметры:
//	Коллекция	 - Произвольный - Коллекция элементов с полями.
//	ПоляИндекса	 - Строка - Имена полей индекса через запятую.
//
// Возвращаемое значение:
//	Структура - Индекс коллекции. Поля:
//		* Поля		 - Массив из Строка - Имена полей индекса.
//		* Индекс	 - Соответствие - Индекс. Содержит вложенные соответствия для значений каждого поля индекса.
//									На последнем уровне содержит элементы исходной коллекции.
//
Функция ПостроитьИндексКоллекции(Коллекция, Знач ПоляИндекса) Экспорт
	
	МаксимальноеКоличествоПолейИндекса = 8;	// Можно увеличить при желании, но лучше не стоит.

	#Область Проверки
	Если ТипЗнч(ПоляИндекса) <> Тип("Строка") Тогда
		ВызватьИсключение "Параметр ПоляИндекса: Ожидается тип Строка";
	КонецЕсли;
	Если ПустаяСтрока(ПоляИндекса) Тогда
		ВызватьИсключение "Параметр ПоляИндекса: Ожидается значение.";
	КонецЕсли;
	Попытка
		ПоляСтруктурой = Новый Структура(ПоляИндекса); // BSLLS:UnusedLocalVariable-off
	Исключение
		ВызватьИсключение "Параметр ПоляИндекса: Неверный формат имён.";
	КонецПопытки;
	МаксПолейИндексаФикс = 32;	// Технологическое ограничение. Куда уж больше?
	МаксПолейИндекса = Мин(МаксимальноеКоличествоПолейИндекса, МаксПолейИндексаФикс);
	Если ПоляСтруктурой.Количество() > МаксПолейИндекса Тогда 
		ВызватьИсключение СтрШаблон(
			"Количество полей индекса превышет технологическое ограничение в %1", 
			МаксПолейИндекса
		);
	КонецЕсли;
	#КонецОбласти // Проверки

	ИндексКоллекции = Новый Структура;
	ИндексКоллекции.Вставить("Поля", СтрРазделить(ПоляИндекса, ", ", Ложь));
	ИндексКоллекции.Вставить("ПоляСтрокой", ПоляИндекса);
	ИндексКоллекции.Вставить("Индекс", Новый Соответствие);

	Для Каждого ЭлементКоллекции Из Коллекция Цикл
		ДобавитьВИндексКоллекции(ИндексКоллекции, ЭлементКоллекции);
	КонецЦикла;

	Возврат ИндексКоллекции;

КонецФункции

// Ищет элементы коллекции по индексу
//
// Параметры:
//	ИндексКоллекции - Структура - См. ПостроитьИндексКоллекции()
//	ПараметрыПоиска - Структура - см. ПараметрыПоискаПоИндексуКоллекции()
//		Поля, аналогично методу НайтиСтроки().
//		Элементы:
//		* Ключ		 - Поле коллекции.
//		* Значение	 - Значение в поле.
//
// ВозвращаемоеЗначение:
//	Массив - Найденные элементы.
//
Функция НайтиПоИндексуКоллекции(ИндексКоллекции, ПараметрыПоиска) Экспорт
	
	НайденныеЭлементы = Новый Массив;
	
	ТекущийСлой = ИндексКоллекции.Индекс;
	Для Индекс = 0 По ИндексКоллекции.Поля.ВГРаница() Цикл
		Поле = ИндексКоллекции.Поля[Индекс];
		СлойПоЗначению = ТекущийСлой[ПараметрыПоиска[Поле]];
		Если СлойПоЗначению = Неопределено Тогда
			Прервать;
		КонецЕсли;
		ТекущийСлой = СлойПоЗначению;
	КонецЦикла;

	Если ТипЗнч(ТекущийСлой) = Тип("Массив") Тогда
		Для каждого ЭлементИндекса Из ТекущийСлой Цикл
			НайденныеЭлементы.Добавить(ЭлементИндекса);
		КонецЦикла;
	КонецЕсли;

	Возврат НайденныеЭлементы;

КонецФункции

#КонецОбласти // Индексирование

// Возвращает верхнюю границу индекса коллекции, аналогично Массив.ВГраница().
//
// Параметры:
//	Коллекция - Произвольный - Коллекция, поддерживающая обход Для Каждого ... Из ... Цикл.
//
// Возвращаемое значение:
//	Число - Наибольший индекс в коллекции. Если количество элементов коллеции равно 0, возвращает -1.
//
Функция ВГраница(Коллекция) Экспорт

	Если ТипЗнч(Коллекция) = Тип("Массив") Тогда
		Возврат Коллекция.ВГраница();
	КонецЕсли;
	
	Попытка
		Возврат Коллекция.Количество() - 1;	
	Исключение // BSLLS:MissingCodeTryCatchEx-off
		// Вряд ли есть такие коллекции, которые не поддерживают Количество().
		ВызватьИсключение "Параметр Коллекция: Значение не является коллекцией, или не поддерживает Количество().";
	КонецПопытки;

КонецФункции

// Выгружает ключи из структуры или соответствия
//
// Параметры:
//	Коллекция - Структура, Соответствие
//
// Возвращаемое значение:
//	Массив - Ключи коллекции.
//
Функция ВыгрузитьКлючиКоллекции(Коллекция) Экспорт
	
	Выгрузка = Новый Массив;
	Для Каждого КлючЗначение Из Коллекция Цикл
		Выгрузка.Добавить(КлючЗначение.Ключ);
	КонецЦикла;
	
	Возврат Выгрузка;
	
КонецФункции // ВыгрузитьКлючиКоллекции

// Выгружает значения из структуры или соответствия
//
// Параметры:
//	Коллекция - Структура, Соответствие
//
// Возвращаемое значение:
//	Массив - Значения коллекции.
//
Функция ВыгрузитьЗначенияКоллекции(Коллекция) Экспорт
	
	Выгрузка = Новый Массив;
	Для Каждого КлючЗначение Из Коллекция Цикл
		Выгрузка.Добавить(КлючЗначение.Значение);
	КонецЦикла;
	
	Возврат Выгрузка;
	
КонецФункции // ВыгрузитьЗначенияКоллекции

// Выгружает значения указанного поля всех элементов коллекции.
//
// Параметры:
//  Коллекция	 - Произвольный	 - Коллекция, поддерживающая обход циклом "Для Каждого ..."
//  Поле		 - Строка		 - Выгружаемое поле (колонка). Должно присутствовать во всех элементах.
//				 - Число		 - Индекс поля элемента коллекции. 
//
// Возвращаемое значение:
//   Массив   - Выгруженные значения поля в порядке следования в коллекции.
//
Функция ВыгрузитьПолеКоллекции(Коллекция, Поле) Экспорт
	
	Выгрузка = Новый Массив;
	Для Каждого ЭлементКоллекции Из Коллекция Цикл
		Выгрузка.Добавить(ЭлементКоллекции[Поле]);
	КонецЦикла;
	
	Возврат Выгрузка;
	
КонецФункции // ВыгрузитьПолеКоллекции()


// Дополняет элементы структуры или соответствия элементами другой структуры или соответствия.
//
// Параметры:
//  Коллекция				 - Структура, Соответствие	 - Дополняемая коллекция.
//  ДополнительныеЭлементы	 - Структура, Соответствие	 - Дополнительные элементы.
//  Замещать				 - Булево					 - Если Истина, элементы исходной коллекции будут замещены
//														элементами дополняющей коллекции с идентичными ключами.
//
Процедура ДополнитьКлючиИЗначения(Коллекция, ДополнительныеЭлементы, Замещать = Ложь) Экспорт
	
	Если ТипЗнч(Коллекция) <> Тип("Соответствие")
		И ТипЗнч(Коллекция) <> Тип("Структура") Тогда
		ВызватьИсключение "Параметр Коллекция: Ожидается типы: Структура, Соответствие";
	КонецЕсли;
	
	Если НЕ Замещать Тогда
		ПропускаемыеКлючи = Новый Массив;
		Ключи = Новый Массив;
		Для Каждого Элемент Из Коллекция Цикл
			Ключи.Добавить(Элемент.Ключ);
		КонецЦикла;
		Для Каждого Элемент Из ДополнительныеЭлементы Цикл
			Если Ключи.Найти(Элемент.Ключ) <> Неопределено Тогда
				ПропускаемыеКлючи.Добавить(Элемент.Ключ);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Для Каждого Элемент Из ДополнительныеЭлементы Цикл
		Если НЕ Замещать И ПропускаемыеКлючи.Найти(Элемент.Ключ) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Коллекция.Вставить(Элемент.Ключ, Элемент.Значение);
	КонецЦикла;
	
КонецПроцедуры // ДополнитьКлючиИЗначения()

// Получает значения полей элементов коллекции
//
// Параметры:
//	Коллекция	 - Произвольный	 - Любая коллекция.
//	Свойства	 - Строка		 - Список свойств через запятую.
//
// Возвращаемое значение:
//	Массив из Структура - Значения свойств элементов коллекции.
//
Функция ЗначенияСвойствЭлементовКоллекции(Коллекция, Свойства) Экспорт
	
	ЗначенияСвойств = Новый Массив;
	
	Для Каждого ЭлементКоллекции Из Коллекция Цикл
		СтруктураДанных = Новый Структура(Свойства);
		ЗаполнитьЗначенияСвойств(СтруктураДанных, ЭлементКоллекции);
		ЗначенияСвойств.Добавить(СтруктураДанных);
	КонецЦикла;
	
	Возврат ЗначенияСвойств;
	
КонецФункции // ЗначенияСвойствЭлементовКоллекции()

// Осуществляет поиск строки в коллекции. См. НайтиСтроки().
//
// Параметры:
//	Коллекция		 - Произвольный	 - Коллекция, поддерживающая метод НайтиСтроки().
//	ПараметрыОтбора	 - Структура	 - Условия поиска.
//
// Возвращаемое значение:
//	Произвольный - Найденный элемент коллекции. Если подходящих элементов нет, возвращается Неопределено.
//
Функция НайтиСтроку(Коллекция, ПараметрыОтбора) Экспорт
	Строки = Коллекция.НайтиСтроки(ПараметрыОтбора);
	Если ЗначениеЗаполнено(Строки) Тогда
		Возврат Строки[0];
	КонецЕсли;
	Возврат Неопределено;
КонецФункции

// Производит поиск в однородной коллекции, состоящих из элементов с полями (например, Массив из Структура)
//
// Параметры:
//  Коллекция 		 - Произвольный	 - Коллекция, поддерживающая обход "Для Каждого ..."
//  ПараметрыПоиска  - Структура:
//		* Ключ			 - Поле элемента коллекции, в котором производится поиск
//		* Значение		 - Искомое значение
//					 - Произвольный	 - Искомое значение
//  ПоляПоиска 		 - Строка		 - Поля элемента коллекции, в которых производится поиск, через запятую.
//									 Поиск производится по значению в любом из указанных полей.
//									 Если указана пустая строка, проверяются все поля элементов коллекции.
//
// Варианты вызова:
//	НайтиЭлементыКоллекции(Произвольный, Структура)				 - Поиск по значениям нескольких полей.
//	НайтиЭлементыКоллекции(Произвольный, Произвольный, Строка)	 - Поиск по значению в любом поле из указанных.
//
// Возвращаемое значение:
//   Массив   - Найденные элементы коллекции
//
Функция НайтиЭлементыКоллекции(Коллекция, Знач ПараметрыПоиска, Знач ПоляПоиска = Неопределено) Экспорт
	
	НайденныеЭлементы = Новый Массив;
	
	Если Не ЗначениеЗаполнено(Коллекция) Тогда
		Возврат НайденныеЭлементы;
	КонецЕсли;
	
	ЭтоПоискПоОдномуЗначению = ПоляПоиска <> Неопределено Или ТипЗнч(ПараметрыПоиска) <> Тип("Структура");
	Если ЭтоПоискПоОдномуЗначению Тогда
		ПоляПоиска = СтрРазделить(ПоляПоиска, ", ", Ложь);
		ИскомоеЗначение = ПараметрыПоиска;
	КонецЕсли;
	
	// Для пустого Отбора - пустой результат, как для ТаблицаЗначений.НайтиСтроки():
	Если НЕ ЭтоПоискПоОдномуЗначению И НЕ ЗначениеЗаполнено(ПараметрыПоиска) Тогда
		Возврат НайденныеЭлементы;
	КонецЕсли;

	Если Не ЭтоПоискПоОдномуЗначению Тогда
		// Коллекции, поддерживающие метод НайтиСтроки()
		ТипКоллекции = ТипЗнч("Коллекция");
		МожноИспользоватьМетодНайтиСтроки = Ложь;
		Если ТипКоллекции = Тип("ДанныеФормыКоллекция") Или ТипКоллекции = Тип("ДанныеФормыСтруктураСКоллекцией") Тогда
			МожноИспользоватьМетодНайтиСтроки = Истина	
		КонецЕсли;
		#Если Сервер Или ВнешнееСоединение Тогда
		Если ТипКоллекции = Тип("ТаблицаЗначений") Или ТипКоллекции = Тип("КоллекцияСтрокДереваЗначений") Тогда
			МожноИспользоватьМетодНайтиСтроки = Истина	
		КонецЕсли;
		#КонецЕсли
		Если МожноИспользоватьМетодНайтиСтроки Тогда
			Возврат Коллекция.НайтиСтроки(ПараметрыПоиска);
		КонецЕсли;
	КонецЕсли;
	
	Для Каждого ЭлементКоллекции Из Коллекция Цикл
		
		Если ЭтоПоискПоОдномуЗначению И ЗначениеЗаполнено(ПоляПоиска) Тогда
			
			ЭлементСоответствуетОтбору = Ложь;
			Для Каждого Поле Из ПоляПоиска Цикл
				Если ЭлементКоллекции[Поле] = ИскомоеЗначение Тогда
					ЭлементСоответствуетОтбору = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
		ИначеЕсли ЭтоПоискПоОдномуЗначению И Не ЗначениеЗаполнено(ПоляПоиска) Тогда
			
			// При незаполненных полях поиска пытаемся проверить все поля элементов коллекции.
			ЭлементСоответствуетОтбору = Ложь;
			Для Каждого ПолеЭлементаКоллекции Из ЭлементКоллекции Цикл
				ЭтоКлючЗначение = ТипЗнч(ПолеЭлементаКоллекции) = Тип("КлючИЗначение");
				ПроверяемоеЗначение = ?(ЭтоКлючЗначение, ПолеЭлементаКоллекции.Значение, ПолеЭлементаКоллекции);
				Если ПроверяемоеЗначение = ИскомоеЗначение Тогда
					ЭлементСоответствуетОтбору = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
		ИначеЕсли ЗначениеЗаполнено(ПараметрыПоиска) Тогда
			
			ЭлементСоответствуетОтбору = Истина;
			Для Каждого ПараметрПоиска Из ПараметрыПоиска Цикл
				Если ЭлементКоллекции[ПараметрПоиска.Ключ] <> ПараметрПоиска.Значение Тогда
					ЭлементСоответствуетОтбору = Ложь;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
		Иначе // Пустая структура Отбора
			
			Прервать;
			
		КонецЕсли;
		
		Если ЭлементСоответствуетОтбору Тогда
			НайденныеЭлементы.Добавить(ЭлементКоллекции);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат НайденныеЭлементы;
	
КонецФункции // НайтиЭлементыКоллекции()

// Производит поиск в однородной коллекции, состоящих из элементов с полями (например, Массив из Структура)
//
// Параметры:
//  Коллекция 		 - Произвольный	 - Коллекция, поддерживающая обход "Для Каждого ..."
//  ПараметрыПоиска  - Структура:
//		* Ключ			 - Поле элемента коллекции, в котором производится поиск
//		* Значение		 - Искомое значение
//					 - Произвольный	 - Искомое значение
//  ПоляПоиска 		 - Строка		 - Поля элемента коллекции, в которых производится поиск, через запятую.
//									 Поиск производится по значению в любом из указанных полей.
//									 Если указана пустая строка, проверяются все поля элементов коллекции.
//
// Варианты вызова:
//	НайтиЭлементыКоллекции(Произвольный, Структура)				 - Поиск по значениям нескольких полей.
//	НайтиЭлементыКоллекции(Произвольный, Произвольный, Строка)	 - Поиск по значению в любом поле из указанных.
//
// Возвращаемое значение:
//   Произвольный   - Найденный элемент коллекции
//
Функция НайтиЭлементКоллекции(
		Коллекция,
		Знач ПараметрыПоиска,
		Знач ПоляПоиска = Неопределено) Экспорт
	
	НайденныеЭлементы = НайтиЭлементыКоллекции(Коллекция, ПараметрыПоиска, ПоляПоиска);
	Если ЗначениеЗаполнено(НайденныеЭлементы) Тогда
		НайденныйЭлемент = НайденныеЭлементы[0];
	Иначе
		НайденныйЭлемент = Неопределено;
	КонецЕсли;
	
	Возврат НайденныйЭлемент;
	
КонецФункции // НайтиЭлементКоллекции()

// Производит поиск элементов коллекции по типу значений.
//
// Параметры:
//  Коллекция			 - Произвольный		 - Коллекция, поддерживающая обход "Для Каждого ..."
//  Тип					 - Тип				 - Тип искомых значений
//						 - ОписаниеТипов	 - Допустимые типы искомых значений
//						 - Строка			 - Имена типов через запятую
//	ТолькоЗаполненные	 - Булево			 - Будут отобраны только заполненные значения.
//
// Возвращаемое значение:
//	Массив - Отобранные элементы в порядке следования в исходной коллекции.
//
Функция НайтиЭлементыКоллекцииПоТипу(Коллекция, Тип, ТолькоЗаполненные = Ложь) Экспорт
	
	ОтобранныеЭлементы = Новый Массив;
	
	Если ТипЗнч(Тип) = Тип("Тип") Тогда
		ТипЭтоОписаниеТипов = Ложь;
		
	ИначеЕсли ТипЗнч(Тип) = Тип("ОписаниеТипов") Тогда
		ТипЭтоОписаниеТипов = Истина;
		ОписаниеТипов = Тип;
		
	ИначеЕсли ТипЗнч(Тип) = Тип("Строка") Тогда
		ТипЭтоОписаниеТипов = Истина;
		Попытка
			ОписаниеТипов = Новый ОписаниеТипов(Тип);
		Исключение
			ВызватьИсключение "Параметр Тип: Неверное описание типов";
		КонецПопытки;
		
	Иначе
		ВызватьИсключение "Параметр Тип: Неожиданный тип";
		
	КонецЕсли;
	
	Для Каждого ЭлементКоллекции Из Коллекция Цикл
		ТипЭлемента = ТипЗнч(ЭлементКоллекции);
		Если НЕ ТипЭтоОписаниеТипов И ТипЭлемента <> Тип Тогда
			Продолжить;
		КонецЕсли;
		Если ТипЭтоОписаниеТипов И НЕ ОписаниеТипов.СодержитТип(ТипЭлемента) Тогда
			Продолжить;
		КонецЕсли;
		Если ТолькоЗаполненные И НЕ ЗначениеЗаполнено(ЭлементКоллекции) Тогда
			Продолжить;
		КонецЕсли;
		ОтобранныеЭлементы.Добавить(ЭлементКоллекции);
	КонецЦикла;
	
	Возврат ОтобранныеЭлементы;
	
КонецФункции // НайтиЭлементыКоллекцииПоТипу()

// Обновляет состав коллекции из другой коллекции.
//	Обновляет существующие элементы;
//	добавляет, удаляет, сортирует исходные элементы коллекции без нарушения внутренних иденитфикаторов.
//	Предназначена для обновления отображаемых данных формы.
//
// Параметры:
//	Коллекция	 - ТаблицаЗначений - Коллекция из элементов с именованными полями.
//				 - ТабличнаяЧасть
//				 - ДанныеФормыКоллекция
//				 - ДанныеФормыСтруктураСКоллекцией
//	Данные		 - Произвольный - Обновленные данные. Аналогичен параметру Коллекция.
//	КлючевыеПоля - Строка - Имена ключевых полей, по которым сопоставляются существующие и обновленные элементы.
//	Добавлять	 - Булево - Новые элемент обновленных данных будут добавлены в Коллекцию.
//	Удалять		 - Булево - Элементы Коллекции, которых нет в обновленных данных, будут удалены.
//	Сортировать	 - Булево - Элементы, присутствующие в Данных, будет отсортированы с порядке следования в них.
//
Процедура ОбновитьКоллекцию(
	Коллекция, 
	Данные, 
	Знач КлючевыеПоля, 
	Добавлять = Истина, 
	Удалять = Истина,
	Сортировать = Истина) Экспорт

	#Область Проверки
	Если ТипЗнч(КлючевыеПоля) <> Тип("Строка") Тогда
		ВызватьИсключение "Параметр КлючевыеПоля: Ожидается тип Строка";
	КонецЕсли;
	Если ПустаяСтрока(КлючевыеПоля) Тогда
		ВызватьИсключение "Параметр КлючевыеПоля: Ожидается значение";
	КонецЕсли;
	#КонецОбласти // Проверки

	КлючевыеПоляСтрокой = КлючевыеПоля;
	ПараметрыПоиска = Новый Структура(КлючевыеПоляСтрокой);

	#Область Удаление
	ЭлементыБезДанных = Новый Массив;
	Для каждого ЭлементКоллекции Из Коллекция Цикл
		ЗаполнитьЗначенияСвойств(ПараметрыПоиска, ЭлементКоллекции);
		ЭлементыДанных = Данные.НайтиСтроки(ПараметрыПоиска);
		Если Не ЗначениеЗаполнено(ЭлементыДанных) Тогда
			ЭлементыБезДанных.Добавить(ЭлементКоллекции);
		КонецЕсли;
	КонецЦикла;
	Если Удалять Тогда
		Для Каждого ЭлементКоллекции Из ЭлементыБезДанных Цикл
			Коллекция.Удалить(ЭлементКоллекции);
		КонецЦикла;
	КонецЕсли;
	#КонецОбласти // Удаление

	#Область ДобавлениеОбновление
	ИндексДляСортировки = 0;
	НовыеИндексыЭлементов = Новый Соответствие;	// {ЭлементКоллекции, Число}
	Для каждого ЭлементДанных Из Данные Цикл
		ЗаполнитьЗначенияСвойств(ПараметрыПоиска, ЭлементДанных);
		ЭлементыКоллекции = Коллекция.НайтиСтроки(ПараметрыПоиска);
		Если Не ЗначениеЗаполнено(ЭлементыКоллекции) И Добавлять Тогда
			ЭлементыКоллекции.Добавить(Коллекция.Добавить());
		КонецЕсли;
		Для каждого ЭлементКоллекции Из ЭлементыКоллекции Цикл
			ЗаполнитьЗначенияСвойств(ЭлементКоллекции, ЭлементДанных);
			НовыеИндексыЭлементов[ЭлементКоллекции] = ИндексДляСортировки;
			ИндексДляСортировки = ИндексДляСортировки + 1;
		КонецЦикла;
	КонецЦикла;
	#КонецОбласти // ДобавлениеОбновление
	
	#Область Сортировка
	Если Сортировать Тогда

		// Запоминаем позиции удаленных элементов
		Если Не Удалять Тогда
			СтарыеИндексыЭлементов = Новый Соответствие;
			Для Каждого ЭлементКоллекции Из ЭлементыБезДанных Цикл
				СтарыеИндексыЭлементов[ЭлементКоллекции] = Коллекция.Индекс(ЭлементКоллекции);
			КонецЦикла;
		КонецЕсли;

		// Двигаем добавленные элементы в новые позиции
		Для каждого ЭлементИндекс Из НовыеИндексыЭлементов Цикл
			ЭлементКоллекции = ЭлементИндекс.Ключ;
			НовыйИндекс = ЭлементИндекс.Значение;
			ТекущийИндекс = Коллекция.Индекс(ЭлементКоллекции);
			Смещение = НовыйИндекс - ТекущийИндекс;
			Коллекция.Сдвинуть(ТекущийИндекс, Смещение);
		КонецЦикла;
		 	
		// Восстанавливаем удаленные элементы на старых позициях
		Если Не Удалять Тогда
			Для каждого ЭлементКоллекции Из ЭлементыБезДанных Цикл
				НовыйИндекс = СтарыеИндексыЭлементов[ЭлементКоллекции];
				ТекущийИндекс = Коллекция.Индекс(ЭлементКоллекции);
				Смещение = НовыйИндекс - ТекущийИндекс;
				Коллекция.Сдвинуть(ТекущийИндекс, Смещение);
			КонецЦикла;
		КонецЕсли;

	КонецЕсли;
	#КонецОбласти // Сортировка
		
КонецПроцедуры

// Формирует массив с элементами в обратном порядке.
//
// Параметры:
//  ИсходнаяКоллекция	 - Произвольный - Коллекция, поддерживающая обход посредством оператора Для каждого … Из … Цикл,
//										и метод Количество().
//
// Возвращаемое значение:
//  Массив - Элементы исходной коллекции в обратном порядке.
//
Функция ОбратныйПорядок(ИсходнаяКоллекция) Экспорт

	ЕстьМетодКоличество = Истина;	// На случай, если попадутся коллекции без метода, добавим их в исключения.
	
	Если ЕстьМетодКоличество Тогда
		Элементы = ИсходнаяКоллекция;
		ВГраница = Элементы.Количество() - 1;
	Иначе
		Элементы = Новый Массив;
		Для Каждого ТекущийЭлемент Из ИсходнаяКоллекция Цикл
			Элементы.Добавить(ТекущийЭлемент);
		КонецЦикла;
		ВГраница = Элементы.ВГраница();
	КонецЕсли;

	Индекс = ВГраница;
	ЭлементыВОбратномПорядке = Новый Массив(Элементы.Количество());
	Для Каждого ТекущийЭлемент Из Элементы Цикл
		ЭлементыВОбратномПорядке.Вставить(Индекс, ТекущийЭлемент);
		Индекс = Индекс - 1;
	КонецЦикла;
	
	Возврат ЭлементыВОбратномПорядке;
	
КонецФункции // ОбратныйПорядок()

// Получает N первых элементов коллекции
//
// Параметры:
//	Коллекция	 - Произвольный	 - Исходная коллекция. Должна поддерживать обход "Для Каждого...".
//	Количество	 - Число		 - Количество элементов к получению.
//
// Возвращаемое значение:
//	Массив - Элементы коллекции в порядке следования. 
//
Функция Первые(Коллекция, Знач Количество) Экспорт
	
	Количество = Цел(Количество);
	Первые = Новый Массив;

	Для Каждого Элемент Из Коллекция Цикл
		Первые.Добавить(Элемент);
		Если Первые.Количество() >= Количество Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;

	Возврат Первые;

КонецФункции // Первые()

// Получает N последних элементов коллекции
//
// Параметры:
//	Коллекция	 - Произвольный	 - Исходная коллекция. Должна поддерживать обход "Для Каждого...".
//	Количество	 - Число		 - Количество элементов к получению.
//
// Возвращаемое значение:
//	Массив - Элементы коллекции в порядке следования. 
//
Функция Последние(Коллекция, Знач Количество) Экспорт
	
	Количество = Цел(Количество);
	Последние = Новый Массив;

	Если ТипЗнч(Коллекция) = Тип("Массив") Тогда
		Для Индекс = Макс(0, Коллекция.ВГраница() - Количество) По Коллекция.ВГраница() Цикл
			Последние.Добавить(Коллекция[Индекс]);
		КонецЦикла;
	Иначе
		Массив = Новый Массив;
		Для Каждого Элемент Из Коллекция Цикл
			Массив.Добавить(Элемент);
		КонецЦикла;
		Возврат Последние(Массив, Количество);
	КонецЕсли;

	Возврат Последние;

КонецФункции

// Получает N элементов коллекции, начиная с указанной позиции.
//
// Параметры:
//	Коллекция		 - Произвольный	 - Исходная коллекция. Должна поддерживать обход "Для Каждого...".
//	НачальныйИндекс	 - Число		 - Индекс первого получаемого элемента.
//										Если не указан, будут получены элементы с начала коллекции.
//	Количество		 - Число		 - Количество элементов к получению. 
//										Если не указан, будут получены элементы до конца колелкции.
//
// Возвращаемое значение:
//	Массив - Элементы коллекции в порядке следования. 
//
Функция Средние(Коллекция, Знач НачальныйИндекс = 0, Знач Количество = 0) Экспорт

	НачальныйИндекс = Цел(НачальныйИндекс);
	Количество = Цел(Количество);
	Средние = Новый Массив;

	Если ТипЗнч(Коллекция) = Тип("Массив") Тогда
		Если Количество = 0 Тогда
			МаксимальныйИндекс = Коллекция.ВГраница();
		Иначе
			МаксимальныйИндекс = (НачальныйИндекс + Количество - 1);
		КонецЕсли;
		Для Индекс = НачальныйИндекс По МаксимальныйИндекс Цикл
			Средние.Добавить(Коллекция[Индекс]);
		КонецЦикла;
	Иначе
		Массив = Новый Массив;
		Для Каждого Элемент Из Коллекция Цикл
			Массив.Добавить(Элемент);
		КонецЦикла;
		Возврат Средние(Массив, НачальныйИндекс, Количество);
	КонецЕсли;

	Возврат Средние;
	
КонецФункции

// Возвращает первый элемент коллекции
//
// Параметры:
//  Коллекция - Произвольный - Исходная коллекция. Должна поддерживать обход "Для Каждого...".
//
// Возвращаемое значение:
//   Произвольный, Неопределено   - Первый элемент. Если коллекция не содержит элементов, будет возвращено Неопределено.
//
Функция ПервыйЭлементКоллекции(Коллекция) Экспорт

	ТипКоллекции = ТипЗнч(Коллекция);
	
	Элемент = Неопределено;

	Если ТипКоллекции = Тип("Массив") Или ТипКоллекции = Тип("ФиксированныйМассив") Тогда
		Если ЗначениеЗаполнено(Коллекция) Тогда
			Возврат Коллекция[0];
		КонецЕсли;
	Иначе
		Для каждого Элемент Из Коллекция Цикл
			Возврат Элемент; 
		КонецЦикла;
	КонецЕсли;

	Возврат Элемент;
	
КонецФункции

// Возвращает последний элемент коллекции
//
// Параметры:
//  Коллекция - Произвольный - Исходная коллекция. Должна поддерживать обход "Для Каждого...".
//
// Возвращаемое значение:
//   Произвольный, Неопределено   - Первый элемент. Если коллекция не содержит элементов, будет возвращено Неопределено.
//
Функция ПоследнийЭлементКоллекции(Коллекция) Экспорт

	// BSLLS:EmptyCodeBlock-off
	// BSLLS:UseLessForEach-off

	ТипКоллекции = ТипЗнч(Коллекция);
	
	Элемент = Неопределено;

	Если ТипКоллекции = Тип("Массив") Или ТипКоллекции = Тип("ФиксированныйМассив") Тогда
		Если ЗначениеЗаполнено(Коллекция) Тогда
			Возврат Коллекция[Коллекция.ВГраница()];
		КонецЕсли;
	Иначе
		Для каждого Элемент Из Коллекция Цикл
		КонецЦикла;
	КонецЕсли;

	Возврат Элемент;
	
	// BSLLS:UseLessForEach-on
	// BSLLS:EmptyCodeBlock-on

КонецФункции

// Меняет местами ключи и значения коллекции элементов типа КлючИЗначение.
// Из-за возможных дубликатов значений коллекций, состав элементов не гарантируется.
//
// Параметры:
//	Коллекция	 - Структура - Коллекция для обработки. Все значения должны быть строковыми.
//				 - Соответствие - Коллекция для обработки. Значения типа Неопределено будут проигнорированы.
//
// Возвращаемое значение:
//	Структура, Соответствие
//
Функция ПоменятьМестамиКлючиИЗначения(Коллекция) Экспорт
	
	ТипКоллекции = ТипЗнч(Коллекция);
	Если ТипКоллекции <> Тип("Структура") И ТипКоллекции <> Тип("Соответствие") Тогда
		ВызватьИсключение "Параметр Коллекция: Ожидается тип Структура или Соответствие";
	КонецЕсли;
	
	НоваяКоллекция = Новый(ТипКоллекции);
	Для Каждого Элемент Из Коллекция Цикл
		НоваяКоллекция.Вставить(Элемент.Значение, Элемент.Ключ);
	КонецЦикла;
	
	Возврат НоваяКоллекция;
	
КонецФункции // ПоменятьМестамиКлючиИЗначения()

// Нумерует элементы коллекции
//
// Параметры:
//	Коллекция		 - Произвольный	 - Коллекция для обработки.
//	ПолеНомер	 - Строка		 - Имя поля или колонки, содержащей номер
//	НачальныйНомер	 - Число		 - Номер первого элемента в коллекции
//
Процедура ПронумероватьКоллекцию(Коллекция, ПолеНомер, НачальныйНомер = 1)
	
	НомерЭлемента = НачальныйНомер - 1;
	Для Каждого ЭлементКоллекции Из Коллекция Цикл
		НомерЭлемента = НомерЭлемента + 1;
		ЭлементКоллекции[ПолеНомер] = НомерЭлемента;
	КонецЦикла;
	
КонецПроцедуры // ПронумероватьКоллекцию()

// Копирует переданную коллекцию
//
// Параметры:
//	Коллекция	 - ТаблицаЗначений
//				 - ДеревоЗначений
//				 - Структура,	 ФиксированнаяСтруктура
//				 - Соответствие, ФиксированноеСоответствие
//				 - Массив,		 ФиксированныйМассив
//				 - СписокЗначений
//				 - Произвольный - Прочие значения. Будет возвращено как есть, без копирования.
//	Рекурсивно	 - Булево - Если Истина, будут рекурсивно скопированы вложенные коллекции.
//							Например, Массив из Массив: Будут созданы копии каждого элемента - массива.
//
// Возвращаемое значение:
//	- Произвольный - Соответствует типу переданной коллекции.
//
Функция СкопироватьКоллекцию(Коллекция, Рекурсивно = Ложь) Экспорт
	
	ТипКоллекции = ТипЗнч(Коллекция);
	
	#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	
	Если ТипКоллекции = Тип("ТаблицаЗначений") Тогда
		
		Если НЕ Рекурсивно Тогда
			Возврат Источник.Скопировать();
		КонецЕсли;
		
		НоваяКоллекция = Коллекция.СкопироватьКолонки();
		МаксИндексКолонки = Коллекция.Колонки.Количество() - 1;
		Для Каждого СтрокаТаблицы Из Коллекция Цикл
			НоваяСтрока = НоваяКоллекция.Добавить();
			Для Индекс = 0 По МаксИндексКолонки Цикл
				Значение = ?(Рекурсивно,
						СкопироватьКоллекцию(СтрокаТаблицы[Индекс], Рекурсивно),
						СтрокаТаблицы[Индекс]);
				НоваяСтрока[Индекс] = Значение;
			КонецЦикла;
		КонецЦикла;
		Возврат НоваяКоллекция;
		
	КонецЕсли;
	
	Если ТипКоллекции = Тип("ДеревоЗначений") Тогда
		
		Если НЕ Рекурсивно Тогда
			Возврат Коллекция.Скопировать();
		КонецЕсли;
		
		НоваяКоллекция = Новый ДеревоЗначений;
		Для Каждого Колонка Из Коллекция.Колонки Цикл
			НоваяКоллекция.Колонки.Добавить(
				Колонка.Имя,
				Колонка.ТипЗначения,
				Колонка.Заголовок,
				Колонка.Ширина
			);
		КонецЦикла;
		Стек = Новый Массив;
		СтекРодителей = Новый Массив;
		Для Каждого ТекущаяСтрока Из Коллекция.Строки Цикл
			Стек.Добавить(ТекущаяСтрока);
			СтекРодителей.Добавить(НоваяКоллекция);
		КонецЦикла;
		СоответствиеСтрок[Коллекция] = НоваяКоллекция;
		МаксИндексКолонки = Коллекция.Колонки.Количество() - 1;
		Индекс = 0;
		Пока Индекс <= Стек.ВГраница() Цикл
			ТекущаяСтрока = Стек[Индекс];
			НовыйРодитель = СтекРодителей[Индекс];
			НоваяСтрока = НовыйРодитель.Строки.Добавить();
			Для ИндексКолонки = 0 По МаксИндексКолонки Цикл
				Значение = ?(Рекурсивно,
						СкопироватьКоллекцию(ТекущаяСтрока[ИндексКолонки], Рекурсивно),
						ТекущаяСтрока[ИндексКолонки]);
				НоваяСтрока[ИндексКолонки] = Значение;
			КонецЦикла;
			Для Каждого ПодчиненнаяСтрока Из ТекущаяСтрока.Строки Цикл
				Стек.Добавить(ПодчиненнаяСтрока);
				СтекРодителей.Добавить(ТекущаяСтрока);
			КонецЦикла;
			Индекс = Индекс + 1;
		КонецЦикла;
		Возврат НоваяКоллекция;
		
	КонецЕсли;
	
	#КонецЕсли // Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение
	
	Если ТипКоллекции = Тип("Структура") ИЛИ ТипКоллекции = Тип("ФиксированнаяСтруктура") Тогда
		
		НоваяКоллекция = Новый Структура;
		Для Каждого Элемент Из Коллекция Цикл
			Значение = ?(Рекурсивно, СкопироватьКоллекцию(Элемент.Значение, Рекурсивно), Элемент.Значение);
			НоваяКоллекция.Вставить(Элемент.Ключ, Значение);
			Если ТипКоллекции = Тип("ФиксированнаяСтруктура") Тогда
				НоваяКоллекция = Новый ФиксированнаяСтруктура(НоваяКоллекция);
			КонецЕсли;
		КонецЦикла;
		
	ИначеЕсли ТипКоллекции = Тип("Соответствие") ИЛИ ТипКоллекции = Тип("ФиксированноеСоответствие") Тогда
		
		НоваяКоллекция = Новый Соответствие;
		Для Каждого Элемент Из Коллекция Цикл
			Значение = ?(Рекурсивно, СкопироватьКоллекцию(Элемент.Значение, Рекурсивно), Элемент.Значение);
			НоваяКоллекция.Вставить(Элемент.Ключ, Значение);
			Если ТипКоллекции = Тип("ФиксированноеСоответствие") Тогда
				НоваяКоллекция = Новый ФиксированноеСоответствие(НоваяКоллекция);
			КонецЕсли;
		КонецЦикла;
		
	ИначеЕсли ТипКоллекции = Тип("Массив") Тогда
		
		НоваяКоллекция = Новый Массив(Коллекция.Количество());
		Для Индекс = 0 По Коллекция.ВГраница() Цикл
			Значение = ?(Рекурсивно, СкопироватьКоллекцию(Коллекция[Индекс], Рекурсивно), Коллекция[Индекс]);
			НоваяКоллекция[Индекс] = Значение;
			Если ТипКоллекции = Тип("ФиксированныйМассив") Тогда
				НоваяКоллекция = Новый ФиксированныйМассив(НоваяКоллекция);
			КонецЕсли;
		КонецЦикла;
		
	ИначеЕсли ТипКоллекции = Тип("СписокЗначений") Тогда
		
		НоваяКоллекция = Новый СписокЗначений;
		Для Каждого Элемент Из Коллекция Цикл
			Значение = ?(Рекурсивно, СкопироватьКоллекцию(Элемент.Значение, Рекурсивно), Элемент.Значение);
			Коллекция.Добавить(Значение, Элемент.Представление, Элемент.Пометка, Элемент.Картинка);
		КонецЦикла;
		
	Иначе
		НоваяКоллекция = Коллекция;
		
	КонецЕсли;
	
	Возврат НоваяКоллекция;
	
КонецФункции // СкопироватьКоллекцию()

// Сортирует коллекцию элементов по значениям полей элементов коллекции.
// Подобно методу ТаблицаЗначений.Сортировать()
//
// Параметры:
//	Коллекция	 - Произвольный				 - Любая коллекция,
//											поддерживающая обращение по индексу, метод Сдвинуть(Индекс, Смещение).
//				 - Массив из Произвольный	 - Частный вариант коллекции для сортировки.
//	Поля		 - Строка					 - Имена полей через запятую.
//											Для имени поля может быть указано направление сортировки (Возр или Убыв)
//
Процедура СортироватьКоллекцию(Коллекция, Поля) Экспорт
	
	Если НЕ ЗначениеЗаполнено(Коллекция) Тогда
		Возврат;
	КонецЕсли;
	
	КоллекцияЭтоМассив = (ТипЗнч(Коллекция) = Тип("Массив"));
	// Массив не поддерживает Сдвинуть() и Индекс(), но часто используется.
	
	Если НЕ КоллекцияЭтоМассив Тогда
		// Приводим к массиву, и запускаем рекурсию:
		КоллекцияМассив = Новый Массив;
		Для Каждого ЭлементКоллекции Из Коллекция Цикл
			КоллекцияМассив.Добавить(ЭлементКоллекции);
		КонецЦикла;
		СортироватьКоллекцию(КоллекцияМассив, Поля);
		
		ВерхняяГраница = КоллекцияМассив.ВГраница();
		Для Индекс = 0 По ВерхняяГраница Цикл
			Элемент = КоллекцияМассив[Индекс];
			ТекущийИндекс = Коллекция.Индекс(Элемент);
			Сдвиг = Индекс - ТекущийИндекс;
			Коллекция.Сдвинуть(ТекущийИндекс, Сдвиг);
		КонецЦикла;
		
		Возврат;
		
	КонецЕсли;
	
	// Далее коллекция - это массив.
	
	#Область ВыражениеСортировки
	Если ТипЗнч(Поля) = Тип("Строка") Тогда
		ВыраженияСортировки = Новый Массив;
		Для Каждого ВыражениеСортировки Из СтрРазделить(Поля, ",", Ложь) Цикл
			ВыраженияСортировки.Добавить(СокрЛП(ВыражениеСортировки));
		КонецЦикла;
	ИначеЕсли ТипЗнч(Поля) = Тип("Массив") Тогда
		ВыраженияСортировки = Поля;
	Иначе
		ВызватьИсключение "Параметр Поля: Ожидается тип Строка или Массив";
	КонецЕсли;
	Если НЕ ЗначениеЗаполнено(ВыраженияСортировки) Тогда
		ВызватьИсключение "Не указаны поля сортировки";
	КонецЕсли;
	ВыраженияСортировкиОбратныйПорядок = Новый Массив;
	Для Каждого ВыражениеСортировки Из ВыраженияСортировки Цикл
		ВыраженияСортировкиОбратныйПорядок.Вставить(0, ВыражениеСортировки);
	КонецЦикла;
	
	ВыражениеСортировки = ВыраженияСортировки[0];
	ПозицияРазделителя = СтрНайти(ВыражениеСортировки, " ");
	ЕстьНаправлениеСортировки = ПозицияРазделителя > 0;
	ПолеСортировки = ?(ЕстьНаправлениеСортировки,
			Лев(ВыражениеСортировки, ПозицияРазделителя - 1),
			СокрЛП(ВыражениеСортировки)
		);
	Если ЕстьНаправлениеСортировки Тогда
		СуффиксНаправления = ВРег(СокрЛП(Сред(ВыражениеСортировки, ПозицияРазделителя + 1)));
		Если СуффиксНаправления = "УБЫВ" ИЛИ СуффиксНаправления = "DESC" Тогда
			Направление = НаправлениеСортировки.Убыв;
		ИначеЕсли СуффиксНаправления = "ВОЗР" ИЛИ СуффиксНаправления = "ASC" Тогда
			Направление = НаправлениеСортировки.Возр;
		Иначе
			ВызватьИсключение СтрШаблон("Неверно указано направление сортировки по полю %1", ПолеСортировки);
		КонецЕсли;
	Иначе
		Направление = НаправлениеСортировки.Возр;
	КонецЕсли;
	#КонецОбласти // ВыражениеСортировки
	
	#Область Сортировка
	СписокСортировки = Новый СписокЗначений;
	ЭлементыСпискаКоллекции = Новый Соответствие; // {ЭлементСпискаЗначений; ЭлементКоллекции}
	Для Каждого ЭлементКоллекции Из Коллекция Цикл
		ЭлементСписка = СписокСортировки.Добавить(Неопределено);
		ЭлементыСпискаКоллекции[ЭлементСписка] = ЭлементКоллекции;
		ЭлементСписка.Значение = ЭлементКоллекции[ПолеСортировки];
	КонецЦикла;
	СписокСортировки.СортироватьПоЗначению(Направление);
	#КонецОбласти // Сортировка
	
	#Область ПрименениеРезультатов
	ВерхняяГраница = Коллекция.ВГраница();
	Для Индекс = 0 По ВерхняяГраница Цикл
		Коллекция.Установить(Индекс, ЭлементыСпискаКоллекции[СписокСортировки[Индекс]]);
	КонецЦикла;
	#КонецОбласти // ПрименениеРезультатов
	
	Если ВыраженияСортировки.ВГраница() = 0 Тогда
		Возврат; // Всё отсортировали
	КонецЕсли;
	
	#Область Рекурсия
	// Обходим отсортированную коллекцию, собирая группы с одинаковым значением.
	// Каждую группу сортируем рекурсивно.
	ВложенныеПоля = Новый Массив;
	Для Индекс = 1 По ВыраженияСортировки.ВГраница() Цикл
		ВложенныеПоля.Добавить(ВыраженияСортировки[Индекс]);
	КонецЦикла;
	
	ВложеннаяКоллекция = Новый Массив; // Все элементы с одинаковым значением текущего поля сортировки.
	ПредыдущееЗначениеПоля = Коллекция[0][ПолеСортировки];
	СтартовыйИндекс = 0;
	ВложенныеКоллекции = Новый Соответствие; // {Индекс первого элемента; Массив}
	Для Индекс = 0 По Коллекция.ВГраница() Цикл
		КлючевоеЗначениеИзменилось = (Коллекция[Индекс][ПолеСортировки] <> ПредыдущееЗначениеПоля);
		Если КлючевоеЗначениеИзменилось ИЛИ Индекс = Коллекция.ВГраница() Тогда
			КонечныйИндекс = ?(КлючевоеЗначениеИзменилось, Индекс - 1, Индекс);
			ВложеннаяКоллекция = Новый Массив;
			Для ВложенныйИндекс = СтартовыйИндекс По КонечныйИндекс Цикл
				ВложеннаяКоллекция.Добавить(Коллекция[ВложенныйИндекс]);
			КонецЦикла;
			ВложенныеКоллекции[СтартовыйИндекс] = ВложеннаяКоллекция;
			СтартовыйИндекс = Индекс;
			ПредыдущееЗначениеПоля = Коллекция[Индекс][ПолеСортировки];
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ОписаниеВложеннойКоллекции Из ВложенныеКоллекции Цикл
		СтартовыйИндекс = ОписаниеВложеннойКоллекции.Ключ;
		ВложеннаяКоллекция = ОписаниеВложеннойКоллекции.Значение;
		Если ВложеннаяКоллекция.Количество() = 1 Тогда
			Продолжить; // Такие сортировать незачем.
		КонецЕсли;
		СортироватьКоллекцию(ВложеннаяКоллекция, ВложенныеПоля);
		Для Индекс = 0 По ВложеннаяКоллекция.ВГраница() Цикл
			Коллекция[СтартовыйИндекс + Индекс] = ВложеннаяКоллекция[Индекс];
		КонецЦикла;
	КонецЦикла;
	
	#КонецОбласти // Рекурсия
	
КонецПроцедуры // СортироватьКоллекцию()

// Сортирует коллекцию по образцу.
//
// Параметры:
//	Коллекция	 - Произвольный				 - Любая коллекция, поддерживающая методы Индекс() и Сдвинуть().
//	Образец		 - Массив из Произвольный	 - Массив с элементами коллекции в нужном порядке.
//	СНачала 	 - Булево					 - Если Истина, элементы образца будут перемещены в начало коллекции.
//										Если Ложь - после первого элемента образца.
//
Процедура СортироватьКоллекциюПоОбразцу(Коллекция, Образец, СНачала = Истина) Экспорт
	
	Если Не ЗначениеЗаполнено(Коллекция) Тогда
		Возврат;
	КонецЕсли;	
	Если Не ЗначениеЗаполнено(Образец) Тогда
		Возврат;
	КонецЕсли;	
	Если ТипЗнч(Образец) <> Тип("Массив") Тогда
		ВызватьИсключение "Параметр Образец: Ожидается тип Массив";
	КонецЕсли;

	Для ИндексОбразца = 0 По Образец.ВГраница() Цикл
		Элемент = Образец[ИндексОбразца];
		ИндексЭлемента = Коллекция.Индекс(Элемент);
		Если ИндексЭлемента < 0 Тогда
			ВызватьИсключение "Элемент образца не принадлежит коллекции.";
		КонецЕсли;
		НачальныйИндекс = ?(СНачала, 0, Коллекция.Индекс(Образец[0]));
		ЦелевойИндекс = НачальныйИндекс + ИндексОбразца;
		Сдвиг = ЦелевойИндекс - ИндексЭлемента;
		Если Сдвиг <> 0 Тогда
			Коллекция.Сдвинуть(ИндексЭлемента, Сдвиг);
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры // СортироватьКоллекциюПоОбразцу()

#КонецОбласти // Коллекции

// Производит заполнение шаблона со строковыми параметрами
//
// Параметры:
//  Шаблон		 - Строка	 - Строка вида "Параметр %Параметр% содержит значение %Значение%"
//  Поля		 - Структура, Соответствие - Коллекция с именами параметров и текстом, который надо подставить в шаблон.
//											 Например: Новый Структура("Параметр, Значение", "Цвет", "Красный")
//  ПрефиксПоля	 - Строка	 - Префикс поля в шаблоне
//  СуффиксПоля	 - Строка	 - Суффикс поля в шаблоне
//
// Возвращаемое значение:
//  Строка - Шаблон с подставленными параметрами
//
Функция ЗаполнитьПоляШаблона(Шаблон, Поля, ПрефиксПоля = "%", СуффиксПоля = "%") Экспорт
	
	Результат = Шаблон;
	Для Каждого Поле Из Поля Цикл
		Результат = СтрЗаменить(Результат, ПрефиксПоля + Поле.Ключ + СуффиксПоля, Поле.Значение);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции // ЗаполнитьПоляШаблона()

// Делит разыменование поля на составляющие с неполными путями
//
// Параметры:
//  Разыменование	 - Строка	 - Делимое разыменование
//
// Возвращаемое значение:
//  Массив из Строка
//
// Пример:
//	Разыменование вида Поле1.Поле2.Поле3 будет разложено на массив вида [Поле1, Поле1.Поле2, Поле1.Поле2.Поле3]
//
Функция РазделитьРазыменованиеНаНеполныеПути(Знач Разыменование) Экспорт
	
	МассивПолей = СтрРазделить(Разыменование, ".");
	МассивПутей = Новый Массив;
	Для Индекс = 0 По МассивПолей.ВГраница() Цикл
		НеполныйПуть = Новый Массив;
		Для НеполныйИндекс = 0 По Индекс Цикл
			НеполныйПуть.Добавить(МассивПолей[НеполныйИндекс]);
		КонецЦикла;
		МассивПутей.Добавить(СтрСоединить(НеполныйПуть, "."));
	КонецЦикла;
	
	Возврат МассивПутей;
	
КонецФункции // РазделитьРазыменованиеНаНеполныеПути()

#Область Строки

#Область СистемыСчисления

// Преобразует значение в двоичное число
// 
// Параметры:
//	Значение - Строка 	- Число в строковом представлении. 
//						Может быть двоичным или шестнадцатеричным представлением числа.
//						В этом случае должно иметь префикс "0b" или "0x" соответственно.
//			 - Число	 - Десятичное число.
//			 - Булево	 - Преобразуется к числу.
//
// Возвращаемое значение:
//	Строка - Двоичное представление числа с префиксом "0b"
//
Функция ДвоичноеЧисло(Значение)

	Если ТипЗнч(Значение) = Тип("Число") Тогда
		
		ЧислоСтрокой = XMLСтрока(Значение);

	ИначеЕсли ТипЗнч(Значение) = Тип("Строка") Тогда

		ДлинаПрефикса = 2;
		Если СтрДлина(Значение) > ДлинаПрефикса Тогда
			Префикс = НРег(Лев(Значение, ДлинаПрефикса));
			Если Префикс = "0x" Тогда
				Возврат ДвоичноеЧисло(ЧислоИзШестнадцатеричнойСтроки(Значение));
			КонецЕсли;
			Если Префикс = "0b" Тогда
				Возврат Значение;
			КонецЕсли;
		КонецЕсли;

		ЧислоСтрокой = Значение;

	ИначеЕсли ТипЗнч(Значение) = Тип("Булево") Тогда

		Возврат ?(Значение, "0b1", "0b0");

	Иначе
		ВызватьИсключение СтрШаблон("Значение «%1» нельзя преобразовать к двоичному числу.", Строка(Значение));

	КонецЕсли;

	ОснованиеДесятичное = 10;
	ОснованиеДвоичное = 2;
	ДвоичноеЧисло = ПреобразоватьСистемуСчисления(ЧислоСтрокой, ОснованиеДесятичное, ОснованиеДвоичное);

	Возврат "0b" + ?(ПустаяСтрока(ДвоичноеЧисло), "0", "");

КонецФункции

// Преобразует значение в десятичное число
// 
// Параметры:
//	Значение - Строка 	- Число в строковом представлении. 
//						Может быть двоичным или шестнадцатеричным представлением числа.
//						В этом случае должно иметь префикс "0b" или "0x" соответственно.
//			 - Число	 - Возвращает число как есть.
//			 - Булево	 - Преобразуется к числу.
//
// Возвращаемое значение:
//	Число
//
Функция ДесятичноеЧисло(Знач Значение)
	
	Если ТипЗнч(Значение) = Тип("Число") Тогда
		Возврат Значение; 

	ИначеЕсли ТипЗнч(Значение) = Тип("Булево") Тогда
		Возврат Число(Значение);

	ИначеЕсли ТипЗнч(Значение) = Тип("Строка") Тогда

		ДлинаПрефикса = 2;
		Если СтрДлина(Значение) > ДлинаПрефикса Тогда
			Префикс = НРег(Лев(Значение, ДлинаПрефикса));
			Если Префикс = "0x" Тогда
				Возврат ЧислоИзШестнадцатеричнойСтроки(Значение);
			КонецЕсли;
			Если Префикс = "0b" Тогда
				Возврат ЧислоИзДвоичнойСтроки(Значение);
			КонецЕсли;
		КонецЕсли;

		Возврат Число(Значение);

	Иначе
		ВызватьИсключение СтрШаблон("Значение «%1» нельзя преобразовать к десятичному числу.", Строка(Значение));

	КонецЕсли;

КонецФункции	// ДесятичноеЧисло()

// Преобразует значение в шестнадцатеричное число
// 
// Параметры:
//	Значение - Строка 	- Число в строковом представлении. 
//						Может быть двоичным или шестнадцатеричным представлением числа.
//						В этом случае должно иметь префикс "0b" или "0x" соответственно.
//			 - Число	 - Десятичное число.
//			 - Булево	 - Преобразуется к числу.
//
// Возвращаемое значение:
//	Строка - Двоичное представление числа с префиксом "0x"
//
Функция ШестнадцатеричноеЧисло(Значение)

	Если ТипЗнч(Значение) = Тип("Число") Тогда
		
		ЧислоСтрокой = XMLСтрока(Значение);

	ИначеЕсли ТипЗнч(Значение) = Тип("Строка") Тогда

		ДлинаПрефикса = 2;
		Если СтрДлина(Значение) > ДлинаПрефикса Тогда
			Префикс = НРег(Лев(Значение, ДлинаПрефикса));
			Если Префикс = "0b" Тогда
				Возврат ШестнадцатеричноеЧисло(ЧислоИзДвоичнойСтроки(Значение));
			КонецЕсли;
			Если Префикс = "0x" Тогда
				Возврат Значение;
			КонецЕсли;
		КонецЕсли;

		ЧислоСтрокой = Значение;

	ИначеЕсли ТипЗнч(Значение) = Тип("Булево") Тогда

		Возврат ?(Значение, "0x1", "0x0");

	Иначе
		ВызватьИсключение СтрШаблон("Значение «%1» нельзя преобразовать к двоичному числу.", Строка(Значение));

	КонецЕсли;

	ОснованиеДесятичное = 10;
	ОснованиеШестнадцатеричное = 16;
	ДвоичноеЧисло = ПреобразоватьСистемуСчисления(ЧислоСтрокой, ОснованиеДесятичное, ОснованиеШестнадцатеричное);

	Возврат "0x" + ?(ПустаяСтрока(ДвоичноеЧисло), "0", "");
	
КонецФункции // ШестнадцатеричноеЧисло()

// Переводит число из одной позиционной системы счисления в другую.
//
// Параметры:
//	ЧислоСтрокой		 - Строка	 - Исходное число
//	ОснованиеИсходное	 - Число	 - Основание исходного числа. Для десятичной системы будет 10, для двоичной - 2.
//	ОснованиеНовое		 - Число	 - Целевое основание.
//
// Возвращаемое значение:
//	Строка - Строковое представление числа.
//
Функция ПреобразоватьСистемуСчисления(Знач ЧислоСтрокой, ОснованиеИсходное, ОснованиеНовое) Экспорт
	
	Если ОснованиеИсходное = ОснованиеНовое Тогда
		Возврат ЧислоСтрокой;
	КонецЕсли;
	
	Разряды = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	ЕмкостьАлфавита = СтрДлина(Разряды);
	
	МаксОснование = Макс(ОснованиеИсходное, ОснованиеНовое);
	Если МаксОснование > ЕмкостьАлфавита Тогда
		ВызватьИсключение "Основание больше ёмкости алфавита";
	КонецЕсли;
	
	Если Мин(ОснованиеИсходное, ОснованиеНовое) < 2 Тогда
		ВызватьИсключение "Неверно указано Основание";
	КонецЕсли;
	
	Цифры = Новый Массив;
	Числа = Новый Соответствие;
	Для НомерСимвола = 1 По Мин(ЕмкостьАлфавита, МаксОснование) Цикл
		Символ = Сред(Разряды, НомерСимвола, 1);
		Цифры.Добавить(Символ);
		Числа[Символ] = НомерСимвола - 1;
	КонецЦикла;
	
	ЧислоСтрокой = СокрЛП(ЧислоСтрокой);
	ДлинаЧислаИсх = СтрДлина(ЧислоСтрокой);
	
	// Из произвольной в десятичную:
	ЧислоДес = 0;
	Для НомерСимвола = 1 По ДлинаЧислаИсх Цикл
		Степень = ДлинаЧислаИсх - НомерСимвола;
		Символ = Сред(ЧислоСтрокой, НомерСимвола, 1);
		Число = Числа[Символ];
		Если Число = Неопределено ИЛИ Число >= ОснованиеИсходное Тогда
			ВызватьИсключение "Исходное число не соответствует своей системе счисления";
		КонецЕсли;
		ЧислоДес = ЧислоДес + Число * Pow(ОснованиеИсходное, Степень);
	КонецЦикла;
	
	Если ОснованиеНовое = 10 Тогда
		Возврат Формат(ЧислоДес, "ЧГ=;ЧН=0");
	КонецЕсли;
	
	// Из десятичного в произвольную:
	ЧислоНовое = "";
	Частное = ЧислоДес;
	Пока Частное > 0 Цикл
		Уменьшаемое = Частное % ОснованиеНовое;
		ЧислоНовое = Цифры[Уменьшаемое] + ЧислоНовое;
		Частное = Цел(Частное / ОснованиеНовое);
	КонецЦикла;
	
	Возврат ЧислоНовое;
	
КонецФункции // ПреобразоватьСистемуСчисления()

// Является аналогом одноимённой платформеной функции, и используется для обратной совестимости.
//
// Преобразует двоичную строку в значение типа Число.
// Двоичная строка должна начинаться с префикса "0b", после которого следуют двоичные цифры (одна или больше). 
// Поддерживаются только натуральные числа.
// Примеры корректных строк: "0b0011001", "0b101001111".
// 
// Параметры:
//	ДвоичнаяСтрока - Строка - Двоичная строка.
//
// Возвращаемое значение:
//	Число
// 
Функция ЧислоИзДвоичнойСтроки(Знач ДвоичнаяСтрока)
	
	ДопустимыйПрефикс = "0b";
	ДопустимыеСимволы = "01";
	ИсходнаяСтрока = ДвоичнаяСтрока;
	Основание = 2;

	Если СтрДлина(ИсходнаяСтрока) < 3 Тогда
		ВызватьИсключение "Строка не содержит значимых символов";
	КонецЕсли;
	Префикс = НРег(Лев(ИсходнаяСтрока, 2));
	Если Префикс <> ДопустимыйПрефикс Тогда
		ВызватьИсключение СтрШаблон("Строка должна начинаться с префикса ""%1""", ДопустимыйПрефикс);
	КонецЕсли;

	СтрокаБезПрефиксаНрег = НРег(Сред(ИсходнаяСтрока, 3));
	Для НомерСимвола = 1 По СтрДлина(СтрокаБезПрефиксаНрег) Цикл
		Если Не СтрНайти(ДопустимыеСимволы, Сред(СтрокаБезПрефиксаНрег, НомерСимвола, 1)) Тогда
			ВызватьИсключение "Строка содержит недопустимые символы";
		КонецЕсли;
	КонецЦикла;
	Число = Число(ПреобразоватьСистемуСчисления(СтрокаБезПрефиксаНрег, Основание, 10));

	Возврат Число;

КонецФункции

// Является аналогом одноимённой платформеной функции, и используется для обратной совестимости.
//
// Преобразует шестнадцатеричную строку в значение типа Число.
// Строка должна начинаться с префикса "0x", после которого следуют одна или несколько шестнадцатеричных цифр. Другие символы в строке не допускаются.
// Поддерживаются только натуральные числа.
// Отрицательные и числа с дробной частью не поддерживаются.
// Примеры допустимых строк: "0x003A", "0xabcde".
// 
// Параметры:
//	ШестнадцатеричнаяСтрока - Строка - Шестнадцатеричная строка.
//
// Возвращаемое значение:
//	Число
// 
Функция ЧислоИзШестнадцатеричнойСтроки(Знач ШестнадцатеричнаяСтрока)

	ДопустимыйПрефикс = "0x";
	ДопустимыеСимволы = "0123456789abcdef";
	ИсходнаяСтрока = ШестнадцатеричнаяСтрока;
	Основание = 16;
	
	Если СтрДлина(ИсходнаяСтрока) < 3 Тогда
		ВызватьИсключение "Строка не содержит значимых символов";
	КонецЕсли;
	Префикс = НРег(Лев(ИсходнаяСтрока, 2));
	Если Префикс <> ДопустимыйПрефикс Тогда
		ВызватьИсключение СтрШаблон("Строка должна начинаться с префикса ""%1""", ДопустимыйПрефикс);
	КонецЕсли;

	СтрокаБезПрефиксаНрег = НРег(Сред(ИсходнаяСтрока, 3));
	Для НомерСимвола = 1 По СтрДлина(СтрокаБезПрефиксаНрег) Цикл
		Если Не СтрНайти(ДопустимыеСимволы, Сред(СтрокаБезПрефиксаНрег, НомерСимвола, 1)) Тогда
			ВызватьИсключение "Строка содержит недопустимые символы";
		КонецЕсли;
	КонецЦикла;
	Число = Число(ПреобразоватьСистемуСчисления(СтрокаБезПрефиксаНрег, Основание, 10));

	Возврат Число;

КонецФункции

#КонецОбласти // СистемыСчисления

#Область РимскиеЧисла

// Возвращает римский литерал из юникода,
// соответствующий переданному числу.
//
// Параметры:
//	Число - Число - Целое число в пределах от 1 до 12.
//
// Возвращаемое значение:
//	Строка - Литерал.
//
Функция РимскийЛитерал(Число) Экспорт
	
	ЭтоВалидноеЧисло = (ТипЗнч(Число) = Тип("Число")) И (1 <= Число И Число <= 12) И (Число = Цел(Число));
	Если НЕ ЭтоВалидноеЧисло Тогда
		ВызватьИсключение "Параметр Число: Неожиданное значение";
	КонецЕсли;
	
	КодРимскойЕдиницы = КодСимвола("Ⅰ"); // U+2160 Roman Number One
	Смещение = Число - 1;
	РимскийЛитерал = Символ(КодРимскойЕдиницы + Смещение);
	
	Возврат РимскийЛитерал;
	
КонецФункции // РимскийЛитерал()

// Преобразует число в римское.
// Аналогична функции РИМСКОЕ() из Microsoft Excel
// см. https://support.microsoft.com/ru-ru/office/функция-римское-d6b0b99e-de46-4704-a518-b45a0f8b56f5
//
// Параметры:
//	Число	 - Число	 - Исходное целое число в диапазоне [1..3999]
//	Форма	 - Число	 - Форма упрощения числа, от 0 до 4, где 0 = Классическая, а 4 - упрощённая. См. примеры.
//			 - Булево	 - Истина соответствует классической формы написания, Ложь - Упрощённой.
//
// Возвращаемое значение:
//	Строка - Римское написание числа.
//
// Примеры:
//	РимскоеЧисло(499, 0); // "CDXCIX"
//	РимскоеЧисло(499, 1); // "LDVLIV"
//	РимскоеЧисло(499, 2); // "XDIX"
//	РимскоеЧисло(499, 3); // "VDIV"
//	РимскоеЧисло(499, 4); // "ID"
//
Функция РимскоеЧисло(Число, Знач Форма = Истина) Экспорт
	
	ЭтоВалидноеЧисло = (ТипЗнч(Число) = Тип("Число")) И (1 <= Число И Число <= 3999) И (Число = Цел(Число));
	Если НЕ ЭтоВалидноеЧисло Тогда
		ВызватьИсключение "Параметр Число: Неожиданное значение";
	КонецЕсли;
	
	ЭтоВалиднаяФорма = (ТипЗнч(Форма) = Тип("Число")) И (0 <= Форма И Форма <= 4) И (Число = Цел(Число))
		ИЛИ ТипЗнч(Форма) = Тип("Булево");
	Если НЕ ЭтоВалиднаяФорма Тогда
		ВызватьИсключение "Параметр Форма: Неожиданное значение";
	КонецЕсли;
	
	Если ТипЗнч(Форма) = Тип("Булево") Тогда
		Форма = ?(Форма = Истина, 0, 4);
	КонецЕсли;
	
	Разряды = Новый Соответствие;
	
	Разряды = Новый СписокЗначений;
	Разряды.Добавить(1000, "M");
	Разряды.Добавить(500, "D");
	Разряды.Добавить(100, "C");
	Разряды.Добавить(50, "L");
	Разряды.Добавить(10, "X");
	Разряды.Добавить(5, "V");
	Разряды.Добавить(1, "I");
	
	ЗначенияРазрядов = Новый Соответствие;
	Для Каждого Разряд Из Разряды Цикл
		ЗначенияРазрядов[Разряд.Представление] = Разряд.Значение;
	КонецЦикла;
	
	Сочетания = Разряды.Скопировать();
	
	ТаблицаВычитаний = "
		// Описывает, какие вычитания возможны, в зависимости от формы:
		//	0	1	2	3	4
		|M	C	L	X	V	I
		|D	C	L	X	V	I
		|C	X	V	I		
		|L	X	V	I		
		|X	I				
		|V	I				
		|";
	РазрядыСочетаний = СтрРазделить(ТаблицаВычитаний, Символы.ПС, Ложь);
	Для Каждого РазрядСочетаний Из РазрядыСочетаний Цикл
		ТекущиеСочетания = СтрРазделить(РазрядСочетаний, Символы.Таб, Ложь);
		БазовыйРазряд = ТекущиеСочетания[0];
		База = ЗначенияРазрядов[БазовыйРазряд];
		МаксИндексСочетания = Мин(Форма + 1, ТекущиеСочетания.ВГраница());
		Для ИндексСочетания = 1 По МаксИндексСочетания Цикл
			ТекущийРазряд = ТекущиеСочетания[ИндексСочетания];
			СочетаниеЗначение = База - ЗначенияРазрядов[ТекущийРазряд];
			СочетаниеПредставление = ТекущийРазряд + БазовыйРазряд;
			Сочетания.Добавить(СочетаниеЗначение, СочетаниеПредставление);
		КонецЦикла;
	КонецЦикла;
	
	Сочетания.СортироватьПоЗначению(НаправлениеСортировки.Убыв);
	
	РимскоеЧисло = "";
	УменьшаемоеЗначение = Число;
	ИндексВычитаемого = 0;
	Пока УменьшаемоеЗначение > 0 Цикл
		Сочетание = Сочетания[ИндексВычитаемого];
		Если УменьшаемоеЗначение < Сочетание.Значение Тогда
			ИндексВычитаемого = ИндексВычитаемого + 1;
			Продолжить;
		Иначе
			РимскоеЧисло = РимскоеЧисло + Сочетание.Представление;
			УменьшаемоеЗначение = УменьшаемоеЗначение - Сочетание.Значение;
		КонецЕсли;
	КонецЦикла;
	
	Возврат РимскоеЧисло;
	
КонецФункции // РимскоеЧисло()

// Преобразует число из римской формы счисления.
//
// Параметры:
//	РимскоеЧисло - Строка - Строка в формате классического римского числа (Напр.: "MDCLXVI")
//
// Возвращаемое значение:
//	Число - Число в диапазоне [1..3999]
//
Функция ЧислоИзРимскогоЧисла(Знач РимскоеЧисло) Экспорт
	
	Если ТипЗнч(РимскоеЧисло) <> Тип("Строка") ИЛИ ПустаяСтрока(РимскоеЧисло) Тогда
		ВызватьИсключение "Параметр РимскоеЧисло: Неожиданное значение";
	КонецЕсли;
	
	РимскоеЧисло = ВРег(СокрЛП(РимскоеЧисло));
	
	ЗначенияСимволов = Новый Соответствие;
	ЗначенияСимволов.Вставить("M", 1000);
	ЗначенияСимволов.Вставить("D", 500);
	ЗначенияСимволов.Вставить("C", 100);
	ЗначенияСимволов.Вставить("L", 50);
	ЗначенияСимволов.Вставить("X", 10);
	ЗначенияСимволов.Вставить("V", 5);
	ЗначенияСимволов.Вставить("I", 1);
	
	ДлинаРимскогоЧисла = СтрДлина(РимскоеЧисло);
	
	ЗначенияРазрядов = Новый Соответствие;
	Для Позиция = 1 По ДлинаРимскогоЧисла Цикл
		ТекущийСимвол = Сред(РимскоеЧисло, Позиция, 1);
		ТекущееЗначение = ЗначенияСимволов[ТекущийСимвол];
		Если ТекущееЗначение = Неопределено Тогда
			ВызватьИсключение СтрШаблон("Параметр РимскоеЧисло: Неожиданный символ (%1)", ТекущийСимвол);
		КонецЕсли;
		ЗначенияРазрядов[Позиция] = ТекущееЗначение;
	КонецЦикла;
	
	Результат = 0;
	
	Для Позиция = 1 По ДлинаРимскогоЧисла Цикл
		ТекущийСимвол = Сред(РимскоеЧисло, Позиция, 1);
		ТекущееЗначение = ЗначенияРазрядов[Позиция];
		Если Позиция < ДлинаРимскогоЧисла Тогда
			СледующееЗначение = ЗначенияРазрядов[Позиция + 1];
			Если СледующееЗначение > ТекущееЗначение Тогда
				Результат = Результат + (СледующееЗначение - ТекущееЗначение);
				Позиция = Позиция + 1;
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		Результат = Результат + ТекущееЗначение;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции // ЧислоИзРимскогоЧисла()

#КонецОбласти // РимскиеЧисла

#Область Транслитерация

// Выполняет транслитерацию строки.
// см. https://ru.wikipedia.org/wiki/Транслитерация_русского_алфавита_латиницей
//
// Параметры:
//  Фраза	 - Строка	 - Исходная строка
//  Стандарт - Строка	 - Стандарт транслитерации. Варианты:
//		* 4271	 - Приказ МИД N 4271 (2016-н/в)
//				(см. http://www.consultant.ru/document/cons_doc_LAW_198429/c956ff01bf42465d7052431dec215b77d0404875)
//		* 310	 - Приказ МВД N 310 (1997-2010)
//
// Возвращаемое значение:
//  Строка - Результат транслитерации
//
Функция ТранслитерироватьСтроку(Знач Фраза, Стандарт = "4271")
	
	// Контрольный пример: абвгдеёжзийклмнопрстуфхцчшщъыьэюя. Съешь этих мягких французских булочек, да выпей же чаю. ВЕРХНИЙРЕГИСТР, Перваязаглавная, нижнийрегистр, СмешанныйРегистр. Слова123с5434Цифрами.и_$ЗНАКАМИ%вперемешку.
	
	ФразаЛатиницей = "";
	
	СоответствиеБукв = Новый Соответствие;
	#Область ОбщиеДляВсехСтандартовСимволы
	
	// Те символы, которые различаются в стандартах - не заполнены
	СоответствиеБукв.Вставить("а", "a");
	СоответствиеБукв.Вставить("б", "b");
	СоответствиеБукв.Вставить("в", "v");
	СоответствиеБукв.Вставить("г", "g");
	СоответствиеБукв.Вставить("д", "d");
	СоответствиеБукв.Вставить("е", "");
	СоответствиеБукв.Вставить("ё", "");
	СоответствиеБукв.Вставить("ж", "");
	СоответствиеБукв.Вставить("з", "z");
	СоответствиеБукв.Вставить("и", "");
	СоответствиеБукв.Вставить("й", "");
	СоответствиеБукв.Вставить("к", "k");
	СоответствиеБукв.Вставить("л", "l");
	СоответствиеБукв.Вставить("м", "m");
	СоответствиеБукв.Вставить("н", "n");
	СоответствиеБукв.Вставить("о", "o");
	СоответствиеБукв.Вставить("п", "p");
	СоответствиеБукв.Вставить("р", "r");
	СоответствиеБукв.Вставить("с", "s");
	СоответствиеБукв.Вставить("т", "t");
	СоответствиеБукв.Вставить("у", "u");
	СоответствиеБукв.Вставить("ф", "f");
	СоответствиеБукв.Вставить("х", "");
	СоответствиеБукв.Вставить("ц", "");
	СоответствиеБукв.Вставить("ч", "");
	СоответствиеБукв.Вставить("ш", "");
	СоответствиеБукв.Вставить("щ", "");
	СоответствиеБукв.Вставить("ъ", "");
	СоответствиеБукв.Вставить("ы", "");
	СоответствиеБукв.Вставить("ь", "");
	СоответствиеБукв.Вставить("э", "");
	СоответствиеБукв.Вставить("ю", "");
	СоответствиеБукв.Вставить("я", "");
	
	// Буквы-исключения: Е, Ё, Ж, И, Й, Х, Ц, Ч, Ш, Щ, Ъ, Ы, Ь, Э, Ю, Я.
	БуквыИсключения = СтрРазделить("е, ё, ж, и, й, х, ц, ч, ш, щ, ъ, ы, ь, э, ю, я", ", ", Ложь);
	Для Каждого ТекущийСимвол Из БуквыИсключения Цикл
		СоответствиеБукв.Вставить(ТекущийСимвол, "");
	КонецЦикла;
	
	#КонецОбласти // ОбщиеДляВсехСтандартовСимволы
	
	#Область ОписаниеСтандартов
	Если Стандарт = "4271" Тогда
		
		СоответствиеБукв.Вставить("е", "e");
		СоответствиеБукв.Вставить("ё", "e");
		СоответствиеБукв.Вставить("ж", "zh");
		СоответствиеБукв.Вставить("и", "i");
		СоответствиеБукв.Вставить("й", "i");
		СоответствиеБукв.Вставить("х", "kh");
		СоответствиеБукв.Вставить("ц", "ts");
		СоответствиеБукв.Вставить("ч", "ch");
		СоответствиеБукв.Вставить("ш", "sh");
		СоответствиеБукв.Вставить("щ", "shch");
		СоответствиеБукв.Вставить("ъ", "ie");
		СоответствиеБукв.Вставить("ы", "y");
		СоответствиеБукв.Вставить("ь", ""); // пропускается
		СоответствиеБукв.Вставить("э", "e");
		СоответствиеБукв.Вставить("ю", "iu");
		СоответствиеБукв.Вставить("я", "ia");
		
	ИначеЕсли Стандарт = "310" Тогда
		
		// см. СтроковыеФункцииКлиентСервер.СоответствиеКириллицыИЛатиницы()
		// или СтроковыеФункцииКлиентСервер.СоответствиеНациональногоАлфавитаИЛатиницы() (БСП)
		СоответствиеБукв.Вставить("е", "e");
		СоответствиеБукв.Вставить("ё", "e");
		СоответствиеБукв.Вставить("ж", "zh");
		СоответствиеБукв.Вставить("и", "i");
		СоответствиеБукв.Вставить("й", "y");
		СоответствиеБукв.Вставить("х", "kh");
		СоответствиеБукв.Вставить("ц", "ts");
		СоответствиеБукв.Вставить("ч", "ch");
		СоответствиеБукв.Вставить("ш", "sh");
		СоответствиеБукв.Вставить("щ", "shch");
		СоответствиеБукв.Вставить("ъ", """");
		СоответствиеБукв.Вставить("ы", "y");
		СоответствиеБукв.Вставить("ь", ""); // пропускается
		СоответствиеБукв.Вставить("э", "e");
		СоответствиеБукв.Вставить("ю", "yu");
		СоответствиеБукв.Вставить("я", "ya");
		
	Иначе
		
		Возврат "";
		
	КонецЕсли;
	#КонецОбласти // ОписаниеСтандартов
	
	ПредыдущийСимвол = "";
	
	Слово = "";
	СловоЛатиницей = "";
	ДлинаСтроки = СтрДлина(Фраза);
	Для Позиция = 1 По ДлинаСтроки Цикл
		
		ТекущийСимвол = Сред(Фраза, Позиция, 1);
		
		ЭтоБуква = СоответствиеБукв[НРег(ТекущийСимвол)] <> Неопределено;
		
		Если ЭтоБуква Тогда
			
			Буква = ТекущийСимвол;
			БукваЛатиницей = СоответствиеБукв[НРег(ТекущийСимвол)]; // Поиск соответствия без учета регистра.
			Если Буква = ВРег(Буква) Тогда
				БукваЛатиницей = ТРег(БукваЛатиницей);
			КонецЕсли;
			
			Слово = Слово + Буква;
			СловоЛатиницей = СловоЛатиницей + БукваЛатиницей;
			
		КонецЕсли;
		
		СловоЗакончилось = ЗначениеЗаполнено(Слово) И (НЕ ЭтоБуква ИЛИ Позиция = ДлинаСтроки);
		
		Если СловоЗакончилось Тогда
			
			Если Слово = Врег(Слово) Тогда
				СловоЛатиницей = ВРег(СловоЛатиницей);
			ИначеЕсли Слово = НРег(Слово) Тогда
				СловоЛатиницей = НРег(СловоЛатиницей);
			ИначеЕсли Слово = ТРег(Слово) Тогда
				СловоЛатиницей = ТРег(СловоЛатиницей);
			КонецЕсли;
			ФразаЛатиницей = ФразаЛатиницей + СловоЛатиницей;
			
			Слово = "";
			СловоЛатиницей = "";
			
		КонецЕсли;
		
		Если НЕ ЭтоБуква Тогда
			
			ФразаЛатиницей = ФразаЛатиницей + ТекущийСимвол;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ФразаЛатиницей;
	
КонецФункции // ТранслитерироватьСтроку

// Различающиеся символы раскладок клавиатуры Йцукен и Qwerty
//
// Возвращаемое значение:
//   Структура - Символы раскладок в порядке, соответствующем положению клавиш на клавиатуре.
//		* Йцукен - Строка - Символы раскладки кириллицы
//		* Qwerty - Строка - Символы раскладки латиницы
//
Функция РазличныеСимволыРаскладокЙцукенQwerty()
	
	Йцукен = "ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,Ё!""№;%:?/"; // Заглавный алфавит, потом верхний ряд с Ё до 7, потом шифт-черта
	Qwerty = "QWERTYUIOP{}ASDFGHJKL:""ZXCVBNM<>?~!@#$%^&|"; // Заглавный алфавит, потом верхний ряд с ~ до 7, потом шифт-черта
	Йцукен = Йцукен + "йцукенгшщзхъфывапролджэячсмитьбю.ё"; // Строчный алфавит и ё
	Qwerty = Qwerty + "qwertyuiop[]asdfghjkl;'zxcvbnm,./`"; // Строчный алфавит и `
	
	Раскладки = Новый Структура;
	Раскладки.Вставить("Йцукен", Йцукен);
	Раскладки.Вставить("Qwerty", Qwerty);
	
	Если СтрДлина(Йцукен) <> СтрДлина(Qwerty) Тогда // Контроль
		ВызватьИсключение "Количество символов в раскладках не совпадает";
	КонецЕсли;
	
	Возврат Раскладки;
	
КонецФункции // РазличныеСимволыРаскладокЙцукенQwerty()

// см. СтрокаИзДругойРаскладки()
//
Функция СтрокаQwertyИзЙцукен(ИсходнаяСтрока) Экспорт
	
	Возврат СтрокаИзДругойРаскладки(ИсходнаяСтрока, "Йцукен", "Qwerty");
	
КонецФункции // СтрокаQwertyИзЙцукен()

// см. СтрокаИзДругойРаскладки()
//
Функция СтрокаЙцукенИзQwerty(ИсходнаяСтрока) Экспорт
	
	Возврат СтрокаИзДругойРаскладки(ИсходнаяСтрока, "Qwerty", "Йцукен");
	
КонецФункции // СтрокаЙцукенИзQwerty()

// Посимвольно преобразует строку из другой раскладки в порядке расположения клавиш клавиатуры другой раскладки.
//
// Параметры:
//  ИсходнаяСтрока			 - Строка
//  ИмяРаскладкиИсточник	 - Строка - см. ИмяРаскладкиНазначение
//	ИмяРаскладкиНазначение	 - Строка:
//		* "Qwerty" - Латиница
//		* "Йцукен" - Кириллица
//
// Возвращаемое значение:
//   Строка   - Преобразованная строка
//
Функция СтрокаИзДругойРаскладки(ИсходнаяСтрока, ИмяРаскладкиИсточник, ИмяРаскладкиНазначение)
	
	Раскладки = РазличныеСимволыРаскладокЙцукенQwerty();
	РаскладкаИсточник = Раскладки[ИмяРаскладкиИсточник];
	РаскладкаНазначение = Раскладки[ИмяРаскладкиНазначение];
	
	Результат = "";
	ЕстьСимволыДругойРаскладки = Ложь;
	Для НомерСимвола = 1 По СтрДлина(ИсходнаяСтрока) Цикл
		
		ТекСимвол = Сред(ИсходнаяСтрока, НомерСимвола, 1);
		
		Если НЕ ЕстьСимволыДругойРаскладки Тогда
			ЕстьСимволыДругойРаскладки = Булево(СтрНайти(РаскладкаИсточник, ТекСимвол));
			Если ЕстьСимволыДругойРаскладки Тогда
				// Построим соответствия раскладок
				СоответствиеСимволов = Новый Соответствие;
				Для НомерСимволаРаскладки = 1 По СтрДлина(РаскладкаИсточник) Цикл
					СимволРаскладкиИсточник = Сред(РаскладкаИсточник, НомерСимволаРаскладки, 1);
					СимволРаскладкиНазначение = Сред(РаскладкаНазначение, НомерСимволаРаскладки, 1);
					СоответствиеСимволов[СимволРаскладкиИсточник] = СимволРаскладкиНазначение;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
		
		Если ЕстьСимволыДругойРаскладки Тогда
			СимволНазначение = СоответствиеСимволов[ТекСимвол];
			Результат = Результат + ?(СимволНазначение <> Неопределено, СимволНазначение, ТекСимвол);
		Иначе
			Результат = Результат + ТекСимвол;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции // СтрокаИзДругойРаскладки()

#КонецОбласти // Транслитерация

#Область Конвертация

// Проверяет имя объекта на соответствия правилам именования встроенного языка.
//
// Параметры:
//	Имя - Строка - Имя объекта: Русские, латинские буквы, цифры и знак подчеркивания.
//
// Возвращаемое значение:
//	Булево - Результат проверки.
//
Функция ИмяОбъектаВалидно(Имя) Экспорт
	
	Если ПустаяСтрока(Имя) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Цифры = "0123456789";
	
	Алфавит = "";
	Алфавит = Алфавит + "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдеёжзийклмнопрстуфхцчшщъыьэюя";
	Алфавит = Алфавит + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
	Алфавит = Алфавит + Цифры;
	Алфавит = Алфавит + "_";
	
	Для НомерСимвола = 1 По СтрДлина(Имя) Цикл
		Символ = Сред(Имя, НомерСимвола, 1);
		Если НЕ СтрНайти(Алфавит, Символ) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	СтрокаНачинаетсяЦифрой = СтрНайти(Цифры, Лев(Имя, 1));
	Если СтрокаНачинаетсяЦифрой Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции // ИмяОбъектаВалидно()

// Преобразует синоним в валидное имя по правилам именования объектов.
//
// Параметры:
//	Синоним			 - Строка - Произвольная строка.
//	ЗаменитьБуквуЁ	 - Булево - Буквы "Ё" и "ё" будут заменены не "Е" и "е", согласно методической рекомендации.
//
// Возвращаемое значение:
//	Строка - Имя по правилам именования.
//
Функция ИмяОбъектаИзСинонима(Синоним, ЗаменитьБуквуЁ = Истина) Экспорт
	
	Строка = СокрЛП(Синоним);

	Если ЗаменитьБуквуЁ Тогда
		Строка = СтрЗаменить(Строка, "Ё", "Е");
		Строка = СтрЗаменить(Строка, "ё", "е");
	КонецЕсли;
	
	Цифры = "0123456789";
	
	Алфавит = "";
	Алфавит = Алфавит + "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдеёжзийклмнопрстуфхцчшщъыьэюя";
	Алфавит = Алфавит + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
	Алфавит = Алфавит + Цифры;
	Алфавит = Алфавит + "_";
	
	НедопустимыеСимволы = "";
	Для НомерСимвола = 1 По СтрДлина(Строка) Цикл
		Символ = Сред(Строка, НомерСимвола, 1);
		Если НЕ СтрНайти(Алфавит, Символ) Тогда
			НедопустимыеСимволы = НедопустимыеСимволы + Символ;
		КонецЕсли;
	КонецЦикла;
	
	СтрокаПоЧастям = СтрРазделить(Строка, НедопустимыеСимволы, Ложь);
	
	Если СтрокаПоЧастям.Количество() = 1 И НедопустимыеСимволы = "" Тогда
		Строка = СтрСоединить(СтрокаПоЧастям);
	Иначе
		Для Индекс = 0 По СтрокаПоЧастям.ВГраница() Цикл
			СтрокаПоЧастям[Индекс] = ТРег(СтрокаПоЧастям[Индекс]);
		КонецЦикла;
		Строка = СтрСоединить(СтрокаПоЧастям);
	КонецЕсли;
	
	СтрокаНачинаетсяЦифрой = СтрНайти(Цифры, Лев(Строка, 1));
	Если СтрокаНачинаетсяЦифрой Тогда
		Строка = "_" + Строка;
	КонецЕсли;
	
	Возврат Строка;
	
КонецФункции // ИмяИзНаименования()

// Преобразует имя объекта в синоним.
// Преобразование такое же, как на уровне платформы.
//
// Параметры:
//	Имя - Строка - Имя в формате именования переменных и объектов
//
// Возвращаемое значение:
//	Строка - Полученный синоним
//
// Пример:
//	СинонимОбъектаИзИмени("_АаАаААааАААаааААААааааААААА_АА_ААА_123_АА") // "Аа аа а ааа АААааа ААААаааа ААААА а а ААА 123 АА"
//
Функция СинонимОбъектаИзИмени(Имя) Экспорт
	
	Синоним = "";
	Цифры = "0123456789";
	Буквы = "";
	Буквы = Буквы + "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдеёжзийклмнопрстуфхцчшщъыьэюя";
	Буквы = Буквы + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
	
	ДлинаСтроки = СтрДлина(Имя);

	// Короткая проверка: Если строка состоит из одного слова с заглавной буквы,
	// без символа подчёркивания и цифр, то оно уже соответствует синониму, 
	// и дальнейшая обработка не требуется:
	ЭтоОдноСлово = (Имя = ТРег(Имя)); 
	Если ЭтоОдноСлово Тогда
		Для НомерСимвола = 1 По ДлинаСтроки Цикл
			Символ = Сред(Имя, НомерСимвола, 1);
			Если Символ = "_"
				Или СтрНайти(Цифры, Символ)
				Или Не СтрНайти(Буквы, Символ) Тогда
				ЭтоОдноСлово = Ложь;			
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Если ЭтоОдноСлово Тогда
		Возврат Имя;
	КонецЕсли;

	Слово = "";
	ЭтоПервоеСлово = Истина;
	ПредСимволЭтоЗаглавная = Ложь;
	ПредСимволЭтоЦифра = Ложь;
	СинонимПоЧастям = Новый Массив;
	СинонимПоЧастям.Добавить();
	
	// Разделители:
	Для НомерСимвола = 1 По ДлинаСтроки Цикл
		
		Символ = Сред(Имя, НомерСимвола, 1);
		СимволЭтоБуква = Булево(СтрНайти(Буквы, Символ));
		СимволЭтоЗаглавная = СимволЭтоБуква И (Символ = ВРег(Символ));
		СимволЭтоЦифра = НЕ СимволЭтоБуква И Булево(СтрНайти(Цифры, Символ));
		
		Если СимволЭтоБуква Тогда
			Если СимволЭтоЗаглавная И НЕ ПредСимволЭтоЗаглавная Тогда
				Слово = Слово + "_";
			КонецЕсли;
			
		ИначеЕсли СимволЭтоЦифра Тогда
			Если НЕ ПредСимволЭтоЦифра Тогда
				Слово = Слово + "_";
			КонецЕсли;
			
		ИначеЕсли Символ = "_" Тогда
			// Ничего
			
		Иначе
			ВызватьИсключение СтрШаблон("Неожиданный символ в позиции %1: %2", НомерСимвола, Символ);
			
		КонецЕсли;
		
		Слово = Слово + Символ;
		
		ПредСимволЭтоЗаглавная = СимволЭтоЗаглавная;
		ПредСимволЭтоЦифра = СимволЭтоЦифра;
		
	КонецЦикла;
	
	СинонимПоЧастям = СтрРазделить(Слово, "_", Истина);
	
	// Регистр и отделение союзов:
	ЭтоПервоеСлово = Истина;
	Для Индекс = 0 По СинонимПоЧастям.ВГраница() Цикл
		
		Слово = СинонимПоЧастям[Индекс];
		ДлинаСлова = СтрДлина(Слово);
		
		// Союзы: ААаа → а ааа.
		ДлинаАббревиатуры = 0;
		Для НомерСимволаСлова = 1 По ДлинаСлова Цикл
			ТекСимвол = Сред(Слово, НомерСимволаСлова, 1);
			Если ТекСимвол = ВРег(ТекСимвол) Тогда;
				ДлинаАббревиатуры = ДлинаАббревиатуры + 1;
			Иначе
				Прервать;
			КонецЕсли;
		КонецЦикла;
		ЭтоЗаглавныеВКонцеСтроки = (ДлинаАббревиатуры = ДлинаСлова И Индекс = СинонимПоЧастям.ВГраница());
		Если ДлинаАббревиатуры = 2 И НЕ ЭтоЗаглавныеВКонцеСтроки Тогда
			ТекСимвол = Лев(Слово, 1);
			СинонимПоЧастям.Вставить(Индекс, ?(ЭтоПервоеСлово, ВРег(ТекСимвол), НРег(ТекСимвол)));
			Индекс = Индекс + 1;
			ДлинаАббревиатуры = ДлинаАббревиатуры - 1;
			Слово = НРег(Сред(Слово, 2));
			СинонимПоЧастям[Индекс] = Слово;
			ЭтоПервоеСлово = Ложь;
			Продолжить;
		КонецЕсли;
		
		Если НЕ ПустаяСтрока(Слово) Тогда
			СохранитьРегистр = (ДлинаАббревиатуры > 2) ИЛИ ЭтоЗаглавныеВКонцеСтроки;
			Если НЕ СохранитьРегистр Тогда
				Слово = ?(ЭтоПервоеСлово, ТРег(Слово), НРег(Слово));
			КонецЕсли;
			СинонимПоЧастям[Индекс] = Слово;
			ЭтоПервоеСлово = Ложь;
		КонецЕсли;
		
	КонецЦикла;
	
	Для ОбратныйИндекс = -СинонимПоЧастям.ВГраница() По 0 Цикл
		Индекс = -ОбратныйИндекс;
		Если ПустаяСтрока(СинонимПоЧастям[Индекс]) Тогда
			СинонимПоЧастям.Удалить(Индекс);
		КонецЕсли;
	КонецЦикла;
	
	Синоним = СтрСоединить(СинонимПоЧастям, " ");
	
	Возврат Синоним;
	
КонецФункции // СинонимОбъектаИзИмени()

#КонецОбласти // Конвертация

#Область Спецсимволы

// Убирает экранирование спецсимволов косой чертой.
//
// Параметры:
//	Строка				- Строка - Строка, в которой нужно убрать экранирование спецсимволов.
//	Спецсимволы			- Строка - Строка, содержащая спецсимволы, которые нужно убрать из экранирования.
//	СимволЭкранирования - Строка - Символ экранирования, по умолчанию "\".
//
// Возвращаемое значение:
//	Строка
//
Функция УбратьЭкранированиеСпецсимволов(Знач Строка, Спецсимволы, СимволЭкранирования = "\") Экспорт

	КоличествоСимволов = СтрДлина(Спецсимволы);
	СимволыДляЭкранирования = Новый Массив(КоличествоСимволов);
	Для Индекс = 0 По КоличествоСимволов - 1 Цикл
		СимволыДляЭкранирования[Индекс] = Сред(Спецсимволы, Индекс + 1, 1);
	КонецЦикла;

	Результат = "";
	ДлинаСтроки = СтрДлина(Строка);
	Для НомерСимвола = 1 По ДлинаСтроки Цикл
		Символ = Сред(Строка, НомерСимвола, 1);
		Если Символ = СимволЭкранирования 
			И НомерСимвола < ДлинаСтроки  Тогда
			СледующийСимвол = Сред(Строка, НомерСимвола + 1, 1);
			Если СимволыДляЭкранирования.Найти(СледующийСимвол) <> Неопределено Тогда
				НомерСимвола = НомерСимвола + 1; // Пропускаем символ экранирования
				Символ = СледующийСимвол;
			КонецЕсли;
		КонецЕсли;
		Результат = Результат + Символ; // Добавляем символ в результат
	КонецЦикла;

	Возврат Результат;

КонецФункции // УбратьЭкранированиеСпецсимволов()

// Экранирует спецсимволы в строке, добавляя перед ними символ экранирования "\".
//
// Параметры:
//	Строка				- Строка - Строка, в которой нужно экранировать спецсимволы.
//	Спецсимволы			- Строка - Строка, содержащая спецсимволы, которые нужно экранировать.
//	СимволЭкранирования - Строка - Символ экранирования, по умолчанию "\".
//
// Возвращаемое значение:
//	Строка
//
Функция ЭкранироватьСпецсимволы(Знач Строка, Спецсимволы, СимволЭкранирования = "\") Экспорт

	КоличествоСимволов = СтрДлина(Спецсимволы);
	СимволыДляЭкранирования = Новый Массив(КоличествоСимволов);
	Для Индекс = 0 По КоличествоСимволов - 1 Цикл
		СимволыДляЭкранирования[Индекс] = Сред(Спецсимволы, Индекс + 1, 1);
	КонецЦикла;

	ДлинаКонструкцииПеременной = СтрДлина("{_}"); // Длина конструкции ${VAR}

	Результат = "";
	Для НомерСимвола = 1 По СтрДлина(Строка) Цикл
		Символ = Сред(Строка, НомерСимвола, 1);
		Экранировать = СимволыДляЭкранирования.Найти(Символ) <> Неопределено;
		Если Экранировать Тогда
			// Не экранируются символы "$", если они являются частью конструкции ${VAR}:
			Если Символ = "$" И (СтрДлина(Строка) - НомерСимвола >= ДлинаКонструкцииПеременной) Тогда
				НачалоКонструкции = СтрНайти(Строка, "{", НомерСимвола + 1);
				КонецКонструкции = СтрНайти(Строка, "}", НачалоКонструкции + 1);
				Если НачалоКонструкции = НомерСимвола + 1 И НачалоКонструкции < КонецКонструкции Тогда
					ИмяПеременной = Сред(Строка, НачалоКонструкции + 1, КонецКонструкции - 1);
					Если ИмяОбъектаВалидно(ИмяПеременной) Тогда
						Экранировать = Ложь;
					КонецЕсли;				
				КонецЕсли;
				Если Не Экранировать Тогда
					ДлинаКонструкции = КонецКонструкции - НомерСимвола + 1; // Длина конструкции ${VAR}
					КонструкцияЦеликом = Сред(Строка, НомерСимвола, ДлинаКонструкции);
					Результат = Результат + КонструкцияЦеликом; // Добавляем конструкцию целиком
					НомерСимвола = КонецКонструкции; // Пропускаем символы конструкции
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Результат = Результат + ?(Экранировать, СимволЭкранирования, "") + Символ; // Экранируем спецсимволы
	КонецЦикла;

	Возврат Результат;	

КонецФункции // ЭкранироватьСпецсимволы()

#КонецОбласти // Спецсимволы

// Заменяет табуляцию в строке пробелами с сохранением разметки.
//
// Параметры:
//  Текст			 - Строка 	 - Исходный текст.
//  ШиринаТабуляции	 - Число	 - Ширина табуляции. Должна быть больше нуля
//
// Возвращаемое значение:
//  Строка - Результирующий текст.
//
Функция ЗаменитьТабуляциюПробелами(Текст, Знач ШиринаТабуляции = 4) Экспорт
	
	ШиринаТабуляции = Цел(ШиринаТабуляции);
	Если ШиринаТабуляции <= 0 Тогда
		ВызватьИсключение "Ширина табуляции должна быть больше нуля.";
	КонецЕсли;
	
	ТабПробелами = "";
	Для НомерСимвола = 1 По ШиринаТабуляции Цикл
		ТабПробелами = ТабПробелами + " ";
	КонецЦикла;
	
	ЧислоСтрок = СтрЧислоСтрок(Текст);
	СоставРезультата = Новый Массив(ЧислоСтрок);
	Для НомерСтроки = 1 По ЧислоСтрок Цикл
		ТекущаяСтрока = СтрПолучитьСтроку(Текст, НомерСтроки);
		ПозицияТабуляции = СтрНайти(ТекущаяСтрока, Символы.Таб);
		Пока ПозицияТабуляции > 0 Цикл
			ЧислоПробелов = ШиринаТабуляции - (ПозицияТабуляции - 1) % ШиринаТабуляции;
			ТекущаяСтрока = Лев(ТекущаяСтрока, ПозицияТабуляции - 1)
				+ Лев(ТабПробелами, ЧислоПробелов)
				+ Сред(ТекущаяСтрока, ПозицияТабуляции + 1);
			ПозицияТабуляции = СтрНайти(ТекущаяСтрока, Символы.Таб, , ПозицияТабуляции);
		КонецЦикла;
		СоставРезультата[НомерСтроки - 1] = ТекущаяСтрока;
	КонецЦикла;
	ТекстРезультат = СтрСоединить(СоставРезультата, Символы.ПС);
	
	Возврат ТекстРезультат;
	
КонецФункции // ЗаменитьТабуляциюПробелами()

// Заменяет пробелы табуляцией с сохранением отступов.
//
// Параметры:
//  Текст			 - Строка 	 - Исходный текст.
//  ШиринаТабуляции	 - Число	 - Ширина табуляции. Должна быть больше нуля.
//
// Возвращаемое значение:
//  Строка - Результирующий текст.
//
Функция ЗаменитьПробелыТабуляцией(Текст, Знач ШиринаТабуляции = 4) Экспорт
	
	ШиринаТабуляции = Цел(ШиринаТабуляции);
	Если ШиринаТабуляции <= 0 Тогда
		ВызватьИсключение "Ширина табуляции должна быть больше нуля.";
	КонецЕсли;
	
	Пробел = " ";
	ШаблоныПробелов = Новый Массив(ШиринаТабуляции + 1);
	ШаблоныПробелов[0] = "";
	Для Индекс = 1 По ШиринаТабуляции Цикл
		ШаблоныПробелов[Индекс] = ШаблоныПробелов[Индекс - 1] + Пробел;
	КонецЦикла;
	
	ЧислоСтрок = СтрЧислоСтрок(Текст);
	СоставРезультата = Новый Массив(ЧислоСтрок);
	Для НомерСтроки = 1 По ЧислоСтрок Цикл
		ТекущаяСтрока = СтрПолучитьСтроку(Текст, НомерСтроки);
		Если ТекущаяСтрока = "" Тогда
			Продолжить;
		КонецЕсли;
		КоличествоФрагментов = СтрДлина(ТекущаяСтрока) / ШиринаТабуляции;
		КоличествоФрагментов = ?(КоличествоФрагментов = Цел(КоличествоФрагментов), КоличествоФрагментов, Цел(КоличествоФрагментов) + 1); // Округление вверх.
		СоставСтроки = Новый Массив(КоличествоФрагментов);
		Для ИндексФрагмента = 0 По КоличествоФрагментов - 1 Цикл
			НачалоФрагмента = ШиринаТабуляции * ИндексФрагмента + 1;
			Фрагмент = Сред(ТекущаяСтрока, НачалоФрагмента, ШиринаТабуляции);
			Для МинусЧислоПробелов = -ШиринаТабуляции По - 2 Цикл
				ЧислоПробелов = -МинусЧислоПробелов;
				Пробелы = ШаблоныПробелов[ЧислоПробелов];
				Фрагмент = СтрЗаменить(Фрагмент, Пробелы, Символы.Таб);
			КонецЦикла;
			Если СтрЗаканчиваетсяНа(Фрагмент, " ") И Сред(ТекущаяСтрока, НачалоФрагмента + ШиринаТабуляции, 1) = Пробел Тогда
				Фрагмент = Лев(Фрагмент, СтрДлина(Фрагмент) - 1) + Пробел;
			КонецЕсли;
			СоставСтроки[ИндексФрагмента] = Фрагмент;
		КонецЦикла;
		СоставРезультата[НомерСтроки - 1] = СтрСоединить(СоставСтроки);
	КонецЦикла;
	ТекстРезультат = СтрСоединить(СоставРезультата, Символы.ПС);
	
	Возврат ТекстРезультат;
	
КонецФункции // ЗаменитьПробелыТабуляцией()

// Символы, которые 1С считает незначащими.
// см. СокрЛП()
//
// Возвращаемое значение:
//	Массив из Строка
//
Функция НезначащиеСимволы() Экспорт
	
	НезначащиеСимволы = Новый Массив;
	НезначащиеСимволы.Добавить(" ");
	НезначащиеСимволы.Добавить(Символы.НПП);
	НезначащиеСимволы.Добавить(Символы.Таб);
	НезначащиеСимволы.Добавить(Символы.ВТаб);
	НезначащиеСимволы.Добавить(Символы.ВК);
	НезначащиеСимволы.Добавить(Символы.ПС);
	НезначащиеСимволы.Добавить(Символы.ПФ);
	
	Возврат НезначащиеСимволы;
	
КонецФункции // НезначащиеСимволы()

// Производит поиск слова целиком.
// Работает для русского и английского алфавитов.
// Границей слова считается любой символ, кроме русских и английских букв,
// цифр и знака подчёркивания.
//
// Параметры:
//	Строка			 - Строка			 - Исходная строка.
//	ПодстрокаПоиска	 - Строка			 - Искомая подстрока.
//	Направление		 - НаправлениеПоиска - Указывает направление поиска подстроки в строке.
//	НачальнаяПозиция - Число			 - Указывает позицию в строке, с которой начинается поиск. См. СтрНайти().
//	НомерВхождения	 - Число			 - Указывает номер вхождения искомой подстроки в исходной строке.
//
// Возвращаемое значение:
//	Число - Позиция первого знака найденной подстроки.
//			Нумерация символов в строке начинается с 1.
//			Если строка не содержит указанной подстроки, то возвращается 0.
//
Функция СтрНайтиЦеликом(
		Строка,
		ПодстрокаПоиска,
		Знач Направление = Неопределено,
		НачальнаяПозиция = Неопределено,
		НомерВхождения = 1) Экспорт
	
	Если Направление = Неопределено Тогда
		Направление = НаправлениеПоиска.СНачала;
	КонецЕсли;
	Если ТипЗнч(Направление) <> Тип("НаправлениеПоиска") Тогда
		ВызватьИсключение "Параметр Направление: Ожидается тип НаправлениеПоиска";
	КонецЕсли;
	
	Если НачальнаяПозиция = Неопределено Тогда
		НачальнаяПозиция = ?(Направление = НаправлениеПоиска.СНачала, 1, СтрДлина(Строка));
	КонецЕсли;
	Если НачальнаяПозиция = Неопределено Тогда
		ВызватьИсключение "Параметр Направление: Ожидается тип Число";
	КонецЕсли;
	
	Алфавит = "";
	Алфавит = Алфавит + "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдеёжзийклмнопрстуфхцчшщъыьэюя";
	Алфавит = Алфавит + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
	Алфавит = Алфавит + "0123456789_";
	
	ДлинаИсходнойСтроки = СтрДлина(Строка);
	ДлинаПодстрокиПоиска = СтрДлина(ПодстрокаПоиска);
	ТекущаяНачальнаяПозиция = НачальнаяПозиция;
	ТекущийНомерВхождения = 0;
	КоэффициентНаправления = ?(Направление = НаправлениеПоиска.СНачала, 1, -1);
	Пока ТекущийНомерВхождения < НомерВхождения Цикл
		
		ПозицияРезультата = СтрНайти(Строка, ПодстрокаПоиска, Направление, ТекущаяНачальнаяПозиция);
		Если ПозицияРезультата = 0 Тогда
			Возврат 0;
		КонецЕсли;
		
		ЕстьГраницаСлева = (ПозицияРезультата = 1)
			ИЛИ НЕ СтрНайти(Алфавит, Сред(Строка, ПозицияРезультата - 1, 1));
		ЕстьГраницаСправа = ((ПозицияРезультата + ДлинаПодстрокиПоиска) = ДлинаИсходнойСтроки)
			ИЛИ НЕ СтрНайти(Алфавит, Сред(Строка, ПозицияРезультата + ДлинаПодстрокиПоиска, 1));
		ЭтоСлово = ЕстьГраницаСлева И ЕстьГраницаСправа;
		
		Если ЭтоСлово Тогда
			ТекущийНомерВхождения = ТекущийНомерВхождения + 1;
			Если ТекущийНомерВхождения = НомерВхождения Тогда
				Возврат ПозицияРезультата;
			КонецЕсли;
		КонецЕсли;
		
		ТекущаяНачальнаяПозиция = ПозицияРезультата + ДлинаПодстрокиПоиска * КоэффициентНаправления;
		
	КонецЦикла;
	
	Возврат 0;
	
КонецФункции // СтрНайтиЦеликом

// Проверяет букву на принадлежность к буквам русского алфавита
//
// Параметры:
//   Символ - Строка - Проверяемая буква
//
//  Возвращаемое значение:
//   Булево - Истина, если это буква кириллицы.
//
Функция ЭтоБукваКириллицы(Символ) Экспорт
	
	Если СтрДлина(Символ) <> 1 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	КодСимвола = КодСимвола(Символ);
	
	Возврат КодСимвола("а") <= КодСимвола И КодСимвола <= КодСимвола("я")
	ИЛИ КодСимвола("А") <= КодСимвола И КодСимвола <= КодСимвола("Я")
	ИЛИ Символ = "Ё" ИЛИ Символ = "ё";
	
КонецФункции // ЭтоБукваКириллицы()

// Проверяет букву на принадлежность к буквам английского алфавита
//
// Параметры:
//   Символ - Строка - Проверяемая буква
//
//  Возвращаемое значение:
//   Булево - Истина, если это буква латиницы.
//
Функция ЭтоБукваЛатиницы(Символ) Экспорт
	
	Если СтрДлина(Символ) <> 1 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	КодСимвола = КодСимвола(Символ);
	
	Возврат КодСимвола("a") <= КодСимвола И КодСимвола <= КодСимвола("z")
	ИЛИ КодСимвола("A") <= КодСимвола И КодСимвола <= КодСимвола("Z");
	
КонецФункции // ЭтоБукваЛатиницы()


// Проверяет, является ли переданное значение ссылкой
//
// Параметры:
//  Значение - Произвольный	 - Проверяемое значение
//
// Возвращаемое значение:
//  Булево
//
Функция ЭтоСсылка(Значение) Экспорт
	
	Если ЭтоПримитивныйТип(Значение)
		ИЛИ ТипЗнч(Значение) = Тип("УникальныйИдентификатор") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	СтрокаXML = XMLСтрока(Значение);
	Если ЭтоУникальныйИдентификатор(СтрокаXML) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции // ЭтоСсылка()


// Проверяет, имеет ли строка формат Base64
// см. RFC 2045 (https://datatracker.ietf.org/doc/html/rfc2045)
//
// Параметры:
//  Строка - Строка - Проверяемая строка
//
// Возвращаемое значение:
//   Булево   - Если это Base64, возвращается Истина.
//
Функция ЭтоСтрокаBase64(Строка) Экспорт
	
	Если ТипЗнч(Строка) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;

	ДлинаСтроки = СтрДлина(Строка);
	Если ДлинаСтроки % 4 Тогда	// Длина строки должна быть кратная 4.
		Возврат Ложь;
	КонецЕсли;
	
	Разряды = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" + Символы.ПС;
	
	Для НомерСимвола = 1 По ДлинаСтроки Цикл
		Символ = Сред(Строка, НомерСимвола, 1);
		Если СтрНайти(Разряды, Символ) Тогда
			Продолжить;
		КонецЕсли;
		Если Символ = "=" Тогда
			Если НомерСимвола = ДлинаСтроки Тогда	// Равно в последней позиции.
				Прервать;
			КонецЕсли;
			Если НомерСимвола = ДлинаСтроки - 1				
				И Сред(Строка, ДлинаСтроки, 1) = "=" Тогда	// Два равно в конце.
				Прервать;
			КонецЕсли;
		КонецЕсли;
		Возврат Ложь;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции // ЭтоСтрокаBase64()

// Проверяет, является ли строка уникальным идентификатором
//  вида "123e4567-e89b-12d3-a456-426655440000"
//
// Параметры:
//  Строка				 - Строка	 - Проверяемая строка
//  ДопускатьСкобки		 - Булево	 - Идентификатор может быть обрамлён в (круглые) или {фигурные} скобки
//  ДопускатьПрефикс	 - Булево	 - Идентификатор может начинаться префиксом 0x.
//
// Возвращаемое значение:
//  Булево
//
Функция ЭтоУникальныйИдентификатор(Строка, ДопускатьСкобки = Ложь, ДопускатьПрефикс = Ложь) Экспорт
	
	Если ПустаяСтрока(Строка) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Представление = Строка;
	
	//		  123e4567-e89b-12d3-a456-426655440000
	Шаблон = "00000000-0000-0000-0000-000000000000";
	
	Если СтрДлина(Представление) <> СтрДлина(Шаблон)
		И СтрДлина(Представление) <> (СтрДлина(Шаблон) + ?(ДопускатьСкобки, 2, 0)) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ДопускатьСкобки Тогда
		ПарыСкобок = Новый Соответствие;
		ПарыСкобок["("] = ")";
		ПарыСкобок["{"] = "}";
		СкобкиУдалены = Ложь;
		Для Каждого ПараСкобок Из ПарыСкобок Цикл
			Если СтрНачинаетсяС(Представление, ПараСкобок.Ключ)
				И СтрЗаканчиваетсяНа(Представление, ПараСкобок.Значение) Тогда
				Если СкобкиУдалены Тогда // Вторая пара скобок - это ошибка.
					Возврат Ложь;
				КонецЕсли;
				Представление = Сред(Представление, 2, СтрДлина(Представление) - 2);
				СкобкиУдалены = Истина;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Алфавит = "0123456789abcdef";
	Дефис = "-";
	СловарьШаблона = Новый Соответствие;
	Для НомерСимвола = 1 По СтрДлина(Алфавит) Цикл
		СловарьШаблона[Сред(Алфавит, НомерСимвола, 1)] = "0";
	КонецЦикла;
	СловарьШаблона["-"] = "-";
	Для НомерСимвола = 1 По СтрДлина(Шаблон) Цикл
		ТекущийСимвол = Сред(Представление, НомерСимвола, 1);
		СимволШаблона = Сред(Шаблон, НомерСимвола, 1);
		Если СловарьШаблона[ТекущийСимвол] <> СловарьШаблона[СимволШаблона] Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции // ЭтоУникальныйИдентификатор()

// Подставляет параметры в строку.
//
// Параметры:
//  Шаблон				 - Строка		 - Строка, содержащая параметры.
//  Параметры			 - Структура	 - Параметры для подстановки. Регистр ключей не важен.
//  ЛевыйОграничитель	 - Строка		 - Символы, предваряющие параметр в строке-шаблоне.
//  ПравыйОграничитель	 - Строка		 - Символы, завершающие параметр в строке-шаблоне.
// 
// Возвращаемое значение:
//  Строка - Результат подстановки параметров.
//
Функция ПодставитьПараметрыВСтроку(
	Знач Шаблон, 
	Знач Параметры, 
	Знач ЛевыйОграничитель = "[", 
	Знач ПравыйОграничитель = "]") Экспорт
	
	Если Не ЗначениеЗаполнено(Шаблон) Или Не ЗначениеЗаполнено(Параметры) Тогда
		Возврат Шаблон;
	КонецЕсли;

	ШаблонНРег = НРег(Шаблон);
	
	НомераВхожденийПараметров = Новый Массив;
	ЗначенияПараметровНРег = Новый Соответствие;
	Для Каждого Параметр Из Параметры Цикл 
		КлючПараметраНРег = ЛевыйОграничитель + НРег(Параметр.Ключ) + ПравыйОграничитель;  
		ЗначенияПараметровНРег[КлючПараметраНРег] = Строка(Параметр.Значение);
		НачальнаяПозиция = 1;
		Пока Истина Цикл
			ПозицияПараметра = СтрНайти(ШаблонНРег, КлючПараметраНРег, , НачальнаяПозиция);
			Если ПозицияПараметра > 0 Тогда
				НомераВхожденийПараметров.Добавить(ПозицияПараметра);
				НачальнаяПозиция = ПозицияПараметра + 1;
			Иначе
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;     
	
	СоставСтроки = РазделитьСтрокуПоНомерамСимволов(Шаблон, НомераВхожденийПараметров);
	Для Индекс = 0 По СоставСтроки.ВГраница() Цикл
		ЧастьСтрокиНРег = НРег(СоставСтроки[Индекс]);
		ЗначениеПараметра = ЗначенияПараметровНРег[ЧастьСтрокиНРег];	// Если часть строки - это параметр, то тут будет его значение.
		Если ЗначениеПараметра <> Неопределено Тогда
			СоставСтроки[Индекс] = ЗначениеПараметра;
		КонецЕсли;
	КонецЦикла;
	
	СтрокаРезультат = СтрСоединить(СоставСтроки);

	Возврат СтрокаРезультат;    
	
КонецФункции    

// Разделяет строку по номерам
//
// Параметры:
//  Строка			 - Строка			 - Исходная
//  НомераСимволов	 - Массив из Число	 - Номера символов, по которым будет разделена строка.
//										Номера трактуются в порядке возрастания.
//										Номер символа не может быть меньше единицы и больше длины строки.
//										
// Возвращаемое значение:
//  Массив из Строка - Части строки.
//
// Пример:                                                   
//	НомераСимволов = Новый Массив; 
//	НомераСимволов.Добавить(3);
//	НомераСимволов.Добавить(5);
//	РазделитьСтрокуПоНомерамСимволов("абвгде", НомераСимволов); // {"аб", "вг", "де"}
//
Функция РазделитьСтрокуПоНомерамСимволов(Строка, Знач НомераСимволов) Экспорт
	
	Если Не ЗначениеЗаполнено(НомераСимволов) Тогда
		Возврат Строка;
	КонецЕсли;
	
	// Номера трактуются в порядке возрастания:
	СписокСортировки = Новый СписокЗначений;
	СписокСортировки.ЗагрузитьЗначения(НомераСимволов);
	СписокСортировки.СортироватьПоЗначению(НаправлениеСортировки.Возр);
	НомераСимволов = СписокСортировки.ВыгрузитьЗначения();    
	
	Если НомераСимволов[0] < 1 Тогда
		ВызватьИсключение "Номер символа не может быть меньше единицы.";	
	КонецЕсли;

	ДлинаСтроки = СтрДлина(Строка);
	
	Если НомераСимволов[НомераСимволов.ВГраница()] > ДлинаСтроки Тогда
		ВызватьИсключение "Номер символа не может быть больше длины строки.";	
	КонецЕсли;                                                            
	
	Строки = Новый Массив;

	МаксИндексНомера = НомераСимволов.ВГраница();
	ПредыдущийНомер = 1;
	Для ИндексНомера = 0 По МаксИндексНомера Цикл
		
		Номер = 	НомераСимволов[ИндексНомера];
		ЧастьСтроки = Сред(Строка, ПредыдущийНомер, Номер - ПредыдущийНомер);
		Строки.Добавить(ЧастьСтроки);

		Если ИндексНомера = МаксИндексНомера Тогда
			Строки.Добавить(Сред(Строка, Номер));
		КонецЕсли;

		ПредыдущийНомер = Номер;
	
	КонецЦикла;

	Возврат Строки;

КонецФункции // РазделитьСтрокуПоНомерамСимволов()

// Разбивает каждую подстроку указанной строки так, то её длина вписывается в указанный лимит.
//
// Параметры:
//	ИсходнаяСтрока			 - Строка
//	МаксимальнаяДлинаСтроки	 - Число  
//
// ВозвращаемоеЗначение:
//	Строка - Строка, разбитая через Символы.ПС.
//		Исходная строка может быть собрана обратно через СтрЗаменить(Символы.ПС, "").
//
Функция ФорматироватьТекстПоМаксимальнойДлинеСтрок(ИсходнаяСтрока, МаксимальнаяДлинаСтроки) Экспорт

	СтрокаРезультат = "";  
	
	Абзацы = СтрРазделить(ИсходнаяСтрока, Символы.ПС, Истина);  
	
	РегулярноеВыражение = "(^\s+)?(\b\w+\b)*([^\w\s]*)(\s+)?";
	// Слова целиком, с заканчивающими их знаками препинания и пробелами.
	// (^\s+)?		 - Отступ с начала строки;
	// (\b\w+\b)*	 - Слово;
	// ([^\w\s]*)	 - Знаки препинания после слова;
	// (\s+)?		 - Отступы после слова  
	
	Для Индекс = 0 По Абзацы.ВГраница() Цикл  
		
		Абзац = Абзацы[Индекс];
		Если СтрДлина(Абзац) <= МаксимальнаяДлинаСтроки Тогда
			Продолжить;
		КонецЕсли;	                        
		
		Совпадения = СтрНайтиВсеПоРегулярномуВыражению(Абзац, РегулярноеВыражение, Истина, Ложь);
		Слова = Новый Массив;
		Для каждого Совпадение Из Совпадения Цикл
			
			Слово = Совпадение.Значение;
			Если СтрДлина(Слово) > МаксимальнаяДлинаСтроки Тогда 
				ДлинаСловаБезПоследующихПробелов = СтрДлина(СокрП(Слово));
				Если ДлинаСловаБезПоследующихПробелов <= МаксимальнаяДлинаСтроки Тогда
					// Для случаев, если от слова можно отрезать последующие пробелы. 
					Слова.Добавить(Лев(Слово, ДлинаСловаБезПоследующихПробелов));
					Слова.Добавить(Сред(Слово, ДлинаСловаБезПоследующихПробелов + 1));
				Иначе
					ВызватьИсключение СтрШаблон("Длина слова с последующими отступами превышает %1 симв.:
					|«%2»",
					МаксимальнаяДлинаСтроки,
					Слово);			
				КонецЕсли;
			Иначе
				Слова.Добавить(Слово);
			КонецЕсли;
			
		КонецЦикла;  
		
		СтрокиАбзаца = Новый Массив;
		СтрокаАбзаца = "";
		Для каждого Слово Из Слова Цикл
			Если СтрДлина(СтрокаАбзаца) + СтрДлина(Слово) <= МаксимальнаяДлинаСтроки Тогда
				СтрокаАбзаца = СтрокаАбзаца + Слово;
			Иначе
				СтрокиАбзаца.Добавить(СтрокаАбзаца);
				СтрокаАбзаца = Слово;
			КонецЕсли;		   
		КонецЦикла;            
		СтрокиАбзаца.Добавить(СтрокаАбзаца);
		Абзацы[Индекс] = СтрСоединить(СтрокиАбзаца, Символы.ПС);
		
	КонецЦикла; 
	
	СтрокаРезультат = СтрСоединить(Абзацы, Символы.ПС);
	Возврат СтрокаРезультат;

КонецФункции // ФорматироватьТекстПоМаксимальнойДлинеСтрок()

#КонецОбласти // Строки

#Область Ссылки

// Извлекает представление объекта, номер, дату из представления документа.
// Поддерживаемые форматы:
//	- Имя документа АБВГ-123456 от 01.02.2003 04:05:06
//
// Параметры:
//	ПредставлениеДокумента - Строка - Представление документа.
//
// Возвращаемое значение:
//	Структура - Элементы:
//		* Наименование	 - Строка	 - Представление вида документа.
//		* Номер			 - Строка	 - Номер документа
//		* Дата			 - Дата		 - Дата документа
//	
Функция СоставПредставленияДокумента(Знач ПредставлениеДокумента) Экспорт

	МаркерОт = " от ";                                    
	ПозицияОт = СтрНайти(ПредставлениеДокумента, МаркерОт);
	Если ПозицияОт = 0 Тогда
		ВызватьИсключение "Неверный формат представления документа";
	КонецЕсли;

	ПробелПередНомером = СтрНайти(ПредставлениеДокумента, " ", НаправлениеПоиска.СКонца, ПозицияОт - 1);

	Наименование = Лев(ПредставлениеДокумента, ПробелПередНомером - 1);

	ПозицияНомер = ПробелПередНомером + 1;
	Номер = Сред(ПредставлениеДокумента, ПозицияНомер, ПозицияОт - ПробелПередНомером - 1);
	
	ПробелПередДатой = СтрНайти(ПредставлениеДокумента, " ", НаправлениеПоиска.СКонца, , 2);
	ДатаСтрокой = Сред(ПредставлениеДокумента, ПробелПередДатой + 1);

	СоставДаты = СтрРазделить(ДатаСтрокой, " .:", Ложь);
	Если СоставДаты.Количество() <> 6 Тогда
		ВызватьИсключение "Неожиданный формат даты";
	КонецЕсли;

	// Платформа умеет извлекать дату из канонического представления, но это не документировано.
	// Поэтому извлекаем дату по-подробному:
	День	 = Число(СоставДаты[0]);
	Месяц	 = Число(СоставДаты[1]);
	Год		 = Число(СоставДаты[2]);
	Час		 = Число(СоставДаты[3]);
	Минута	 = Число(СоставДаты[4]);
	Секунда	 = Число(СоставДаты[5]);
	Дата = Дата(Год, Месяц, День, Час, Минута, Секунда);  
	
	СоставПредставления = Новый Структура;
	СоставПредставления.Вставить("Наименование", Наименование);
	СоставПредставления.Вставить("Номер", 		 Номер);
	СоставПредставления.Вставить("Дата",		 Дата);

	Возврат СоставПредставления;

КонецФункции // СоставПредставленияДокумента()

#КонецОбласти // Ссылки

#Область УникальныйИдентификатор

// Получает пустой уникальный идентификатор.
//
// Возвращаемое значение:
//  УникальныйИдентификатор
//
Функция ПустойУникальныйИдентификатор() Экспорт
	
	Возврат Новый УникальныйИдентификатор("00000000-0000-0000-0000-000000000000");
	
КонецФункции

// Преобразует уникальный идентификатор в шестнадцатеричное число,
//	которое используется в навигационных ссылках
//
// Параметры:
//  УникальныйИдентификатор	 - УникальныйИдентификатор, Строка	 - Преобразуемый идентификатор
//  ДобавитьПрефикс			 - Булево							 - Если Истина - к числу будет добавлен префикс "0x"
//
// Возвращаемое значение:
//   - Строка   - Сформированное строковое представление числа,
//					Если формат идентификатора не верен, возвращается Неопределено.
//
Функция УникальныйИдентификаторВШестнадцатеричноеЧисло(Знач УникальныйИдентификатор, ДобавитьПрефикс = Истина)
	
	// Входящее:	00112233-4455-6677-8899-aabbccddeeff
	// Ожидается:	[0x]8899aabbccddeeff6677445500112233
	
	СоставныеЧасти = СтрРазделить(Строка(УникальныйИдентификатор), "-", Ложь);
	КоличествоЧастейУида = 5;
	Если СоставныеЧасти.Количество() <> КоличествоЧастейУида Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ШестнадцатеричноеЧисло =
		?(ДобавитьПрефикс, "0x", "")
		+ СоставныеЧасти[3] // 8899
		+ СоставныеЧасти[4] // aabbccddeeff
		+ СоставныеЧасти[2] // 6677
		+ СоставныеЧасти[1] // 4455
		+ СоставныеЧасти[0]; // 00112233
	
	Возврат ШестнадцатеричноеЧисло;
	
КонецФункции // УникальныйИдентификаторВШестнадцатеричноеЧисло()

// Формирует уникальный идентификатор из шестнадцатеричного числа
//
// Параметры:
//  ШестнадцатеричноеЧисло	 - Строка	 - Шестнадцатеричное число. Может предваряться префиксом "0x"
//
// Возвращаемое значение:
//  УникальныйИдентификатор - Сформированный уникальный идентификатор
//
Функция УникальныйИдентификаторИзШестнадцатеричногоЧисла(Знач ШестнадцатеричноеЧисло)
	
	// Входящее:	[0x]8899aabbccddeeff6677445500112233
	// Ожидается:	00112233-4455-6677-8899-aabbccddeeff
	
	ШестнадцатеричноеЧислоБезПрефикса = СтрЗаменить(ШестнадцатеричноеЧисло, "0x", "");
	Если СтрДлина(ШестнадцатеричноеЧислоБезПрефикса) <> 32 Тогда Возврат Неопределено КонецЕсли;
	
	// Разметка:        1   5           17  21  25
	// Входящее:	[0x]8899aabbccddeeff6677445500112233
	УникальныйИдентификаторСтрокой = СтрШаблон(
			"%5-%4-%3-%1-%2",
			Сред(ШестнадцатеричноеЧислоБезПрефикса, 1, 4), // 8899
			Сред(ШестнадцатеричноеЧислоБезПрефикса, 5, 12), // aabbccddeeff
			Сред(ШестнадцатеричноеЧислоБезПрефикса, 17, 4), // 6677
			Сред(ШестнадцатеричноеЧислоБезПрефикса, 21, 4), // 4455
			Сред(ШестнадцатеричноеЧислоБезПрефикса, 25, 8) // 00112233
		);
	
	Возврат Новый УникальныйИдентификатор(УникальныйИдентификаторСтрокой);
	
КонецФункции // УникальныйИдентификаторИзШестнадцатеричногоЧисла()

#КонецОбласти // УникальныйИдентификатор

#Область Цвет

// Получает цвета палитры цветов диаграммы.
//
// Параметры:
//  ПалитраЦветов						 - ПалитраЦветовДиаграммы
//										 - Диаграмма - Для получения палитры цветов из существующей диаграммы.
//  КоличествоЦветовГрадиентнойПалитры	 - Число	 - см. ОписаниеПалитрыЦветовДиаграммы. Обязательно для градиентов.
//  ЦветНачалаГрадиентнойПалитры		 - Цвет		 - см. ОписаниеПалитрыЦветовДиаграммы
//  ЦветКонцаГрадиентнойПалитры			 - Цвет		 - см. ОписаниеПалитрыЦветовДиаграммы
// 
// Возвращаемое значение:
//  Массив - из Цвет - см. ВыриантыПалитрыЦветовДиаграммы().
//
Функция ЦветаПалитрыЦветовДиаграммы(
	ПалитраЦветов = "Авто",
	КоличествоЦветовГрадиентнойПалитры = Неопределено,
	ЦветНачалаГрадиентнойПалитры = Неопределено,
	ЦветКонцаГрадиентнойПалитры = Неопределено) 
	
	Если ТипЗнч(ПалитраЦветов) = Тип("Диаграмма") Тогда
		Диаграмма = ПалитраЦветов;
		ОписаниеПалитры = Диаграмма.ОписаниеПалитрыЦветов;
		ЦветаПалитры = ЦветаПалитрыЦветовДиаграммы(
			ОписаниеПалитры.ПалитраЦветов,
			?(ОписаниеПалитры.МаксимальноеКоличествоЦветовГрадиентнойПалитры > 0, 
				ОписаниеПалитры.МаксимальноеКоличествоЦветовГрадиентнойПалитры,
				Диаграмма.Серии.Количество()),
			ОписаниеПалитры.ЦветНачалаГрадиентнойПалитры,
			ОписаниеПалитры.ЦветКонцаГрадиентнойПалитры
		);
		Возврат ЦветаПалитры;
	КонецЕсли;

	Диаграмма = Новый Диаграмма;
	ОписаниеПалитры = Диаграмма.ОписаниеПалитрыЦветов;
	ОписаниеПалитры.ПалитраЦветов = ПалитраЦветов;
	Если КоличествоЦветовГрадиентнойПалитры <> Неопределено Тогда
		ОписаниеПалитры.МаксимальноеКоличествоЦветовГрадиентнойПалитры = КоличествоЦветовГрадиентнойПалитры;
		Для НомерСерии = 1 По КоличествоЦветовГрадиентнойПалитры Цикл
			Диаграмма.Серии.Добавить("Серия" + XMLСтрока(НомерСерии));	// Для градиентных палитр обязательно наличие серий.
		КонецЦикла;
	КонецЕсли;
	Если ЦветНачалаГрадиентнойПалитры <> Неопределено Тогда
		ОписаниеПалитры.ЦветНачалаГрадиентнойПалитры = ЦветНачалаГрадиентнойПалитры;
	КонецЕсли;
	Если ЦветКонцаГрадиентнойПалитры <> Неопределено Тогда
		ОписаниеПалитры.ЦветКонцаГрадиентнойПалитры = ЦветКонцаГрадиентнойПалитры;
	КонецЕсли;
	
	ЦветаПалитры = ОписаниеПалитры.ПолучитьПалитру();  
	Возврат ЦветаПалитры;

КонецФункции // ЦветаПалитрыЦветовДиаграммы()

#КонецОбласти // Цвет

#Область НавигационныеСсылки

// Формирует представления навигационных ссылок в формате Соответствия
//
// Параметры:
//	НавигационныеСсылки - Массив из Строка - Получаемые ссылки
//
// Возвращаемое значение:
//	Соответствие:
//		* Ключ		 - Строка		 - Переданная навигационная ссылка из параметра НавигационныеСсылки
//		* Значение	 - Строка		 - Представление навигационной ссылки.
//					 - Неопределено	 - Объект отсутствует в базе.
//
Функция ПредставленияНавигационныхСсылок(НавигационныеСсылки)
	
	Представления = Новый Соответствие;
	
	ПредставленияНавСсылок = ПолучитьПредставленияНавигационныхСсылок(НавигационныеСсылки);
	Для Индекс = 0 По НавигационныеСсылки.ВГраница() Цикл
		ПредставлениеНавСсылки = ПредставленияНавСсылок[Индекс];
		Если ТипЗнч(ПредставлениеНавСсылки) = Тип("ПредставлениеНавигационнойСсылки") Тогда
			Представление = ПредставлениеНавСсылки.Текст;
		Иначе
			Представление = Неопределено;
		КонецЕсли;
		Представления.Вставить(НавигационныеСсылки[Индекс], Представление);
	КонецЦикла;
	
	Возврат Представления;
	
КонецФункции // ПредставленияНавигационныхСсылок()

// Получает представление навигационной ссылки
//
// Параметры:
//	НавигационнаяСсылка - Строка - Получаемая ссылка
//
// Возвращаемое значение:
//	Строка		 - Представление навигационной ссылки. Если объект отсутствует в базе - пустая строка.
//
Функция ПредставлениеНавигационнойСсылки(НавигационнаяСсылка)
	
	Представление = "";
	
	НавигационныеСсылки = Новый Массив;
	Если ЗначениеЗаполнено(НавигационнаяСсылка) Тогда
		НавигационныеСсылки.Добавить(НавигационнаяСсылка);
	КонецЕсли;
	ПредставленияНавСсылок = ПолучитьПредставленияНавигационныхСсылок(НавигационныеСсылки);
	Если ЗначениеЗаполнено(ПредставленияНавСсылок) Тогда
		ПредставлениеНавСсылки = ПредставленияНавСсылок[0];
		Если ТипЗнч(ПредставлениеНавСсылки) = Тип("ПредставлениеНавигационнойСсылки") Тогда
			Представление = ПредставлениеНавСсылки.Текст;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Представление;
	
КонецФункции // ПредставлениеНавигационнойСсылки()

#КонецОбласти // НавигационныеСсылки

#Область OneScript

#Область ФункцииБолванки

Функция ПолучитьПредставленияНавигационныхСсылок(НавигационныеСсылки)
	Возврат Новый Соответствие;
КонецФункции

<<<<<<< HEAD
=======
Функция СтрНайтиВсеПоРегулярномуВыражению(Строка, РегулярноеВыражение, ИгнорироватьРегистр, Многострочная)
	Возврат Новый Массив;
КонецФункции
>>>>>>> 7f4e315310c54a54117b1d4df8a38d516cb2d744

#КонецОбласти // ФункцииБолванки

СериализаторXDTO = Новый СериализаторXDTO;

#КонецОбласти // OneScript