#Область ТаблицаЗначений

// Выгружает значения нескольких колонок таблицы значений в один массив.
//	Порядок следования значений в массиве соответствует порядку следования колонок.
//
// Параметры:
//	ИсходнаяТаблица		 - ТаблицаЗначений	 - Таблица, данные которой требуется выгрузить
//	Колонки				 - Строка			 - Перечисление колонок, которые слудует выгрузить. Если не указан, выгружаются все колонки.
//	Отбор				 - Структура		 - Отбор, строк таблицы для выгрузки.
//	ТолькоЗаполненные	 - Булево			 - Будут выгружены только заполненные значения. Значения проверяются функцией ЗначениеЗаполнено().
//	ТолькоУникальные	 - Булево			 - Полученный массив будет содержать только уникальные значения. Порядок следования значений в массиве - произвольный.
//
// Возвращаемое значение:
//	Массив - Значения колонок исходной таблицы.
//
Функция ЗначенияТаблицыЗначенийВМассив(ИсходнаяТаблица, Знач Колонки = "", Отбор = Неопределено, ТолькоЗаполненные = Ложь, ТолькоУникальные = Ложь)
	
	РезультирующийМассив = Новый Массив;
	Если Ложь Тогда ИсходнаяТаблица = Новый ТаблицаЗначений КонецЕсли;

	КоллекцияСтрок = ИсходнаяТаблица;
	Если ТипЗнч(Отбор) = Тип("Структура") Тогда
		КоллекцияСтрок = ИсходнаяТаблица.НайтиСтроки(Отбор);
	КонецЕсли;

	Если не ЗначениеЗаполнено(КоллекцияСтрок) Тогда Возврат РезультирующийМассив КонецЕсли;	// Пустой массив

	ИменаКолонок = Новый Массив;
	Если ЗначениеЗаполнено(Колонки) Тогда
		ИменаКолонок = СтрРазделить(Колонки, ", ", Ложь);
	Иначе
		Для Каждого Колонка Из ИсходнаяТаблица.Колонки Цикл
			ИменаКолонок.Добавить(Колонка.Имя);
		КонецЦикла;
	КонецЕсли;

	Для Каждого ИмяКолонки из ИменаКолонок Цикл
		Для каждого СтрокаТаблицы Из КоллекцияСтрок Цикл
			Значение = СтрокаТаблицы[ИмяКолонки];
			Если ТолькоЗаполненные и не ЗначениеЗаполнено(Значение) Тогда Продолжить КонецЕсли;
			Если ТолькоУникальные и РезультирующийМассив.Найти(Значение) <> Неопределено Тогда Продолжить КонецЕсли;
			РезультирующийМассив.Добавить(Значение);
		КонецЦикла;
	КонецЦикла;

	Возврат РезультирующийМассив;

КонецФункции // ЗначенияТаблицыЗначенийВМассив()

// Разносит значения из определённой колонки таблицы в самостоятельные колонки.
//
// Параметры:
//	ИсходнаяТаблица		 - ТаблицаЗначений	 - Таблица для обработки
//	Измерения			 - Строка			 - Измерения, сохраняемые в таблице значений.
//	КолонкаПоказателя	 - Строка			 - Имя колонки, значения из которой  будут вынесены в отдельные колонки.
//	КолонкиПоказателя	 - Соответствие		 - Значения, которые будут разнесены по колонкам. В результирующей таблице будут только значения показателя, указанного в этой коллекции.
//		Ключ	 - Произвольный	 - Значение, выделяемое в колонку 
//		Значение - Строка		 - Префикс поздаваемой колонки.
//	Ресурсы				 - Строка - Имена ресурсов, которые будут выделены в самостоятельные колонки. 
//		Если указано больше одного ресурса, являются суффиксами создаваемых колонок.
//		Числовые ресурсы
//
// Пример:
//	СтрокиТаблицыЗначенийВКолонки(ТаблицаЗначений, "Номенклатура", "Склад", {Склад1:"Первый", Склад2:"Второй"}, "Количество");	// ТаблицаЗначений{Номенклатура, Первый, Второй}
//	СтрокиТаблицыЗначенийВКолонки(ТаблицаЗначений, "Номенклатура", "Склад", {Склад1:"Первый", Склад2:"Второй"}, "Количество, Стоимость"); // ТаблицаЗначений{Номенклатура, ПервыйКоличество, ПервыйСтоимость, ВторойКоличество, ВторойСтоимость}
//
// Возвращаемое значение:
//	ТаблицаЗначений - Таблица, содержащая переданные измерения и выделенные ресурсы.
//		Таблица свёрнута по комплектам измерений (параметр измерения).
//		Числовые показатели, если встречаются многократно, просуммированы. 
//		Прочие показатели выражаются последним значением из набора исходных данных.
//
Функция СтрокиТаблицыЗначенийВКолонки(ИсходнаяТаблица, Знач Измерения, КолонкаПоказателя, Знач КолонкиПоказателя, Знач Ресурсы)

	ИменаКолонокРесурсов = Новый Соответствие;

	ЕстьИзмерения = ЗначениеЗаполнено(Измерения);

	#Область КонструкторРезультирующаяТаблица

	Если ЕстьИзмерения Тогда
		РезультирующаяТаблица = ИсходнаяТаблица.СкопироватьКолонки(Измерения);
		ИменаКолонокИзмерений = СтрРазделить(Измерения, ", ", Ложь);
	Иначе
		РезультирующаяТаблица = Новый ТаблицаЗначений;
		ИменаКолонокИзмерений = Новый Массив;
	КонецЕсли;

	ИменаКолонокРесурсов = СтрРазделить(Ресурсы, ", ", Ложь);
	ИспользоватьСуффиксРесурсов = ИменаКолонокРесурсов.Количество() > 1;
	ИменаКолонокПоказателей = Новый Массив;
	Для КолонкаПоказатель Из КолонкиПоказателя Цикл
		Если ИменаКолонокПоказателей.Найти(КолонкаПоказатель.Значение) = Неопределено Тогда
			ИменаКолонокПоказателей.Добавить(КолонкаПоказатель.Значение);
		КонецЕсли;
	КонецЦикла;
	Для каждого ИмяКолонкиПоказателя Из ИменаКолонокПоказателей Цикл
		Для каждого ИмяКолонкиРесурса Из ИменаКолонокРесурсов Цикл
			ИмяКолонкиЗначения = ИмяКолонкиПоказателя + ?(ИспользоватьСуффиксРесурсов, ИмяКолонкиРесурса, ""); 
			РезультирующаяТаблица.Колонки.Добавить(ИмяКолонкиЗначения, ИсходнаяТаблица.Колонки[ИмяКолонкиРесурса].ТипЗначения);
		КонецЦикла;
	КонецЦикла;
	Если ЕстьИзмерения Тогда
		РезультирующаяТаблица.Индексы.Добавить(Измерения);
	КонецЕсли;
	#КонецОбласти	// КонструкторРезультирующаяТаблица

	ПредыдущаяПозицияРезультат = Неопределено;
	Для каждого ПозицияИсходная Из ИсходнаяТаблица Цикл
		
		Значение = ПозицияИсходная[КолонкаПоказателя];
		ИмяКолонкиПоказателя = КолонкиПоказателя[Значение];
		Если КолонкаЗначения = Неопределено Тогда Продолжить КонецЕсли;

		ПозицияРезультат = Неопределено;
		Если ЕстьИзмерения и ПредыдущаяПозицияРезультат <> Неопределено Тогда
			НужноНайтиСтроку = Ложь;
			Для каждого ИмяКолонкиИзмерения Из ИменаКолонокИзмерений Цикл
				Если ПредыдущаяПозицияРезультат[ИмяКолонкиИзмерения] <> ПозицияИсходная[ИмяКолонкиИзмерения] Тогда
					НужноНайтиСтроку = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если НужноНайтиСтроку Тогда
				СтруктураПоиска = Новый Структура(Измерения);
				ЗаполнитьЗначенияСвойств(СтруктураПоиска, ПозицияИсходная);
				Для каждого ПозицияРезультат Из РезультирующаяТаблица.НайтиСтроки(СтруктураПоиска) Цикл
					Прервать;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли; 
		Если ПозицияРезультат = Неопределено Тогда
			ПозицияРезультат = РезультирующаяТаблица.Добавить();
			Если ЗначениеЗаполнено(Измерения) Тогда
				ЗаполнитьЗначенияСвойств(ПозицияРезультат, ПозицияИсходная, Измерения);
			КонецЕсли;
		КонецЕсли; 
		
		Для каждого ИмяКолонкиРесурса Из ИменаКолонокРесурсов Цикл

			ИмяКолонкиПоказателя = ИмяКолонкиПоказателя + ?(ИспользоватьСуффиксРесурсов, ИмяКолонкиРесурса, "");

		КонецЦикла;


	КонецЦикла;

	Возврат РезультирующаяТаблица;

КонецФункции // СтрокиТаблицыЗначенийВКолонки()

// Получает итоги по колонкам таблицы с приминением отбора.
//
// Параметры:
//  ТаблицаЗначений	 - ТаблицаЗначений	 - Исходная таблица.
//  ПараметрыОтбора	 - Структура		 - Отбор строк, по которым будут подсчитаны итоги.
//  Ресурсы			 - Строка			 - Имена колонок итога.
// 
// Возвращаемое значение:
//   - Структура   - Полученные итоги. Ключ: Имя колонки, Значение: Число.
//
Функция ИтогиТаблицыЗначенийПоОтбору(ТаблицаЗначений, ПараметрыОтбора, Ресурсы)

	Итоги = Новый Структура(Ресурсы);
	ТаблицаИтогов = ТаблицаЗначений.Скопировать(ПараметрыОтбора, Ресурсы);
	ТаблицаИтогов.Свернуть(, Ресурсы);
	Если ЗначениеЗаполнено(ТаблицаИтогов) Тогда
		ЗаполнитьЗначенияСвойств(Итоги, ТаблицаИтогов[0]);
	Иначе
		Для каждого Элемент Из Итоги Цикл
			Элемент.Значение = 0;
		КонецЦикла;  	
	КонецЕсли; 
	
	Возврат Итоги;

КонецФункции // ИтогиТаблицыЗначенийПоОтбору()

// Позволяет разделить данные исходной таблицы на произвольное количество частей
// Например, таблицу из трёх строк на пять частей.
//
// Параметры:
//	ДелимаяТаблица	 - ТаблицаЗначений - Разделяемая таблица.
//	КлючевойРесурс	 - Строка - Имя поля ресурса, который подвергается делению.
//		Ключевой ресурс должен быть положительным числом.
//	Делители		 - Массив - Массив значений ресурса, на которые надо разделить исходную таблицу. Элемент: Число. 
//		Каждый делитель должен быть положительным числом.
//	ВедомыеРесурсы	 - Строка - Имена колонок делимой таблицы через запятую.
//		Значения в этих колонках в новой таблице будут распределены пропорционально значению ключевого ресурса.
//
// Возвращаемое значение:
//	ТаблицаЗначений - Результирующая таблица
//
Функция РазделитьТаблицуПоРесурсу(ДелимаяТаблица, КлючевойРесурс, Делители, Знач ВедомыеРесурсы)
	
	#Область РезультирующаяТаблица
	
	РезультирующаяТаблица = ДелимаяТаблица.Скопировать();
	ИсходныеСтроки = Новый Соответствие;	// Для каждоый строки результата содержит исходную строку
	Для Индекс = 0 По РезультирующаяТаблица.Количество() - 1 Цикл
		ИсходнаяСтрока = ДелимаяТаблица[Индекс];
		РезультирующаяСтрока = РезультирующаяТаблица[Индекс];
		ИсходныеСтроки.Вставить(РезультирующаяСтрока, ИсходнаяСтрока);
		
	КонецЦикла;
	
	#КонецОбласти // РезультирующаяТаблица

	#Область РазделениеПоКлючевомуРесурсу
	
	ИндексРезультата = -1;
	МаксИндексРесурснойТаблицы = РезультирующаяТаблица.Количество() - 1;
	Для ИндексДелителя = 0 По Делители.ВГраница() Цикл
		Делитель = Делители[ИндексДелителя];
		Банк = Делитель;
		Пока Банк > 0 Цикл
			ИндексРезультата = ИндексРезультата + 1;
			СтрокаРезультата = РезультирующаяТаблица[ИндексРезультата];
			ИсходнаяСтрока = ИсходныеСтроки[СтрокаРезультата];
			Делимое = СтрокаРезультата[КлючевойРесурс];
			Транш = Мин(Банк, Делимое);
			РазделятьДелимое = (Транш < Делимое);
			Если РазделятьДелимое Тогда
				НоваяСтрокаРезультата = РезультирующаяТаблица.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрокаРезультата, СтрокаРезультата);
				НоваяСтрокаРезультата[КлючевойРесурс] = НоваяСтрокаРезультата[КлючевойРесурс] - Транш;
				СтрокаРезультата[КлючевойРесурс] = Транш;
				РезультирующаяТаблица.Сдвинуть(НоваяСтрокаРезультата, ИндексРезультата - РезультирующаяТаблица.Индекс(НоваяСтрокаРезультата) + 1);
				
				ИсходныеСтроки.Вставить(НоваяСтрокаРезультата, ИсходнаяСтрока);			// Запоминаем в исходную строку
				
				МаксИндексРесурснойТаблицы = МаксИндексРесурснойТаблицы + 1;
			КонецЕсли;
			Банк = Банк - Транш;
		КонецЦикла;
		Если ИндексРезультата >= МаксИндексРесурснойТаблицы Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	// Подготовим не попадающие строки результата к удалению
	УдаляемыеСтрокиРезультата = Новый Массив;
	Для ИндексРезультата = (ИндексРезультата + 1) По МаксИндексРесурснойТаблицы Цикл
		УдаляемыеСтрокиРезультата.Добавить(РезультирующаяТаблица[ИндексРезультата]);
	КонецЦикла; 
	
	#КонецОбласти // РазделениеПоКлючевомуРесурсу
	
	#Область ВедомыеРесурсы
	
	ВедомыеРесурсыМассив = СтрРазделить(ВедомыеРесурсы, ", ", Ложь);
	
	РаспределятьВедомыеРесурсы = ЗначениеЗаполнено(ВедомыеРесурсы);
	
	Если РаспределятьВедомыеРесурсы Тогда
		
		#Область КорреспонденцияСтрок
		КорреспонденцияСтрок = Новый Соответствие; // {СтрокаТаблицыЗначений; Массив{СтрокаТаблицыЗначений}} - исходные строки и получившиеся в результате разделения строки
		Для каждого Элемент Из ИсходныеСтроки Цикл
			ИсходнаяСтрока		 = Элемент.Значение;
			РезультирующаяСтрока = Элемент.Ключ;
			СтрокиРезультата = КорреспонденцияСтрок[Элемент.Значение];
			Если СтрокиРезультата = Неопределено Тогда
				СтрокиРезультата = Новый Массив;
				КорреспонденцияСтрок.Вставить(ИсходнаяСтрока, СтрокиРезультата);
			КонецЕсли; 
			СтрокиРезультата.Добавить(РезультирующаяСтрока);
		КонецЦикла; 
		#КонецОбласти // КорреспонденцияСтрок 
		
		Для каждого ЭлементКорреспонденции Из КорреспонденцияСтрок Цикл
			
			ИсходнаяСтрока	 = ЭлементКорреспонденции.Ключ;
			СтрокиРезультата = ЭлементКорреспонденции.Значение;
			
			Если СтрокиРезультата.Количество() = 1 Тогда Продолжить КонецЕсли; 
			
			Для каждого ВедомыйРесурс Из ВедомыеРесурсыМассив Цикл
				
				// Подготовим распределение:
				РаспределяемаяСумма = ИсходнаяСтрока[ВедомыйРесурс];
				Коэффициенты = Новый Массив;
				Для каждого СтрокаРезультата Из СтрокиРезультата Цикл
					Коэффициенты.Добавить(СтрокаРезультата[КлючевойРесурс]);
				КонецЦикла; 
				Точность = РезультирующаяТаблица.Колонки[ВедомыйРесурс].ТипЗначения.КвалификаторыЧисла.РазрядностьДробнойЧасти;
				
				// Распределение, аналогичное БСП.РаспределитьСуммуПропорциональноКоэффициентам()
				#Область РаспределениеПропорционально
			
				ИндексМаксимальногоКоэффициента = 0;
				МаксимальныйКоэффициент = 0;
				РаспределеннаяСумма = 0;
				СуммаКоэффициентов  = 0;
		
				Для Индекс = 0 По Коэффициенты.Количество() - 1 Цикл
					Коэффициент = Коэффициенты[Индекс];
					
					АбсолютноеЗначениеКоэффициента = ?(Коэффициент > 0, Коэффициент, - Коэффициент);
					Если МаксимальныйКоэффициент < АбсолютноеЗначениеКоэффициента Тогда
						МаксимальныйКоэффициент = АбсолютноеЗначениеКоэффициента;
						ИндексМаксимальногоКоэффициента = Индекс;
					КонецЕсли;
					
					СуммаКоэффициентов = СуммаКоэффициентов + Коэффициент;
				КонецЦикла;
		
				РезультатРаспределения = Новый Массив(Коэффициенты.Количество());
				
				Если СуммаКоэффициентов <> 0 Тогда
				
					Для Индекс = 0 По Коэффициенты.Количество() - 1 Цикл
						РезультатРаспределения[Индекс] = Окр(РаспределяемаяСумма * Коэффициенты[Индекс] / СуммаКоэффициентов, Точность, 1);
						РаспределеннаяСумма = РаспределеннаяСумма + РезультатРаспределения[Индекс];
					КонецЦикла;
				
					// Погрешности округления отнесем на коэффициент с максимальным весом.
					Если Не РаспределеннаяСумма = РаспределяемаяСумма Тогда
						РезультатРаспределения[ИндексМаксимальногоКоэффициента] = РезультатРаспределения[ИндексМаксимальногоКоэффициента] + РаспределяемаяСумма - РаспределеннаяСумма;
					КонецЕсли;
					
				Иначе
					
					Для Индекс = 0 по РезультатРаспределения.ВГраница() Цикл
						РезультатРаспределения.Вставить(Индекс, 0);						
					КонецЦикла; 
					
				КонецЕсли; 

				#КонецОбласти // РаспределениеПропорционально 			
				
				// Применяем результаты распределения:
				Для Индекс = 0 По Коэффициенты.ВГраница() Цикл
					СтрокиРезультата[Индекс][ВедомыйРесурс] = РезультатРаспределения[Индекс];
				КонецЦикла;  
				
			КонецЦикла; 
		
		КонецЦикла; 				
	
	КонецЕсли;	// РаспределятьВедомыеРесурсы
	
	#КонецОбласти // ВедомыеРесурсы
	
	// Удалим лишние строки результата:
	Для каждого Строка Из УдаляемыеСтрокиРезультата Цикл
		РезультирующаяТаблица.Удалить(Строка);
	КонецЦикла; 
	
	Возврат РезультирующаяТаблица;
	
КонецФункции // РазделитьТаблицуПоРесурсу()

#КонецОбласти // ТаблицаЗначений

#Область ДеревоЗначений

// Получает различные значения указанных полей дерева значений.
//
// Параметры:
//  Узел	 - ДеревоЗначений	 - Дерево значений
//  Колонки	 - Строка			 - Имена получаемых полей
//  Значения - Неопределено		 - (служебный)
// 
// Возвращаемое значение:
//  ТаблицаЗначений - Полученные значения.
//
Функция ПолучитьРазличныеЗначенияКолонкиДереваЗначений(Узел, ИмяКолонки, Значения = Неопределено)
	
	ЭтоНачалоРекурсии = Значения = Неопределено;

	Если ТипЗнч(Узел) = Тип("СтрокаДереваЗначений") Тогда
		
		Значения.Вставить(Узел[ИмяКолонки]);
		Для каждого Ветвь Из Узел.Строки Цикл
			ПолучитьРазличныеЗначенияКолонкиДереваЗначений(Ветвь, ИмяКолонки, Значения)
		КонецЦикла;
	
	ИначеЕсли ТипЗнч(Узел) = Тип("ДеревоЗначений") Тогда
		
		Значения = Новый Соответствие;
		
		Для каждого Ветвь Из Узел.Строки Цикл
			ПолучитьРазличныеЗначенияКолонкиДереваЗначений(Ветвь, ИмяКолонки, Значения)
		КонецЦикла;
		
	ИначеЕсли ТипЗнч(Узел) = Тип("Строка") и ЭтоАдресВременногоХранилища(Узел) Тогда
		
		Возврат ПолучитьРазличныеЗначенияКолонкиДереваЗначений(ПолучитьИзВременногоХранилища(Узел), ИмяКолонки);
		
	КонецЕсли; 
	
	Если ЭтоНачалоРекурсии Тогда // Формируем результирующий массив
		
		МассивЗначений = Новый Массив;
		Для каждого Элемент Из Значения Цикл
			МассивЗначений.Добавить(Элемент.Ключ);
		КонецЦикла; 
		
		Возврат МассивЗначений;
			
	КонецЕсли; 
	
	Возврат Значения;

КонецФункции // ПолучитьРазличныеЗначенияКолонкиДереваЗначений()

// Получает различные значения указанного поля дерева значений.
//
// Параметры:
//  Узел					 - Строка, ДеревоЗначений, СтрокаДереваЗначений - Дерево значений, или его адрес во временном хранилище
//  ИмяКолонки				 - Строка			 - Имена получаемой колонки
//  ПромежуточнаяКоллекция	 - Неопределено		 - (служебный)
// 
// Возвращаемое значение:
//  Массив - Полученные значения.
//
Функция ПолучитьРазличныеЗначенияКолонкиДереваЗначений(Узел, ИмяКолонки, ПромежуточнаяКоллекция = Неопределено)
	
	ЭтоНачалоРекурсии = ПромежуточнаяКоллекция = Неопределено;

	Если ТипЗнч(Узел) = Тип("СтрокаДереваЗначений") Тогда
		
		ПромежуточнаяКоллекция.Вставить(Узел[ИмяКолонки]);
		Для каждого Ветвь Из Узел.Строки Цикл
			ПолучитьРазличныеЗначенияКолонкиДереваЗначений(Ветвь, ИмяКолонки, ПромежуточнаяКоллекция)
		КонецЦикла;
	
	ИначеЕсли ТипЗнч(Узел) = Тип("ДеревоЗначений") Тогда
		
		ПромежуточнаяКоллекция = Новый Соответствие;
		
		Для каждого Ветвь Из Узел.Строки Цикл
			ПолучитьРазличныеЗначенияКолонкиДереваЗначений(Ветвь, ИмяКолонки, ПромежуточнаяКоллекция)
		КонецЦикла;
		
	ИначеЕсли ТипЗнч(Узел) = Тип("Строка") и ЭтоАдресВременногоХранилища(Узел) Тогда
		
		ДеревоДанных = ПолучитьИзВременногоХранилища(Узел);
		Если ТипЗнч(ДеревоДанных) = Тип("ДеревоЗначений") Тогда
			Возврат ПолучитьРазличныеЗначенияКолонкиДереваЗначений(ДеревоДанных, ИмяКолонки);
		Иначе
			Возврат Новый Массив;
		КонецЕсли; 
		
	КонецЕсли; 
	
	Если ЭтоНачалоРекурсии и ПромежуточнаяКоллекция <> Неопределено Тогда // Формируем результирующий массив
		
		МассивЗначений = Новый Массив;
		Для каждого Элемент Из ПромежуточнаяКоллекция Цикл
			МассивЗначений.Добавить(Элемент.Ключ);
		КонецЦикла; 
		
		Возврат МассивЗначений;
			
	КонецЕсли; 
	
	Возврат ПромежуточнаяКоллекция;

КонецФункции // ПолучитьРазличныеЗначенияКолонокДереваЗначений()

#КонецОбласти	// ДеревоЗначений

