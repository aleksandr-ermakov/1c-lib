
// Модуль содержит реализацию новых функций платформы для старых версий платформы.

// BSLLS:DeprecatedFind-off
// BSLLS:NumberOfOptionalParams-off
// BSLLS:NumberOfParams-off
// BSLLS:DeprecatedFind-off
// BSLLS:MissingParameterDescription-off

#Область ПрограммныйИнтерфейс

// Определяет, что строка начинается с указанной подстроки. 
// Определение выполняется с учетом регистра, аналогично функции Найти.
//
// Параметры:
//  Строка		 - Строка - Проверяемая строка.
//  СтрокаПоиска - Строка - Подстрока, с которой должна начинаться проверяемая строка.
//
// Возвращаемое значение:
//  Булево - Истина, если проверяемая строка начинается с указанной подстроки.
//
Функция СтрНачинаетсяС(Знач Строка, Знач СтрокаПоиска) Экспорт
	
	Возврат Лев(Строка, СтрДлина(СтрокаПоиска)) = СтрокаПоиска;

КонецФункции

// Находит первое вхождение искомой строки как подстроки в исходной строке.
// Сравнение выполняется с учетом регистра.
//
// Параметры:
//  Строка			- Строка - Исходная строка для поиска.
//  ПодстрокаПоиска - Строка - Искомая подстрока
//
// Возвращаемое значение:
//  Число - Позиция первого вхождения искомой подстроки.
//		Если подстрока не найдена, возвращается 0.
//
Функция СтрНайти(Знач Строка, Знач ПодстрокаПоиска) Экспорт
	Возврат Найти(Строка, ПодстрокаПоиска);
КонецФункции

// Определяет, что строка заканчивается указанной подстрокой.
// Определение выполняется с учетом регистра, аналогично функции Найти.
//
// Параметры:
//  Строка		 - Строка - Проверяемая строка.
//  СтрокаПоиска - Строка - Подстрока, с которой должна заканчиваться проверяемая строка.
//
// Возвращаемое значение:
//  Булево - Истина, если проверяемая строка заканчивается указанной подстрокой.
//
Функция СтрЗаканчиваетсяНа(Знач Строка, Знач СтрокаПоиска) Экспорт
	
	Возврат Прав(Строка, СтрДлина(СтрокаПоиска)) = СтрокаПоиска;

КонецФункции

// Разделяет строку на массив подстрок по заданному разделителю.
//
// Параметры:
//	Строка		 - Строка - Исходная строка для разделения.
//	Разделитель - Строка - Строка-разделитель.
//	ВключатьПустые - Булево - Необязательный. Если Истина, то пустые подстроки
//		между разделителями будут включены в результат. По умолчанию Ложь.
//
// Возвращаемое значение:
//	Массив - Массив подстрок, полученных в результате разделения.
//
Функция СтрРазделить(Знач Строка, Знач Разделитель, Знач ВключатьПустые = Ложь) Экспорт

	Результат = Новый Массив;
	Если СтрДлина(Разделитель) = 0 Тогда
		Для Индекс = 1 По СтрДлина(Строка) Цикл
			Результат.Добавить(Сред(Строка, Индекс, 1));
		КонецЦикла;
	Иначе

		Фрагмент = "";
		Для НомерСимвола = 1 По СтрДлина(Строка) Цикл
			Символ = Сред(Строка, НомерСимвола, 1);
			Если Найти(Разделитель, Символ) > 0 Тогда
				Если ВключатьПустые Или СтрДлина(Фрагмент) > 0 Тогда
					Результат.Добавить(Фрагмент);
				КонецЕсли;
				Фрагмент = "";
			Иначе
				Фрагмент = Фрагмент + Символ;
			КонецЕсли;
		КонецЦикла;
		Если ВключатьПустые Или СтрДлина(Фрагмент) > 0 Тогда
			Результат.Добавить(Фрагмент);
		КонецЕсли;

	КонецЕсли;
	
	Возврат Результат;

КонецФункции

// Соединяет массив строк в одну строку с заданным разделителем.
//
// Параметры:
//	Строки		 - Массив - Массив строк для соединения.
//	Разделитель - Строка - Строка-разделитель.
//
// Возвращаемое значение:
//	Строка - Результирующая строка, полученная в результате соединения
//
Функция СтрСоединить(Знач Строки, Знач Разделитель = "") Экспорт

	Результат = "";
	Для Каждого Строка Из Строки Цикл
		Если Результат <> "" Тогда
			Результат = Результат + Разделитель;
		КонецЕсли;
		Результат = Результат + Строка;
	КонецЦикла;
	
	Возврат Результат;

КонецФункции

// Подставляет параметры в строку по номеру.
// - Если в строке встречается символ % два раза подряд (%%), такая пара трактуется как одинарный процент, 
//	независимо от того, стоит ли сразу за ними цифра или не стоит.
//
// Параметры:
//	Шаблон  - Строка - Шаблон строки с параметрами в виде %1, %2, ..., %10. 
//		Если требуется сразу после номера подстановки написать цифру, 
//		то номер подстановки должен быть указан в скобках. Тогда строка может иметь следующий вид: "%(1)1cv8с.exe"
//	Параметр1..Параметр10 - Строка - Значения параметров для подстановки в шаблон.
//
// Возвращаемое значение:
//	Строка - Результирующая строка с подставленными параметрами
//
Функция СтрШаблон(Знач Шаблон, 
	Знач Параметр1 = Неопределено, 
	Знач Параметр2 = Неопределено,
	Знач Параметр3 = Неопределено,
	Знач Параметр4 = Неопределено,
	Знач Параметр5 = Неопределено,
	Знач Параметр6 = Неопределено,
	Знач Параметр7 = Неопределено,
	Знач Параметр8 = Неопределено,
	Знач Параметр9 = Неопределено,
	Знач Параметр10 = Неопределено
	) Экспорт
	
	ПараметрыПоНомерам = Новый Соответствие;
	Для НомерПараметра = 1 По 10 Цикл
		ИмяПараметра = "Параметр" + Строка(НомерПараметра);
		ЗначениеПараметра = Вычислить(ИмяПараметра);
		ПараметрыПоНомерам[НомерПараметра] = ЗначениеПараметра;
	КонецЦикла;

	Цифры = "0123456789";

	Результат = "";

	ПредыдущийСимвол = "";
	Для НомерСимвола = 1 По СтрДлина(Шаблон) Цикл
		Символ = Сред(Шаблон, НомерСимвола, 1);
		НомерПараметра = 0;
		Если ПредыдущийСимвол = "%" Тогда

			Если Символ = "%" Тогда

				// Процент экранирован, и уже в результате.
				ПредыдущийСимвол = "";
				Продолжить;

			ИначеЕсли Символ = "(" Тогда

				// Начало номера параметра в скобках.
				// Дальше цифры и закрывающая скобка.
				ЧастьСтрокиПослеОткрывающейСкобки = Сред(Шаблон, НомерСимвола + 1);
				ПозицияЗакрывающейСкобки = Найти(ЧастьСтрокиПослеОткрывающейСкобки, ")");
				Попытка
					Если ПозицияЗакрывающейСкобки = 0 Тогда
						ВызватьИсключение "Нет закрывающией скобки";
					КонецЕсли;
					ФрагментНомераПараметра = Лев(ЧастьСтрокиПослеОткрывающейСкобки, ПозицияЗакрывающейСкобки - 1);
					Если СтрДлина(ФрагментНомераПараметра) = 0 Тогда
						ВызватьИсключение "Нет номера параметра в скобках";
					КонецЕсли;
					Для НомерСимволаЧисла = 1 По СтрДлина(ФрагментНомераПараметра) Цикл
						Если Найти(Цифры, Сред(ФрагментНомераПараметра, НомерСимволаЧисла, 1)) Тогда
							ВызватьИсключение "Неверный символ в номере параметра";
						КонецЕсли;
					КонецЦикла;
					НомерПараметра = Число(ФрагментНомераПараметра);
					Если НомерПараметра < 1 Или НомерПараметра > 10 Тогда
						ВызватьИсключение "Номер параметра вне диапазона 1..10";
					КонецЕсли;
				Исключение
					ВызватьИсключение "Ошибка синтаксиса шаблона в позиции " + Формат(НомерСимвола, "ЧГ=0");
				КонецПопытки;
				
				// В следующей итерации выйдет за закрывающую скобку.
				НомерСимвола = НомерСимвола + СтрДлина(ФрагментНомераПараметра);

			ИначеЕсли Найти(Цифры, Символ) > 0 Тогда

				// Номер параметра без скобок.

				ФрагментНомераПараметра = Символ;
				Для НомерЦифры = НомерСимвола + 1 По СтрДлина(Шаблон) Цикл
					ДопСимвол = Сред(Шаблон, НомерЦифры, 1);
					Если Найти(Цифры, ДопСимвол) > 0 Тогда
						ФрагментНомераПараметра = ФрагментНомераПараметра + ДопСимвол;
					Иначе
						Прервать;
					КонецЕсли;
				КонецЦикла;
				НомерПараметра = Число(ФрагментНомераПараметра);
				Если НомерПараметра < 1 Или НомерПараметра > 10 Тогда
					ВызватьИсключение "Номер параметра вне диапазона 1..10";
				КонецЕсли;

				// В следующей итерации выйдет на следующий символ после номера.
				НомерСимвола = НомерСимвола + СтрДлина(ФрагментНомераПараметра) - 1; 

			Иначе
				
				ВызватьИсключение "Ошибка синтаксиса шаблона в позиции " + Формат(НомерСимвола, "ЧГ=0");

			КонецЕсли;

			Если НомерПараметра > 0 Тогда
				ЗначениеПараметра = ПараметрыПоНомерам[НомерПараметра];
				Результат = Лев(Результат, СтрДлина(Результат) - 1) + ЗначениеПараметра;
				ПредыдущийСимвол = "";
			КонецЕсли;

		Иначе
			Результат = Результат + Символ;

		КонецЕсли;
		
		ПредыдущийСимвол = Символ;

	КонецЦикла;

	Возврат Результат;
	
КонецФункции

#КонецОбласти