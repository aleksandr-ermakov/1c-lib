
// BSLLS-CognitiveComplexity:off

#Область OneScript

Перем СериализаторXDTO; // Для тестирования

#КонецОбласти // OneScript

#Область ОписанияТипов

// Проверяет соответствие описаний типов
//
// Параметры:
//	ОписаниеТиповА			 - ОписаниеТипов
//	ОписаниеТиповБ			 - ОписаниеТипов
//	ПроверятьКвалификаторы	 - Булево	 - Кроме входящих описаний типов проверяются квалификаторы простых типов
//
// Возвращаемое значение:
//	Булево - Описания типов совпадают
//
Функция ОписанияТиповСовпадают(ОписаниеТиповА, ОписаниеТиповБ, ПроверятьКвалификаторы = Истина) Экспорт

	ТипыА = ОписаниеТиповА.Типы();
	ТипыБ = ОписаниеТиповБ.Типы();
	
	Если ТипыА.Количество() <> ТипыБ.Количество() Тогда
		Возврат Ложь;
	КонецЕсли;

	Для каждого ТипА Из ОписаниеТиповА.Типы() Цикл
		Если Не ОписаниеТиповБ.СодержитТип(ТипА) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Для каждого ТипБ Из ОписаниеТиповБ.Типы() Цикл
		Если Не ОписаниеТиповА.СодержитТип(ТипБ) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;

	Если Не ПроверятьКвалификаторы Тогда
		Возврат Истина;
	КонецЕсли;

	ТипыКвалификаторы = Новый Структура;
	ТипыКвалификаторы.Вставить("Дата",			 "КвалификаторыДаты");
	ТипыКвалификаторы.Вставить("ДвоичныеДанные", "КвалификаторыДвоичныхДанных");
	ТипыКвалификаторы.Вставить("Строка",		 "КвалификаторыСтроки");
	ТипыКвалификаторы.Вставить("Число",			 "КвалификаторыЧисла");
	Для каждого ТипКвалификатор Из ТипыКвалификаторы Цикл
		ИмяТипа			 = ТипКвалификатор.Ключ;
		ИмяКвалификатора = ТипКвалификатор.Значение;
		Если ОписаниеТиповА.СодержитТип(Тип(ИмяТипа)) 
			И Не КвалификаторыТиповСовпадают(
				ОписаниеТиповА[ИмяКвалификатора], 
				ОписаниеТиповБ[ИмяКвалификатора]) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;

	Возврат Истина;

КонецФункции // ОписанияТиповСовпадают()

// Проверяет совпадение квалификаторов типов
//
// Параметры:
//	КвалификаторыА	 - КвалификаторыДаты
//					 - КвалификаторыДвоичныхДанных
//					 - КвалификаторыСтроки
//					 - КвалификаторыЧисла
//	КвалификаторыБ	 - КвалификаторыДаты
//					 - КвалификаторыДвоичныхДанных
//					 - КвалификаторыСтроки
//					 - КвалификаторыЧисла
//
// Варианты вызова:
//	КвалификаторыТиповСовпадают(КвалификаторыДаты, КвалификаторыДаты)						 - Проверка квалификаторов даты
//	КвалификаторыТиповСовпадают(КвалификаторыДвоичныхДанных, КвалификаторыДвоичныхДанных)	 - Проверка квалификаторов строки
//	КвалификаторыТиповСовпадают(КвалификаторыСтроки, КвалификаторыСтроки)					 - Проверка квалификаторов двоичных данных
//	КвалификаторыТиповСовпадают(КвалификаторыЧисла, КвалификаторыЧисла)						 - Проверка квалификаторов числа
//
// Возвращаемое значение:
//   Булево   - Квалификаторы совпадают
//
Функция КвалификаторыТиповСовпадают(КвалификаторыА, КвалификаторыБ) Экспорт
	
	Если ТипЗнч(КвалификаторыА) <> ТипЗнч(КвалификаторыБ) Тогда
		Возврат Ложь;
	КонецЕсли;

	КвА = КвалификаторыА;
	КвБ = КвалификаторыБ;

	Если ТипЗнч(КвалификаторыА) = Тип("КвалификаторыДаты") Тогда

		КвалификаторыСовпадают	 = КвА.ЧастиДаты		 = КвБ.ЧастиДаты;

	ИначеЕсли	ТипЗнч(КвалификаторыА) = Тип("КвалификаторыДвоичныхДанных")
		Или		ТипЗнч(КвалификаторыА) = Тип("КвалификаторыСтроки") Тогда

		КвалификаторыСовпадают	 = КвА.Длина 			 = КвБ.Длина
								 И КвА.ДопустимаяДлина	 = КвБ.ДопустимаяДлина;

	ИначеЕсли ТипЗнч(КвалификаторыА) = Тип("КвалификаторыЧисла") Тогда

		КвалификаторыСовпадают	 = КвА.ДопустимыйЗнак 			 = КвБ.ДопустимыйЗнак
								 И КвА.Разрядность				 = КвБ.Разрядность
								 И КвА.РазрядностьДробнойЧасти	 = КвБ.РазрядностьДробнойЧасти;

	Иначе

		ВызватьИсключение "Непредвиденные параметры";

	КонецЕсли;

	Возврат КвалификаторыСовпадают;

КонецФункции // КвалификаторыТиповСовпадают()

// Сравнивает типы в составе описаний типов
// Без учета квалификаторов
//
// Параметры:
//	ОписаниеТиповА	 - ОписаниеТипов			 - Первое описание типов для сравнения
//					 - Массив Из ОписаниеТипов	 - Для сравнения трёх и более типов
//	ОписаниеТиповБ	 - ОписаниеТипов			 - Второе описание типов для сравнения. 
//												Не используется, если ОписаниеТиповА - это Массив
//
// Возвращаемое значение:
//	Соответствие:
//		* Ключ		 - ОписаниеТипов - Описание типов, поданное в параметре функции
//		* Значение	 - Массив Из Тип - Типы, присутствующие в этом описании, и отсутствующие в другом (любом из других)
//
// Варианты вызова:
//	СравнитьОписанияТипов(ОписаниеТипов, ОписаниеТипов) - Сравнение двух описаний типов
//	СравнитьОписанияТипов(Массив)						- Сравнивает трёх и более описаний типов
//
Функция СравнитьОписанияТипов(ОписаниеТиповА, ОписаниеТиповБ = Неопределено) Экспорт

	Если ТипЗнч(ОписаниеТиповА) = Тип("Массив") Тогда
		ОписанияТипов = ОписаниеТиповА;
	Иначе
		ОписанияТипов = Новый Массив;
		ОписанияТипов.Добавить(ОписаниеТиповА);
		ОписанияТипов.Добавить(ОписаниеТиповБ);
	КонецЕсли;

	Если ОписанияТипов.Количество() < 2 Тогда
		ВызватьИсключение "Описаний для сравнения должно быть 2 или более";
	КонецЕсли;

	СобственныеТипыОписаний = Новый Соответствие;
	Для каждого ОписаниеТипов Из ОписанияТипов Цикл
		СобственныеТипыОписаний.Вставить(ОписаниеТипов, Новый Массив);
	КонецЦикла;

	Для Каждого ТекущееОписаниеТипов Из ОписанияТипов Цикл
		ТипыТекущегоОписания = ТекущееОписаниеТипов.Типы();
		СобственныеТипыОписания = СобственныеТипыОписаний[ТекущееОписаниеТипов];
		Для Каждого ДругоеОписаниеТипов Из ОписанияТипов Цикл
			Если ТекущееОписаниеТипов = ДругоеОписаниеТипов Тогда
				Продолжить;
			КонецЕсли;
			ТипыДругогоОписания = ДругоеОписаниеТипов.Типы();
			Для каждого ТипТекущегоОписания Из ТипыТекущегоОписания Цикл
				Если ТипыДругогоОписания.Найти(ТипТекущегоОписания) = Неопределено
					И СобственныеТипыОписания.Найти(ТипТекущегоОписания) = Неопределено Тогда
					СобственныеТипыОписания.Добавить(ТипТекущегоОписания);
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;

	Возврат СобственныеТипыОписаний;

КонецФункции // СравнитьОписанияТипов()

// Сравнивает описания типов и формирует текстовое представление результата
//
// Параметры:
//	ОписаниеТиповА - ОписаниеТипов
//	ОписаниеТиповБ - ОписаниеТипов
//
// Возвращаемое значение:
//	Строка - Табличное представление результата сравнения
//
Функция СравнитьОписанияТиповСформироватьРезультатТекст(ОписаниеТиповА, ОписаниеТиповБ) Экспорт
	
	Если ТипЗнч(ОписаниеТиповА) = Тип("Массив") Тогда
		ОписанияТипов = ОписаниеТиповА;
	Иначе
		ОписанияТипов = Новый Массив;
		ОписанияТипов.Добавить(ОписаниеТиповА);
		ОписанияТипов.Добавить(ОписаниеТиповБ);
	КонецЕсли;

	РезультатСравнения = СравнитьОписанияТипов(ОписаниеТиповА, ОписаниеТиповБ);

	ВсеТипы = Новый СписокЗначений;
	Для каждого ОписаниеТипов Из ОписанияТипов Цикл
		СобственныеТипыОписания = РезультатСравнения[ОписаниеТипов];
		Для каждого Тип Из СобственныеТипыОписания Цикл
			Если ВсеТипы.НайтиПоЗначению(Тип) = Неопределено Тогда
				ВсеТипы.Добавить(Тип, Строка(Тип));
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	ЕстьРазличия = ЗначениеЗаполнено(ВсеТипы);
	Если Не ЕстьРазличия Тогда
		Возврат "Типы в составе описаний совпадают";
	КонецЕсли;

	ВсеТипы.СортироватьПоПредставлению();

	СоставТаблицы = Новый Массив;
	СоставСтроки = Новый Массив;
	Заголовок = "Тип \ Описание типов";
	СоставСтроки.Добавить(Заголовок);
	Для НомерТипа = 1 По ОписанияТипов.Количество() Цикл
		СоставСтроки.Добавить(Строка(НомерТипа));
	КонецЦикла;
	СоставТаблицы.Добавить(СоставСтроки);

	Для каждого ЭлементСписка Из ВсеТипы Цикл
		Тип = ЭлементСписка.Значение;
		ПредставлениеТипа = ЭлементСписка.Представление;
		СоставСтроки = Новый Массив;
		СоставСтроки.Добавить(ПредставлениеТипа);
		Для каждого ОписаниеТипов Из ОписанияТипов Цикл
			ТипЕстьВОписании = РезультатСравнения[ОписаниеТипов].Найти(Тип) <> Неопределено;
			СоставСтроки.Добавить(?(ТипЕстьВОписании, "+", "-"));
		КонецЦикла;
		СоставТаблицы.Добавить(СоставСтроки);
	КонецЦикла;

	ОтбиватьТабами			 = Ложь;
	ШиринаТаба				 = 4;

	МаксШиринаКолонки = 0;
	Для каждого СоставСтроки Из СоставТаблицы Цикл
		МаксШиринаКолонки = Макс(МаксШиринаКолонки, СтрДлина(СоставСтроки[0]));
	КонецЦикла;

	Если ОтбиватьТабами Тогда

		ШиринаКолонкиТабов	 = Цел(МаксШиринаКолонки / ШиринаТаба) + ?(МаксШиринаКолонки % ШиринаТаба, 1, 0);
		ФиксШиринаКолонки	 = ШиринаКолонкиТабов * ШиринаТаба;
		Для каждого СоставСтроки Из СоставТаблицы Цикл
			СодержимоеКолонки = СоставСтроки[0];
			ШиринаКолонки = СтрДлина(СодержимоеКолонки);
			РазницаШирины = ФиксШиринаКолонки - ШиринаКолонки;
			ДобавитьТабов = Цел(РазницаШирины / ШиринаТаба) + ?(РазницаШирины % ШиринаТаба, 1, 0);
			Для Номер = 1 По ДобавитьТабов Цикл
				СодержимоеКолонки = СодержимоеКолонки + Символы.Таб;
			КонецЦикла;
			СоставСтроки[0] = СодержимоеКолонки;
		КонецЦикла;

	Иначе // Выравнивание неразрывными пробелами

		Для каждого СоставСтроки Из СоставТаблицы Цикл
			СодержимоеКолонки = СоставСтроки[0];
			ШиринаКолонки = СтрДлина(СодержимоеКолонки);
			РазницаШирины = МаксШиринаКолонки - ШиринаКолонки;
			Для Номер = 1 По РазницаШирины Цикл
				СодержимоеКолонки = СодержимоеКолонки + Символы.НПП;
			КонецЦикла;
			СоставСтроки[0] = СодержимоеКолонки;
		КонецЦикла;
		
	КонецЕсли;

	ПредставлениеТаблицы = Новый Массив;
	РазделительКолонок = " | ";
	Для Каждого СоставСтроки Из СоставТаблицы Цикл
		ПредставлениеТаблицы.Добавить(СтрСоединить(СоставСтроки, РазделительКолонок));
	КонецЦикла;
	ПредставлениеТаблицы = СтрСоединить(ПредставлениеТаблицы, Символы.ПС);

	Возврат ПредставлениеТаблицы;

КонецФункции // СравнитьОписанияТиповСформироватьРезультатТекст()

#КонецОбласти

#Область ПримитивныеТипы

// Получает дату с точностью до секунды
//
// Параметры:
//	Дата - Дата - Исходная дата
//
// Возвращаемое значение:
//	Дата
//
Функция ДатаБезМиллисекунд(Дата) Экспорт

	 Возврат Дата(Год(Дата), Месяц(Дата), День(Дата), Час(Дата), Минута(Дата), Секунда(Дата));

КонецФункции // ДатаБезМиллисекунд()

// Проверяет, является тип примитивным.
//
// Параметры:
//  Тип						 - Тип		 - Проверяемый тип
//  СчитатьТипПримитивным	 - Булево	 - Если Истина - то Тип причисляется к примитивным типам.
// 
// Возвращаемое значение:
//  Булево
//
Функция ЭтоПримитивныйТип(Тип, СчитатьТипПримитивным = Истина) Экспорт

	Возврат Тип = Тип("Неопределено")
		Или Тип = Тип("Null")
		Или Тип = Тип("Число")
		Или Тип = Тип("Строка")
		Или Тип = Тип("Дата")  
		Или Тип = Тип("Булево")
		Или Тип = Тип("Тип") И СчитатьТипПримитивным;

КонецФункции // ЭтоПримитивныйТип()

// Разбивает заданный период на периоды с заданной периодичностью
//
// Параметры:
//	Период	 - СтандартныйПериод - Разделяемый период
//	Периодичность	 - Строка - Вид периода. 
//		Возможные значения:
//		* Минута
//		* Час
//		* День
//		* Неделя
//		* Месяц
//		* Год
//
// Возвращаемое значение:
//	Массив - Массив периодов в результате разделения. Элемент: СтандартныйПериод
//
// Пример:
//	РазделитьНаПериоды(Новый СтандартныйПериод(ВариантСтандартногоПериода.ЭтотКвартал), "Месяц"); // Вернёт массив стандартных периодов - месяцов квартала
//
Функция РазделитьНаПериоды(Период, Периодичность = "Месяц")

	НачалоТекущегоПериода	 = '00010101';
	НачалоПоследнегоПериода	 = '00010101';

	Если Периодичность = "Минута" Тогда
		НачалоТекущегоПериода	 = НачалоМинуты(Период.ДатаНачала);
		НачалоПоследнегоПериода	 = НачалоМинуты(Период.ДатаОкончания);
	ИначеЕсли Периодичность = "Час" Тогда
		НачалоТекущегоПериода	 = НачалоЧаса(Период.ДатаНачала);
		НачалоПоследнегоПериода	 = НачалоЧаса(Период.ДатаОкончания);
	ИначеЕсли Периодичность = "День" Тогда
		НачалоТекущегоПериода	 = НачалоДня(Период.ДатаНачала);
		НачалоПоследнегоПериода	 = НачалоДня(Период.ДатаОкончания);
	ИначеЕсли Периодичность = "Неделя" Тогда
		НачалоТекущегоПериода	 = НачалоНедели(Период.ДатаНачала);
		НачалоПоследнегоПериода	 = НачалоНедели(Период.ДатаОкончания);
	ИначеЕсли Периодичность = "Месяц" Тогда
		НачалоТекущегоПериода	 = НачалоМесяца(Период.ДатаНачала);
		НачалоПоследнегоПериода	 = НачалоМесяца(Период.ДатаОкончания);
	ИначеЕсли Периодичность = "Год" Тогда
		НачалоТекущегоПериода	 = НачалоГода(Период.ДатаНачала);
		НачалоПоследнегоПериода	 = НачалоГода(Период.ДатаОкончания);
	Иначе
		ВызватьИсключение "Неверно указан период";
	КонецЕсли;

	Периоды = Новый Массив;

	Пока НачалоТекущегоПериода <= НачалоПоследнегоПериода Цикл

		Если Периодичность = "Минута" Тогда
			КонецТекущегоПериода = КонецМинуты(НачалоТекущегоПериода);
		ИначеЕсли Периодичность = "Час" Тогда
			КонецТекущегоПериода = КонецЧаса(НачалоТекущегоПериода);
		ИначеЕсли Периодичность = "День" Тогда
			КонецТекущегоПериода = КонецДня(НачалоТекущегоПериода);
		ИначеЕсли Периодичность = "Неделя" Тогда
			КонецТекущегоПериода = КонецНедели(НачалоТекущегоПериода);
		ИначеЕсли Периодичность = "Месяц" Тогда
			КонецТекущегоПериода = КонецМесяца(НачалоТекущегоПериода);
		ИначеЕсли Периодичность = "Год" Тогда
			КонецТекущегоПериода = КонецГода(НачалоТекущегоПериода);
		Иначе
			ВызватьИсключение "Что-то пошло не так";
		КонецЕсли;

		ТекущийПериод = Новый СтандартныйПериод(
			Макс(НачалоТекущегоПериода,	 Период.ДатаНачала),
			Мин(КонецТекущегоПериода,	 Период.ДатаОкончания)
		);
		Периоды.Добавить(ТекущийПериод);

		НачалоТекущегоПериода = КонецТекущегоПериода + 1;
			
	КонецЦикла;
	
	Возврат Периоды;

КонецФункции // РазделитьНаПериоды()

// Изменяет переданные даты так, чтобы расположить их в хронологическом порядке.
//
// Параметры:
//	ИсходныеДаты	 - Массив из Дата - Массив неупорядоченных дат.
//	Период			 - Строка - Период, которого следует придерживаться в изменении дат.
//								Возможные значения: "Минута", "Час", "День", "Месяц", "Год".
//								Измененные даты не будут выходить за этот период.
//
// Возвращаемое значение:
//	Массив из Дата - массив упорядоченных дат.
//		Каждая дата массива - это дата исходного массива, но измененная таким образом, 
//		чтобы все даты в массиве шли по возрастанию.
//
Функция РаспределитьДатыПоХронологии(Знач ИсходныеДаты, Знач Период = "") Экспорт

	Если ТипЗнч(ИсходныеДаты) <> Тип("Массив") Тогда
		ВызватьИсключение "Параметр ИсходныеДаты: Ожидается тип Массив";
	КонецЕсли;

	КоличествоДат = ИсходныеДаты.Количество();
	Если КоличествоДат = 0 Тогда 
		Возврат Новый Массив;
	КонецЕсли;

	ДатыПоХронологии = Новый Массив(КоличествоДат);

	ВидПериодаЛюбой	 = 0;
	ВидПериодаМинута = 1;
	ВидПериодаЧас	 = 2;
	ВидПериодаДень	 = 3;
	ВидПериодаМесяц	 = 4;
	ВидПериодаГод	 = 5;

	ШагСменыДат = 1;	// В секундах

	#Область ГраницыПериода

	Если Период = "" Тогда
		ВидПериода = ВидПериодаЛюбой;
	ИначеЕсли ВРег(Период) = ВРег("День") Тогда
		ВидПериода = ВидПериодаДень;
	ИначеЕсли ВРег(Период) = ВРег("Месяц") Тогда
		ВидПериода = ВидПериодаМесяц;
	ИначеЕсли ВРег(Период) = ВРег("Год") Тогда
		ВидПериода = ВидПериодаГод;
	ИначеЕсли ВРег(Период) = ВРег("Час") Тогда
		ВидПериода = ВидПериодаЧас;
	ИначеЕсли ВРег(Период) = ВРег("Минута") Тогда
		ВидПериода = ВидПериодаМинута;
	Иначе
		ВызватьИсключение "Параметр Период: Неожиданное значение";
	КонецЕсли; 

	ПроверятьГраницыПериода = (ВидПериода <> ВидПериодаЛюбой);	// Для проверки выхода даты за день/месяц/год
	НижниеГраницыДат = Новый Соответствие;	// Для контроля допустимого общего периода дат
	ВерхниеГраницыДат = Новый Соответствие;	// Для контроля допустимого общего периода дат
	Если ПроверятьГраницыПериода Тогда
		ВсегоДатВПериоде = 60 * 60 * 24 / ШагСменыДат;
		Если КоличествоДат > ВсегоДатВПериоде Тогда
			ВызватьИсключение "Слишком много дат для распределения в рамках периода"; // Пока не хочется писать проверку. // #СДЕЛАТЬ
		КонецЕсли;
	КонецЕсли;
	
	#КонецОбласти // ГраницыПериода

	НаправлениеОбходаВперед = 1;
	НаправлениеОбходаНазад = -1;

	МинимальнаяДата	 = ИсходныеДаты[0];
	МаксимальнаяДата = ИсходныеДаты[0];
	МаксимальныйИндекс = ИсходныеДаты.ВГраница();
	Для Индекс = 0 По МаксимальныйИндекс Цикл
		ТекущаяДата = ИсходныеДаты[Индекс];
		Если ТипЗнч(ТекущаяДата) <> Тип("Дата") Тогда
			ВызватьИсключение СтрШаблон(
				"Параметр ИсходныеДаты[%1]: Ожидается тип Дата", 
				XMLСтрока(Индекс)
			);
		КонецЕсли;
		ДатыПоХронологии[Индекс] = ИсходныеДаты[Индекс];
		МинимальнаяДата = Мин(МинимальнаяДата, ТекущаяДата);
		МаксимальнаяДата = Макс(МаксимальнаяДата, ТекущаяДата);
	КонецЦикла;
	МаксимальнаяДата = Макс(МаксимальнаяДата, МинимальнаяДата + ШагСменыДат * (КоличествоДат - 1));

	КонтролироватьКоличествоДатПериода = Истина;
	Если ПроверятьГраницыПериода Тогда
		Если КонтролироватьКоличествоДатПериода Тогда
			ЕмкостьПериодов = Новый Соответствие;
		КонецЕсли;
		Для каждого ТекущаяДата Из ИсходныеДаты Цикл
			НижняяГраницаДаты = ТекущаяДата;
			ВерхняяГраницаДаты = ТекущаяДата;
			Если ВидПериода = ВидПериодаДень Тогда
				НижняяГраницаДаты = НачалоДня(ТекущаяДата);
				ВерхняяГраницаДаты = КонецДня(ТекущаяДата);
			ИначеЕсли ВидПериода = ВидПериодаМесяц Тогда
				НижняяГраницаДаты = НачалоМесяца(ТекущаяДата);
				ВерхняяГраницаДаты = КонецМесяца(ТекущаяДата);
			ИначеЕсли ВидПериода = ВидПериодаГод Тогда
				НижняяГраницаДаты = НачалоГода(ТекущаяДата);
				ВерхняяГраницаДаты = КонецГода(ТекущаяДата);
			ИначеЕсли ВидПериода = ВидПериодаЧас Тогда
				НижняяГраницаДаты = НачалоЧаса(ТекущаяДата);
				ВерхняяГраницаДаты = КонецЧаса(ТекущаяДата);
			ИначеЕсли ВидПериода = ВидПериодаМинута Тогда
				НижняяГраницаДаты = НачалоМинуты(ТекущаяДата);
				ВерхняяГраницаДаты = КонецМинуты(ТекущаяДата);
			Иначе
				ВызватьИсключение "Неожиданное поведение";
			КонецЕсли;
			НижняяГраницаДаты = Макс(МинимальнаяДата, НижняяГраницаДаты);
			ВерхняяГраницаДаты = Мин(МаксимальнаяДата, ВерхняяГраницаДаты);
			НижниеГраницыДат[ТекущаяДата] = НижняяГраницаДаты;
			ВерхниеГраницыДат[ТекущаяДата] = ВерхняяГраницаДаты;
			Если КонтролироватьКоличествоДатПериода Тогда
				ЕмкостьПериода = ЕмкостьПериодов[НижняяГраницаДаты];
				Если ЕмкостьПериода = Неопределено Тогда
					ЕмкостьПериода = 0;
				КонецЕсли;
				ЕмкостьПериода = ЕмкостьПериода + 1;
				ЕмкостьПериодов[НижняяГраницаДаты] = ЕмкостьПериода;
				Если ЕмкостьПериода > Цел((ВерхняяГраницаДаты - НижняяГраницаДаты) / ШагСменыДат) Тогда
					ВызватьИсключение "Слишком много дат, чтобы разместить в периоде " + ТРег(Период);
				КонецЕсли;	
			КонецЕсли;
		КонецЦикла;
	Иначе
		Для каждого ТекущаяДата Из ИсходныеДаты Цикл
			НижниеГраницыДат[ТекущаяДата] = МинимальнаяДата;
			ВерхниеГраницыДат[ТекущаяДата] = МаксимальнаяДата;
		КонецЦикла;
	КонецЕсли;

	Индекс = 0;
	МассивДатОтсортирован = Истина;
	НаправлениеОбхода = НаправлениеОбходаВперед;
	Пока Истина Цикл

		ИсходнаяДата = ИсходныеДаты[Индекс];
		ТекущаяДата = ДатыПоХронологии[Индекс];
		НижняяГраницаДаты = НижниеГраницыДат[ИсходнаяДата];
		ВерхняяГраницаДаты = ВерхниеГраницыДат[ИсходнаяДата];

		ЭтоОбходВперед = (НаправлениеОбхода = НаправлениеОбходаВперед);

		ЭтоПервыйЭлемент = (Индекс = ?(ЭтоОбходВперед, 0, МаксимальныйИндекс));

		Если ЭтоПервыйЭлемент Тогда 
			ПредыдущаяДата = ?(ЭтоОбходВперед,
				НижняяГраницаДаты - ШагСменыДат,
				ВерхняяГраницаДаты + ШагСменыДат);
		Иначе
			ПредыдущаяДата = ДатыПоХронологии[Индекс - 1 * НаправлениеОбхода];
		КонецЕсли;

		// Нижняя граница или предыдущий элемент
		ЭлементОтсортирован = ((ТекущаяДата - ПредыдущаяДата) * НаправлениеОбхода) > 0; // Верно для обоих обходов
		Если Не ЭлементОтсортирован Тогда
			НоваяДата = ПредыдущаяДата + ШагСменыДат * НаправлениеОбхода;
			ДатыПоХронологии[Индекс] = НоваяДата;
			МассивДатОтсортирован = Ложь;
			Продолжить;
		КонецЕсли;

		// Верхняя граница
		НадоРазвернутьОбход = Ложь;
		ГраницаДаты = ?(ЭтоОбходВперед, ВерхняяГраницаДаты, НижняяГраницаДаты);
		ТекущаяДатаВыходитЗаГраницу = ((ТекущаяДата - ГраницаДаты) * НаправлениеОбхода) > 0;
		Если ТекущаяДатаВыходитЗаГраницу Тогда
			ДатыПоХронологии[Индекс] = ГраницаДаты;
			МассивДатОтсортирован = Ложь;
			НадоРазвернутьОбход = Истина;
		КонецЕсли;

		// Последний элемент и условие выхода из цикла
		ЭтоПоследнийЭлемент = (Индекс = ?(ЭтоОбходВперед, МаксимальныйИндекс, 0));
		Если ЭтоПоследнийЭлемент Тогда
			Если МассивДатОтсортирован Тогда
				Прервать; // Всё отсортировали.
			Иначе
				НадоРазвернутьОбход = Истина;
			КонецЕсли;
		КонецЕсли;

		Если НадоРазвернутьОбход Тогда 
			НаправлениеОбхода = ?(ЭтоОбходВперед, НаправлениеОбходаНазад, НаправлениеОбходаВперед);
			МассивДатОтсортирован = Истина;
			Продолжить;	// Чтобы повторно обработать этот элемент
		КонецЕсли;

		Индекс = Индекс + 1 * НаправлениеОбхода;

	КонецЦикла;

	ИсходныеДаты = ДатыПоХронологии;

	Возврат ДатыПоХронологии;
	
КонецФункции // РаспределитьДатыПоХронологии()

#КонецОбласти // ПримитивныеТипы

// Работает аналогично ЗаполнитьЗначенияСвойств(),
// но позволяет поменять имена свойств приёмника.
// Служит для того, когда имена свойств источника и приёмника отличаются
//
// Параметры:
//	Источник			 - Произвольный - Объект-источник.
//	Приемник			 - Произвольный - Объект-приемник.
//	СвойстваИсточника	 - Строка - Перечень имён свойств источника.
//	СвойстваПриемника	 - Строка - Перечень имён свойств приемника.
//	ПереноситьПрочие	 - Булево - Переносить свойства с именами, не указанными в СвойстваИсточника.
//	ИсключаяСвойства	 - Строка - Имена свойств, которые переносить не следует. 
//									Используется, если ПереноситьПрочие = Истина.
//
// Пример:
//	Источник = Новый Структура("Раз, Два, Три, Четыре, Пять", 1, 2, 3, 4, 5);
//	Приемник = Новый Структура("Раз, Два, Три, Четыре, Пять");
//	ПеренестиЗначенияСвойств(
//		Источник,
//		Приемник,
//		"Раз, Два, Три",
//		"Раз, Три, Два",
//		Истина,
//		"Пять");	// Приемник станет Структура("Раз, Два, Три, Четыре, Пять", 1, 3, 2, 4, Неопределено)
//
Процедура ПеренестиЗначенияСвойств(
	Источник, 
	Приемник, 
	СвойстваИсточника = "", 
	СвойстваПриемника = "", 
	ПереноситьПрочие = Ложь, 
	ИсключаяСвойства = "")
	
	Если Не ЗначениеЗаполнено(СвойстваИсточника)
		И Не ЗначениеЗаполнено(СвойстваПриемника)
		И Не ПереноситьПрочие Тогда
		Возврат;
	КонецЕсли;

	КлючиИсточника = СтрРазделить(СвойстваИсточника, ", ", Ложь);
	КлючиПриемника = СтрРазделить(СвойстваИсточника, ", ", Ложь);

	Если КлючиИсточника.Количество() <> КлючиПриемника.Количество() Тогда
		ВызватьИсключение "Различается количество указанных ключей источника и приемника";
	КонецЕсли;

	Если ПереноситьПрочие Тогда

		// Для ситуаций, когда ключи источника присутствуют в приемнике,
		// но значения этих ключей переносятся на другие позиции,
		// что избежать изменения значения этих ключей,
		// Мы резервируем ключи Приемника, которые присутствуют в Источнике.
		ЗначенияПриемникаРезерв	 = Новый Структура;
		Для каждого Ключ Из КлючиИсточника Цикл
			ЗначенияПриемникаРезерв.Вставить(Ключ);
		КонецЦикла;
		ЗаполнитьЗначенияСвойств(ЗначенияПриемникаРезерв, Приемник);
		ЗаполнитьЗначенияСвойств(Приемник, Источник, , ИсключаяСвойства);
		ЗаполнитьЗначенияСвойств(Приемник, ЗначенияПриемникаРезерв);

	КонецЕсли;

	Если ЗначениеЗаполнено(КлючиИсточника) Тогда
		Для Индекс = 0 По СвойстваИсточника.ВГраница() Цикл
			Приемник[КлючиПриемника[Индекс]] = Источник[КлючиИсточника[Индекс]];
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры

#Область Коллекции

#Область ДревовидныеКоллекции

// Получает коллекцию подчиненных элементов
//
// Параметры:
//  Узел - ДанныеФормыДерево, ДанныеФормыЭлементДерева, ДеревоЗначений, СтрокаДереваЗначений - Узел или корень дерева
//
// Возвращаемое значение:
//   - ДанныеФормыКоллекцияЭлементовДерева, КоллекцияСтрокДереваЗначений
//
Функция ВетвиДерева(Узел)

	ЭтоЭлементДереваФормы = ТипЗнч(Узел) = Тип("ДанныеФормыЭлементДерева")
		Или ТипЗнч(Узел) = Тип("ДанныеФормыДерево");
		
	Возврат ?(ЭтоЭлементДереваФормы, Узел.ПолучитьЭлементы(), Узел.Строки)

КонецФункции // ВетвиДерева()

// Проверяет, является ли Узел элементом древовидной коллекции
//
// Параметры:
//  Узел - ДанныеФормыДерево, ДанныеФормыЭлементДерева, ДеревоЗначений, СтрокаДереваЗначений - Узел или корень дерева
//
// Возвращаемое значение:
//   - Булево
//
Функция ЭтоУзелДерева(Узел)
	ЭтоУзелДерева = ТипЗнч(Узел) = Тип("ДанныеФормыЭлементДерева");
	#Если Сервер Тогда
		ЭтоУзелДерева = ЭтоУзелДерева ИЛИ ТипЗнч(Узел) = Тип("СтрокаДереваЗначений");
	#КонецЕсли
	Возврат ЭтоУзелДерева;
КонецФункции	// ЭтоУзелДерева()

// Проверяет, является ли Узел листом древовидной коллекции
//
// Параметры:
//  Узел - ДанныеФормыДерево, ДанныеФормыЭлементДерева, Произвольный - Узел дерева
//
// Возвращаемое значение:
//   Булево - Признак того что проверяемый узел не имеет дочерних узлов.
//
Функция ЭтоЛистДерева(Узел)

	Если ТипЗнч(Узел) = Тип("ДанныеФормыЭлементДерева") Тогда
		Возврат Не ЗначениеЗаполнено(Узел.ПолучитьЭлементы());
	КонецЕсли;

	#Если Сервер Тогда
	Если ТипЗнч(Узел) = Тип("СтрокаДереваЗначений") Тогда
		Возврат Не ЗначениеЗаполнено(Узел.Строки);
	КонецЕсли;
	#КонецЕсли

	Возврат Ложь;

КонецФункции	// ЭтоЛистДерева()

// Проверяет, является ли Узел элементом древовидной коллекции формы
//
// Параметры:
//  Узел - ДанныеФормыДерево, ДанныеФормыЭлементДерева, ДеревоЗначений, СтрокаДереваЗначений - Узел или корень дерева
//
// Возвращаемое значение:
//   - Булево
//
Функция ЭтоЭлементДереваФормы(Узел)

	Возврат ТипЗнч(Узел) = Тип("ДанныеФормыЭлементДерева")
		ИЛИ ТипЗнч(Узел) = Тип("ДанныеФормыДерево")

КонецФункции // ЭтоЭлементДереваФормы()

// Получает конечные элементы предоставленной коллекции
//
// Параметры:
//  Узел	 - ДанныеФормыДерево, ДанныеФормыЭлементДерева, ДеревоЗначений, СтрокаДереваЗначений
//	Отбор	 - Структура - Отбор получаемых листьев дерева.
//
// Возвращаемое значение:
//   - Массив из ДанныеФормыЭлементДерева
//	 - Массив из СтрокаДереваЗначений
//
Функция ЛистьяДерева(Узел, Отбор = Неопределено) Экспорт

	ВозвращаемоеЗначение = Новый Массив;
	Коллекция = ВетвиДерева(Узел);
	Если ЗначениеЗаполнено(Коллекция) Тогда
		Для каждого Ветвь Из Коллекция Цикл
			Для каждого Лист Из ЛистьяДерева(Ветвь, Отбор) Цикл 
				ВозвращаемоеЗначение.Добавить(Лист);
			КонецЦикла;
		КонецЦикла;
	ИначеЕсли ЭтоУзелДерева(Узел) Тогда
		Если Отбор = Неопределено Тогда
			ВозвращаемоеЗначение.Добавить(Узел)
		Иначе
			УзелСоответствуетОтбору = Истина;
			Для каждого Элемент Из Отбор Цикл
				Если Узел[Элемент.Ключ] <> Элемент.Значение Тогда
					УзелСоответствуетОтбору = Ложь;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если УзелСоответствуетОтбору Тогда
				ВозвращаемоеЗначение.Добавить(Узел);
			КонецЕсли;
		КонецЕсли;
	Иначе
		ВызватьИсключение "Что-то пошло не так.";
	КонецЕсли;

	Возврат ВозвращаемоеЗначение;

КонецФункции // ЛистьяДерева()

// Получает поля листьев дерева
//
// Параметры:
//  Узел						 - ДанныеФормыДерево, ДанныеФормыЭлементДерева	 - Исходный узел.
//  Поля						 - Строка										 - Имена получаемых полей.
//  Отбор						 - Структура									 - Отбор узлов для получения.
//
// Возвращаемое значение:
//  Массив - Структуры данных
//
Функция ПоляЛистьевДерева(Узел, Поля = "", Отбор = Неопределено) Экспорт

	ЕстьОтбор = Отбор <> Неопределено;

	КоллекцияДанных = Новый Массив;
	КоллекцияПодчиненных = ВетвиДерева(Узел);

	Листья = ?(ЕстьОтбор, КоллекцияПодчиненных.НайтиСтроки(Отбор, Истина), ЛистьяДерева(Узел));

	Для каждого Лист Из Листья Цикл
		Если ЕстьОтбор И Не ЭтоЛистДерева(Лист) Тогда 
			Продолжить; 
		КонецЕсли;	// По отбору могут быть подобраны узлы, имеющие подчиненные элементы.
		СтруктураДанных = Новый Структура(Поля);
		ЗаполнитьЗначенияСвойств(СтруктураДанных, Лист);
		КоллекцияДанных.Добавить(СтруктураДанных);
	КонецЦикла;

	Возврат КоллекцияДанных;

КонецФункции // ПоляЛистьевДерева()

// Получает поля элементов дерева
//
// Параметры:
//  Узел						 - ДанныеФормыДерево, ДанныеФормыЭлементДерева	 -
//  Поля						 - Строка										 - Имена полей, через запятую
//  Отбор						 - Структура									 - Какие элементы опрашиваются
//
// Возвращаемое значение:
//  Массив - Структуры данных
//
Функция ПоляДанныхДереваРекурсивно(Узел, Поля = "Идентификатор, ИдентификаторСтроки", Отбор = Неопределено) Экспорт

	КоллекцияДанных = Новый Массив;

	Если ЭтоУзелДерева(Узел) и ЭлементСоответствуетОтбору(Узел, Отбор) Тогда
		СтруктураДанных = Новый Структура(Поля);
		ЗаполнитьЗначенияСвойств(СтруктураДанных, Узел);
		Если СтруктураДанных.Свойство("ИдентификаторСтроки") и ЭтоЭлементДереваФормы(Узел) Тогда
			СтруктураДанных.ИдентификаторСтроки = Узел.ПолучитьИдентификатор();
		КонецЕсли;
		КоллекцияДанных.Добавить(СтруктураДанных);
	КонецЕсли;

	Коллекция = ВетвиДерева(Узел);

	Для каждого Ветвь Из Коллекция Цикл
		ДанныеПодчиненных = ПоляДанныхДереваРекурсивно(Ветвь, Поля, Отбор); 
		Для каждого СтруктураДанных Из ДанныеПодчиненных Цикл
			КоллекцияДанных.Добавить(СтруктураДанных);
		КонецЦикла;
	КонецЦикла;

	Возврат КоллекцияДанных;

КонецФункции // ПоляДанныхДереваРекурсивно() 

#КонецОбласти // ДревовидныеКоллекции

#Область Массив

// Преобразует коллекцию в двумерный массив (массив массивов)
//
// Параметры:
//  ИсходнаяКоллекция		 - Произвольный	 - Любая коллекция, доступная для обхода "Для каждого ... Цикл". 
//  РазмерВложенногоМассива	 - Число		 - Максимальное количество элементов вложенного массива.
// 
// Возвращаемое значение:
//  Массив - Результирующий массив.
//
Функция ДвумерныйМассивИзКоллекции(Знач ИсходнаяКоллекция, Знач РазмерВложенногоМассива = 1)
	
	МаксИндексВложенногоМассива = РазмерВложенногоМассива - 1;
	ДвумерныйМассив = Новый Массив;
	ИндексВложенногоМассива = -1;
	Для каждого ТекущийЭлемент Из ИсходнаяКоллекция Цикл
		ИндексВложенногоМассива = ИндексВложенногоМассива + 1;
		Если ИндексВложенногоМассива > МаксИндексВложенногоМассива Тогда ИндексВложенногоМассива = 0 КонецЕсли; 
		Если ИндексВложенногоМассива = 0 Тогда
			ВложенныйМассив = Новый Массив;
			ДвумерныйМассив.Добавить(ВложенныйМассив);
		КонецЕсли; 
		ВложенныйМассив.Добавить(ТекущийЭлемент);
	КонецЦикла;
	
	Возврат ДвумерныйМассив;
	
КонецФункции // ДвумерныйМассивИзКоллекции

// Проверяет наличие пересечения массивов
//
// Параметры:
//	ПервыйМассив	 - Массив
//	ВторойМассив	 - Массив
//
// Возвращаемое значение:
//	Булево	 - Истина, если есть хотя бы один общий элемент.
//
Функция ЕстьПересечениеМассивов(ПервыйМассив, ВторойМассив) Экспорт

	Для каждого ТекущийЭлемент Из ПервыйМассив Цикл
		Если ВторойМассив.Найти(ТекущийЭлемент) <> Неопределено Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;

	Возврат Ложь;
	
КонецФункции // ЕстьПересечениеМассивов

// Возвращает заполненные значения из переданного массива.
//
// Параметры:
//	Массив - Массив
//
// Возвращаемое значение:
//	Массив - Заполненные значения в порядке следования в исходном массиве.
//
Функция ЗаполненныеЗначенияМассива(Массив) Экспорт
	
	МассивЗаполненных = Новый Массив;
	Для каждого Значение Из Массив Цикл
		Если ЗначениеЗаполнено(Значение) Тогда
			МассивЗаполненных.Добавить(Массив);
		КонецЕсли;
	КонецЦикла;
	Возврат МассивЗаполненных;

КонецФункции // ЗаполненныеЗначенияМассива()

// Формирует массив и помещает в него переданное значение
//
// Параметры:
//	Значение - Произвольный
//
// Возвращаемое значение:
//	Массив
//
Функция МассивИзЗначения(Значение) Экспорт

	Массив = Новый Массив;
	Массив.Добавить(Значение);
	Возврат Массив;
	
КонецФункции

// BSLLS:NumberOfOptionalParams-off
// BSLLS:NumberOfParams-off
// BSLLS:MissingParameterDescription-off

// Формирует массив из заданных значений
//
// Параметры:
//	Элемент0..N	 - Произвольный - Элемент для помещения в массив
//
// Возвращаемое значение:
//	Массив
//
// Примеры:
//	МассивЗначений(1, 2, 3);	// {1, 2, 3}
//	МассивЗначений(1, Null, 3, Null); // {1, Null, 3} // Последний Null всегда отбрасывается
//
Функция МассивЗначений(
	Элемент0 = Null,
	Элемент1 = Null,
	Элемент2 = Null,
	Элемент3 = Null,
	Элемент4 = Null,
	Элемент5 = Null,
	Элемент6 = Null,
	Элемент7 = Null,
	Элемент8 = Null,
	Элемент9 = Null) Экспорт

	КоличествоПараметровФункции = 10;
	ПустойЭлемент = Null;

	Массив = Новый Массив;

	ДобавляемЭлементы = Ложь;
	Для ОбратныйИндексПараметра = - КоличествоПараметровФункции + 1 По 0 Цикл
		ИндексПараметра = - ОбратныйИндексПараметра;
		ИндексСтрокой = XMLСтрока(ИндексПараметра);
		ТекущийЭлемент = Вычислить(СтрШаблон("Элемент%1", ИндексСтрокой));
		ДобавляемЭлементы = ДобавляемЭлементы Или (ТекущийЭлемент <> ПустойЭлемент);
		Если ДобавляемЭлементы Тогда
			Массив.Вставить(0, ТекущийЭлемент);
		КонецЕсли;
	КонецЦикла;

	Возврат Массив;

	
КонецФункции // МассивЗначений

// BSLLS:NumberOfOptionalParams-on
// BSLLS:NumberOfParams-on
// BSLLS:MissingParameterDescription-on


// Раскладывает строку на массив символов
// 
// Параметры:
//	ИсходнаяСтрока - Строка
//
// Возвращаемое значение:
//	Массив из Строка
//
Функция МассивСимволовИзСтроки(ИсходнаяСтрока) Экспорт

	ДлинаСтроки = СтрДлина(ИсходнаяСтрока);
	МассивСимволов = Новый Массив(ДлинаСтроки);
	Для Индекс = 0 По ДлинаСтроки - 1 Цикл
		МассивСимволов.Установить(Индекс, Сред(ИсходнаяСтрока, Индекс + 1, 1));
	КонецЦикла;

	Возврат МассивСимволов;

КонецФункции // МассивСимволовИзСтроки()

// Находит общие элементы для двух массивов
//
// Параметры:
//	ПервыйМассив	 - Массив
//	ВторойМассив	 - Массив
//
// Возвращаемое значение:
//	Массив	 - Общие элементы в порядке следования в коллекции ПервыйМассив
//
Функция ПересечениеМассивов(ПервыйМассив, ВторойМассив) Экспорт

	Пересечение = Новый Массив;

	Если Не ЗначениеЗаполнено(ПервыйМассив) Или Не ЗначениеЗаполнено(ВторойМассив) Тогда
		Возврат Пересечение;
	КонецЕсли;

	Для каждого ТекущийЭлемент Из ПервыйМассив Цикл
		Если ВторойМассив.Найти(ТекущийЭлемент) <> Неопределено Тогда
			Пересечение.Добавить(ТекущийЭлемент);
			Продолжить;
		КонецЕсли;
	КонецЦикла;

	Возврат Пересечение;
	
КонецФункции // ПересечениеМассивов

// Вырезает элементы из массива, и на их место вставляет новые элементы.
//
// Параметры:
//  Массив				 - Массив	 - Массив, из которого вырезаются/вставляются элементы.
//  Индекс				 - Число	 - Индекс первого удаляемого элемента, а также вставки элементов.
//  КоличествоУдаляемых	 - Число	 - Количество удаляемых элементов массива.
//  Вставка				 - Массив, Произвольный	 - Вставляемые элементы. 
//										Если указано значение типа, отличного от Массив, оно будет вставлено по указанному указанному индексу.
//										Если требуется вставить Массив или Неопределено в качестве элемента - следует передать его в качестве вложенного в массив.
// 
// Возвращаемое значение:
//  Массив - Удаленные элементы
//
Функция СраститьМассив(Массив, Индекс = 0, КоличествоУдаляемых = 0, Вставка = Неопределено) Экспорт

	Удаленные = Новый Массив;
	ОсталосьУдалить = КоличествоУдаляемых;
	
	Пока ОсталосьУдалить Цикл
		Удаленные.Добавить(Массив[Индекс]);
		Массив.Удалить(Индекс);
		ОсталосьУдалить = ОсталосьУдалить - 1;
	КонецЦикла;   
	
	Если Вставка <> Неопределено Тогда
	
		Если ТипЗнч(Вставка) = Тип("Массив") Тогда
			Для каждого Элемент Из Вставка Цикл
				Массив.Вставить(Индекс, Элемент);	
			КонецЦикла; 	
		Иначе
			Массив.Вставить(Индекс, Вставка);	
		КонецЕсли; 
	
	КонецЕсли; 
	
	Возврат Удаленные;

КонецФункции // СраститьМассив()

// Удаляет незаполненные значения из массива.
// Заполненность значений проверяется методом ЗначениеЗаполнено()
// 
// Параметры:
//	Массив				 - Массив из Произвольный - Массив элементов.
//	ИгнорируемыеЗначения - Массив из Произвольный - Значения, которые следует оставить при проверке
//
Процедура УдалитьНезаполненныеЗначенияМассива(Массив, Знач ИгнорируемыеЗначения = Неопределено)

	Если ИгнорируемыеЗначения = Неопределено Тогда
		ИгнорируемыеЗначения = Новый Массив;
	КонецЕсли;

	Для ДопИндекс = - Массив.ВГраница() По 0 Цикл

		Индекс = - ДопИндекс;
		ЭлементМассива = Массив[Индекс];
		Если Не ЗначениеЗаполнено(ЭлементМассива) 
			И ИгнорируемыеЗначения.Найти(ЭлементМассива) = Неопределено Тогда

			Массив.Удалить(Индекс);

		КонецЕсли;

	КонецЦикла;
	
КонецПроцедуры // УдалитьНезаполненныеЗначенияМассива()

#КонецОбласти	// Массив

#Область Структура

// Проверяет наличие свойства структуры.
// Если оно присутствует, возвращает его.
// Если отсутствует -- создаёт.
//
// Параметры:
//	Структура	 - Структура	 - Проверяемая структура.
//	Ключ		 - Строка		 - Искомый ключ
//	Значение	 - Произвольный	 - Ожидаемое значение. 
//								 Если ключ присутствует в структуре, будет установлено из ключа
// Возвращаемое значение:
//	Произвольный - Значение по ключу структуры, или значение параметра Значение, если ключ отсутствует.
//
Функция ОбеспечитьСвойствоСтруктуры(Структура, Ключ, Значение = Неопределено) Экспорт
	
	Если ТипЗнч(Структура) <> Тип("Структура") Тогда
		ВызватьИсключение "Параметр Структура: Ожидается тип Структура";
	КонецЕсли;

	Если Не Структура.Свойство(Ключ) Тогда
		Структура.Вставить(Ключ, Значение);
	Иначе
		Значение = Структура[Ключ];
	КонецЕсли;

	Возврат Структура[Ключ]; 

КонецФункции // ОбеспечитьСвойствоСтруктуры()

#КонецОбласти // Структура

// Вычисляет агрегатную функцию по значениям коллекции
//
// Параметры:
//	Коллекция			 - Произвольный	 - Коллекция, для которой доступен обход "Для Каждого ... Из ... Цикл"
//	АгрегатнаяФункция	 - Строка		 - Агрегатная функция. Допустимые значения:
//		* Сумм[а]
//		* Сред[нее]
//		* Мин[имум]
//		* Макс[имум]
//		* Кол[ичество]
//		* [Количество] Разл[ичные]
//	Поле				 - Строка	 - Имя поля коллекции
//						 - Число	 - Индекс поля коллекции
//						Может быть не указано, если в качестве коллекции выступает Массив
//
// Возвращаемое значение:
//	Число - ТекущееЗначение вычисленной функции		
//
Функция АгрегатКоллекции(Знач Коллекция, АгрегатнаяФункция = "Сумма", Поле = Неопределено) Экспорт

	Если Не ЗначениеЗаполнено(Коллекция) Тогда
		Возврат 0;
	КонецЕсли;

	// Функция:
	ЭтоСумма		 = Ложь;
	ЭтоСреднее		 = Ложь;
	ЭтоМинимум		 = Ложь;
	ЭтоМаксимум		 = Ложь;
	ЭтоКоличество	 = Ложь;
	ЭтоРазличные	 = Ложь;
	АгрегатнаяФункцияВрег = ВРег(АгрегатнаяФункция);
	Если СтрНачинаетсяС(АгрегатнаяФункцияВрег, "СУММ") Тогда
		ЭтоСумма		 = Истина;

	ИначеЕсли СтрНачинаетсяС(АгрегатнаяФункцияВрег, "СРЕД") Тогда
		ЭтоСреднее		 = Истина;

	ИначеЕсли СтрНачинаетсяС(АгрегатнаяФункцияВрег, "МИН") Тогда
		ЭтоМинимум		 = Истина;

	ИначеЕсли СтрНачинаетсяС(АгрегатнаяФункцияВрег, "МАКС") Тогда
		ЭтоМаксимум		 = Истина;

	ИначеЕсли СтрНайти(АгрегатнаяФункцияВрег, "РАЗЛ") Тогда
		ЭтоРазличные	 = Истина;

	ИначеЕсли СтрНачинаетсяС(АгрегатнаяФункцияВрег, "КОЛ") Тогда
		ЭтоКоличество	 = Истина;

	Иначе
		ВызватьИсключение "Параметр АгрегатнаяФункция: Непредвиденное значение";
	
	КонецЕсли;

	Агрегат				 = Неопределено;
	ЭтоАгрегатСравнения	 = ЭтоМинимум Или ЭтоМаксимум;
	ЭтоПервыйЭлемент	 = Истина;
	КоличествоЭлементов	 = 0;
	РазличныеЗначения = Новый Массив();
	Для каждого ЭлементКоллекции Из Коллекция Цикл

		ТекущееЗначение = ?(Поле = Неопределено, ЭлементКоллекции, ЭлементКоллекции[Поле]);
		Если ЭтоПервыйЭлемент Тогда
			Если ЭтоАгрегатСравнения Тогда
				Агрегат = ТекущееЗначение;
			Иначе
				Агрегат = 0;
			КонецЕсли;
			ЭтоПервыйЭлемент = Ложь;
		КонецЕсли;

		Если ЭтоСумма Или ЭтоСреднее Тогда
			Агрегат = Агрегат + ТекущееЗначение;

		ИначеЕсли ЭтоМинимум Тогда
			Агрегат = Мин(Агрегат, ТекущееЗначение);

		ИначеЕсли ЭтоМаксимум Тогда
			Агрегат = Макс(Агрегат, ТекущееЗначение);

		ИначеЕсли ЭтоКоличество Тогда
			Агрегат = Агрегат + 1;

		ИначеЕсли ЭтоРазличные Тогда
			Если РазличныеЗначения.Найти(ТекущееЗначение) = Неопределено Тогда
				РазличныеЗначения.Добавить(ТекущееЗначение);
			КонецЕсли;

		Иначе
			Прервать;	// Обработано исключением выше

		КонецЕсли;

		КоличествоЭлементов = КоличествоЭлементов + 1;

	КонецЦикла;

	ЗначениеПосчитаноВАгрегате = ЭтоСумма Или ЭтоМинимум Или ЭтоМаксимум Или ЭтоКоличество;
	Если ЗначениеПосчитаноВАгрегате Тогда
		ЗначениеАгрегата = Агрегат;

	ИначеЕсли ЭтоСреднее Тогда
		ЗначениеАгрегата = Агрегат / КоличествоЭлементов;

	ИначеЕсли ЭтоРазличные Тогда
		ЗначениеАгрегата = РазличныеЗначения.Количество();

	Иначе
		ЗначениеАгрегата = 0;
	КонецЕсли;

	Возврат ЗначениеАгрегата;

КонецФункции // АгрегатКоллекции()

// Выгружает ключи из структуры или соответствия
// 
// Параметры:
//	Коллекция - Структура, Соответствие
//
// Возвращаемое значение:
//	Массив - Ключи коллекции.
//
Функция ВыгрузитьКлючиКоллекции(Коллекция) Экспорт

	Выгрузка = Новый Массив;
	Для каждого КлючЗначение Из Коллекция Цикл
		Выгрузка.Добавить(КлючЗначение.Ключ);
	КонецЦикла;

	Возврат Выгрузка;

КонецФункции // ВыгрузитьКлючиКоллекции

// Выгружает значения из структуры или соответствия
// 
// Параметры:
//	Коллекция - Структура, Соответствие
//
// Возвращаемое значение:
//	Массив - Значения коллекции.
//
Функция ВыгрузитьЗначенияКоллекции(Коллекция) Экспорт

	Выгрузка = Новый Массив;
	Для каждого КлючЗначение Из Коллекция Цикл
		Выгрузка.Добавить(КлючЗначение.Значение);
	КонецЦикла;

	Возврат Выгрузка;

КонецФункции // ВыгрузитьЗначенияКоллекции

// Производит поиск в однородной коллекции, состоящих из элементов с полями (например, Массив из Структура)
//
// Параметры:
//  Коллекция 		 - Произвольный	 - Коллекция, поддерживающая обход "Для Каждого ..."
//  ПараметрыПоиска  - Структура:
//		* Ключ			 - Поле элемента коллекции, в котором производится поиск
//		* Значение		 - Искомое значение
//					 - Произвольный	 - Искомое значение
//  ПоляПоиска 		 - Строка		 - Поля элемента коллекции, в которых производится поиск, через запятую.
//									 Поиск производится по значению в любом из указанных полей.
//									 Если указана пустая строка, проверяются все поля элементов коллекции.
//	Лимит			 - Число		 - Поиск вернет лишь указанное число значений
//
// Варианты вызова:
//	НайтиЭлементыКоллекции(Произвольный, Структура)				 - Поиск по значениям нескольких полей.
//	НайтиЭлементыКоллекции(Произвольный, Произвольный, Строка)	 - Поиск по значению в любом поле из указанных.
//
// Возвращаемое значение:
//   Массив   - Найденные элементы коллекции
//
Функция НайтиЭлементыКоллекции(
	Коллекция, 
	Знач ПараметрыПоиска, 
	Знач ПоляПоиска = Неопределено, 
	Лимит = Неопределено) Экспорт
	
	НайденныеЭлементы = Новый Массив;
	
	Если Не ЗначениеЗаполнено(Коллекция) Тогда
		Возврат НайденныеЭлементы;
	КонецЕсли;

	ЭтоПоискПоОдномуЗначению = ПоляПоиска <> Неопределено;
	Если ЭтоПоискПоОдномуЗначению Тогда
		ПоляПоиска = СтрРазделить(ПоляПоиска, ", ", Ложь);
		ИскомоеЗначение = ПараметрыПоиска;
	КонецЕсли;

	// Для пустого отбора - пустой результат, как для ТаблицаЗначений.НайтиСтроки():
	Если Не ЭтоПоискПоОдномуЗначению И Не ЗначениеЗаполнено(ПараметрыПоиска) Тогда
		Возврат НайденныеЭлементы;
	КонецЕсли;
	
	НайденоЭлементов = 0;
	Для каждого ЭлементКоллекции Из Коллекция Цикл
		
		Если Лимит <> Неопределено И НайденоЭлементов = Лимит Тогда
			Прервать;
		КонецЕсли;

		Если ЭтоПоискПоОдномуЗначению И ЗначениеЗаполнено(ПоляПоиска) Тогда

			ЭлементСоответствуетОтбору = Ложь;
			Для каждого ИмяПоля Из ПоляПоиска Цикл
				Если ЭлементКоллекции[ИмяПоля] = ИскомоеЗначение Тогда
					ЭлементСоответствуетОтбору = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;	
				
		ИначеЕсли ЭтоПоискПоОдномуЗначению И Не ЗначениеЗаполнено(ПоляПоиска) Тогда

			// При незаполненных полях поиска пытаемся проверить все поля элементов коллекции.
			ЭлементСоответствуетОтбору = Ложь;
			Для каждого ПолеЭлементаКоллекции Из ЭлементКоллекции Цикл
				ЭтоКлючЗначение = ТипЗнч(ПолеЭлементаКоллекции) = Тип("КлючИЗначение");
				ПроверяемоеЗначение = ?(ЭтоКлючЗначение, ПолеЭлементаКоллекции.Значение, ПолеЭлементаКоллекции);
				Если ПроверяемоеЗначение = ИскомоеЗначение Тогда
					ЭлементСоответствуетОтбору = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;

		ИначеЕсли ЗначениеЗаполнено(ПараметрыПоиска) Тогда

			ЭлементСоответствуетОтбору = Истина;
			Для каждого ПараметрПоиска Из ПараметрыПоиска Цикл
				Если ЭлементКоллекции[ПараметрПоиска.Ключ] <> ПараметрПоиска.Значение Тогда
					ЭлементСоответствуетОтбору = Ложь;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		
		Иначе // Пустая структура отбора

			Прервать;

		КонецЕсли;

		Если ЭлементСоответствуетОтбору Тогда
			НайденныеЭлементы.Добавить(ЭлементКоллекции);
			НайденоЭлементов = НайденоЭлементов + 1;
		КонецЕсли;

	КонецЦикла;

	Возврат НайденныеЭлементы;

КонецФункции // НайтиЭлементыКоллекции()

// Производит поиск в однородной коллекции, состоящих из элементов с полями (например, Массив из Структура)
//
// Параметры:
//  Коллекция 		 - Произвольный	 - Коллекция, поддерживающая обход "Для Каждого ..."
//  ПараметрыПоиска  - Структура:
//		* Ключ			 - Поле элемента коллекции, в котором производится поиск
//		* Значение		 - Искомое значение
//					 - Произвольный	 - Искомое значение
//  ПоляПоиска 		 - Строка		 - Поля элемента коллекции, в которых производится поиск, через запятую.
//									 Поиск производится по значению в любом из указанных полей.
//									 Если указана пустая строка, проверяются все поля элементов коллекции.
//
// Варианты вызова:
//	НайтиЭлементыКоллекции(Произвольный, Структура)				 - Поиск по значениям нескольких полей.
//	НайтиЭлементыКоллекции(Произвольный, Произвольный, Строка)	 - Поиск по значению в любом поле из указанных.
//
// Возвращаемое значение:
//   Произвольный   - Найденный элемент коллекции
//
Функция НайтиЭлементКоллекции(
	Коллекция, 
	Знач ПараметрыПоиска, 
	Знач ПоляПоиска = Неопределено) Экспорт

	НайденныеЭлементы = НайтиЭлементыКоллекции(Коллекция, ПараметрыПоиска, ПоляПоиска, 1);
	Если ЗначениеЗаполнено(НайденныеЭлементы) Тогда
		НайденныйЭлемент = НайденныеЭлементы[0];
	Иначе
		НайденныйЭлемент = Неопределено;
	КонецЕсли;

	Возврат НайденныйЭлемент;
	
КонецФункции // НайтиЭлементКоллекции() 

// Производит поиск элементов коллекции по типу значений.
//
// Параметры:
//  Коллекция			 - Произвольный		 - Коллекция, поддерживающая обход "Для Каждого ..."
//  Тип					 - Тип				 - Тип искомых значений
//						 - ОписаниеТипов	 - Допустимые типы искомых значений
//						 - Строка			 - Имена типов через запятую
//	ТолькоЗаполненные	 - Булево			 - Будут отобраны только заполненные значения.
//
// Возвращаемое значение:
//	Массив - Отобранные элементы в порядке следования в исходном массиве.
//
Функция НайтиЭлементыКоллекцииПоТипу(Коллекция, Тип, ТолькоЗаполненные = Ложь) Экспорт
	
	ОтобранныеЭлементы = Новый Массив;

	Если ТипЗнч(Тип) = Тип("Тип") Тогда
		ТипЭтоОписаниеТипов = Ложь;

	ИначеЕсли ТипЗнч(Тип) = Тип("ОписаниеТипов") Тогда
		ТипЭтоОписаниеТипов = Истина;
		ОписаниеТипов = Тип;

	ИначеЕсли ТипЗнч(Тип) = Тип("Строка") Тогда
		ТипЭтоОписаниеТипов = Истина;
		Попытка
			ОписаниеТипов = Новый ОписаниеТипов(Тип);
		Исключение
			ВызватьИсключение "Параметр Тип: Неверное описание типов";
		КонецПопытки;

	Иначе
		ВызватьИсключение "Параметр Тип: Неожиданный тип";

	КонецЕсли;

	Для каждого ЭлементКоллекции Из Коллекция Цикл
		ТипЭлемента = ТипЗнч(ЭлементКоллекции);
		Если Не ТипЭтоОписаниеТипов И ТипЭлемента <> Тип Тогда
			Продолжить;
		КонецЕсли;
		Если ТипЭтоОписаниеТипов И Не ОписаниеТипов.СодержитТип(ТипЭлемента) Тогда
			Продолжить;
		КонецЕсли;
		Если ТолькоЗаполненные И Не ЗначениеЗаполнено(ЭлементКоллекции) Тогда
			Продолжить;
		КонецЕсли;
		ОтобранныеЭлементы.Добавить(ЭлементКоллекции);
	КонецЦикла;				

	Возврат ОтобранныеЭлементы;

КонецФункции // НайтиЭлементыКоллекцииПоТипу()

// Формирует массив с элементами в обратном порядке.
//
// Параметры:
//  ИсходнаяКоллекция	 - Произвольный - Коллекция, поддерживающая обход посредством оператора Для каждого … Из … Цикл.
// 
// Возвращаемое значение:
//  Массив - Элементы исходной коллекции в обратном порядке.
//
Функция ОбратныйПорядок(ИсходнаяКоллекция) Экспорт
	
	ЭлементыВОбратномПорядке = Новый Массив;
	Для каждого ТекущийЭлемент Из ИсходнаяКоллекция Цикл
		ЭлементыВОбратномПорядке.Вставить(0, ТекущийЭлемент);
	КонецЦикла; 

	Возврат ЭлементыВОбратномПорядке;
	
КонецФункции // ОбратныйПорядок()

// Нумерует элементы коллекции
//
// Параметры:
//	Коллекция		 - Произвольный	 - Коллекция для обработки
//	ИмяПоляНомер	 - Строка		 - Имя поля или колонки, содержащей номер
//	НачальныйНомер	 - Число		 - Номер первого элемента в коллекции
//
Процедура ПронумероватьКоллекцию(Коллекция, ИмяПоляНомер, НачальныйНомер = 1)

	НомерЭлемента = НачальныйНомер - 1;
	Для каждого ЭлементКоллекции Из Коллекция Цикл
		НомерЭлемента = НомерЭлемента + 1;
		ЭлементКоллекции[ИмяПоляНомер] = НомерЭлемента;
	КонецЦикла;

КонецПроцедуры // ПронумероватьКоллекцию()

#КонецОбласти	// Коллекции

// Производит заполнение шаблона со строковыми параметрами
//
// Параметры:
//  Шаблон		 - Строка	 - Строка вида "Параметр %Параметр% содержит значение %Значение%"
//  Поля		 - Структура, Соответствие - Коллекция с именами параметров и текстом, который надо подставить в шаблон. 
//											 Например: Новый Структура("Параметр, Значение", "Цвет", "Красный")
//  ПрефиксПоля	 - Строка	 - Префикс поля в шаблоне
//  СуффиксПоля	 - Строка	 - Суффикс поля в шаблоне
// 
// Возвращаемое значение:
//  Строка - Шаблон с подставленными параметрами
//
Функция ЗаполнитьПоляШаблона(Шаблон, Поля, ПрефиксПоля = "%", СуффиксПоля = "%") Экспорт

	Результат = Шаблон;
	Для каждого Поле Из Поля Цикл
		Результат = СтрЗаменить(Результат, ПрефиксПоля + Поле.Ключ + СуффиксПоля, Поле.Значение);
	КонецЦикла; 
	
	Возврат Результат;

КонецФункции // ЗаполнитьПоляШаблона()

// Делит разыменование поля на составляющие с неполными путями
// Пример: Разыменование вида Поле1.Поле2.Поле3 будет разложено на массив вида [Поле1, Поле1.Поле2, Поле1.Поле2.Поле3]
//
// Параметры:
//  Разыменование	 - Строка	 - Делимое разыменование
// 
// Возвращаемое значение:
//  Массив - Элемент: Строка
//
// Пример: 
//	Разыменование вида Поле1.Поле2.Поле3 будет разложено на массив вида [Поле1, Поле1.Поле2, Поле1.Поле2.Поле3]
//
Функция РазделитьРазыменованиеНаНеполныеПути(Знач Разыменование)

	МассивПолей	= СтрРазделить(Разыменование, ".");
	МассивПутей = Новый Массив;
	Для Индекс = 0 по МассивПолей.ВГраница() Цикл
		НеполныйПуть = Новый Массив;
		Для НеполныйИндекс = 0 По Индекс Цикл
			НеполныйПуть.Добавить(МассивПолей[НеполныйИндекс]);
		КонецЦикла; 		
		МассивПутей.Добавить(СтрСоединить(НеполныйПуть, "."));
	КонецЦикла; 
	
	Возврат МассивПутей;	

КонецФункции // РазделитьРазыменованиеНаНеполныеПути()

// Проверяет элемент данных на соответствие отбору.
//
// Параметры:
//  Элемент	 - Произвольный	 - Произвольная коллекция, к которой возможно обращение по имени поля. 
//							 Например, СтрокаДереваЗначений.
//  Отбор	 - Структура	 - Накладываемый отбор. 
//							 Поля отбора должны присутствовать в проверяемом элементе. 
//							 Если Неопределено - элемент считается соответствующим отбору.
// 
// Возвращаемое значение:
//  Булево - Истина, если элемент соответствует отбору или отбор не определён
//
Функция ЭлементСоответствуетОтбору(Знач Элемент, Знач Отбор = Неопределено) Экспорт

	Если Отбор = Неопределено Тогда 
		Возврат Истина;
	КонецЕсли; 
	
	Для каждого ЭлементОтбора Из Отбор Цикл
		Если Элемент[ЭлементОтбора.Ключ] <> ЭлементОтбора.Значение Тогда 
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла; 

	Возврат Истина;
	
КонецФункции // ЭлементСоответствуетОтбору()

#Область Строка

#Область СистемыСчисления

// Преобразует число из шестнадцатеричной системы счисления в десятичную
//
// Параметры:
//   Число - Строка - Шестнадцатеричное число
//
//  Возвращаемое значение:
//   Число - Десятичное число
//
Функция ДесятЧислоИзШестн(Число) Экспорт
	ЧислоСтрокой = ПреобразоватьСистемуСчисления(Число, 16, 10);
	Возврат Число(ЧислоСтрокой); 
КонецФункции // ДесятЧислоИзШестн()

// Преобразует число из десятичной системы счисления в шестнадцатеричную
//
// Параметры:
//	Число - Число, Строка - Исходное число
//
// Возвращаемое значение:
//	Строка - Шестнадцатеричное число
//
Функция ШестнЧислоИзДесят(Знач Число) Экспорт
	Если ТипЗнч(Число) = Тип("Число") Тогда
		Число = Формат(Число, "ЧГ=;ЧН=0");
	КонецЕсли;
	Возврат ПреобразоватьСистемуСчисления(Число, 10, 16);
КонецФункции // ШестнЧислоИзДесят()

// Переводит число из одной позиционной системы счисления в другую.
//
// Параметры:
//	ЧислоСтрокой		 - Строка	 - Исходное число
//	ОснованиеИсходное	 - Число	 - Основание исходного числа. Для десятичной системы будет 10, для двоичной - 2.
//	ОснованиеНовое		 - Число	 - Целевое основание.
//
// Возвращаемое значение:
//	Строка - Строковое представление числа.
//
Функция ПреобразоватьСистемуСчисления(Знач ЧислоСтрокой, ОснованиеИсходное, ОснованиеНовое) Экспорт

	Если ОснованиеИсходное = ОснованиеНовое Тогда
		Возврат ЧислоСтрокой;
	КонецЕсли;

	Разряды = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	ЕмкостьАлфавита = СтрДлина(Разряды);
	
	МаксОснование = Макс(ОснованиеИсходное, ОснованиеНовое);
	Если МаксОснование > ЕмкостьАлфавита Тогда 
		ВызватьИсключение "Основание больше ёмкости алфавита";
	КонецЕсли;

	Если Мин(ОснованиеИсходное, ОснованиеНовое) < 2 Тогда
		ВызватьИсключение "Неверно указано Основание";
	КонецЕсли;

	Цифры = Новый Массив;
	Числа = Новый Соответствие;
	Для НомерСимвола = 1 По Мин(ЕмкостьАлфавита, МаксОснование) Цикл
		Символ = Сред(Разряды, НомерСимвола, 1);
		Цифры.Добавить(Символ);
		Числа[Символ] = НомерСимвола - 1;
	КонецЦикла;

	ЧислоСтрокой = СокрЛП(ЧислоСтрокой);
	ДлинаЧислаИсх = СтрДлина(ЧислоСтрокой);

	// Из произвольной в десятичную:
	ЧислоДес = 0;
	Для НомерСимвола = 1 По ДлинаЧислаИсх Цикл
		Степень = ДлинаЧислаИсх - НомерСимвола;
		Символ = Сред(ЧислоСтрокой, НомерСимвола, 1);
		Число = Числа[Символ];
		Если Число = Неопределено Или Число >= ОснованиеИсходное Тогда
			ВызватьИсключение "Исходное число не соответствует своей системе счисления";
		КонецЕсли;
		ЧислоДес = ЧислоДес + Число * Pow(ОснованиеИсходное, Степень);
	КонецЦикла;

	Если ОснованиеНовое = 10 Тогда
		Возврат Формат(ЧислоДес, "ЧГ=;ЧН=0");
	КонецЕсли;

	// Из десятичного в произвольную:
	ЧислоНовое = "";
	Частное = ЧислоДес;
	Пока Частное > 0 Цикл
		Уменьшаемое = Частное % ОснованиеНовое;
		ЧислоНовое = Цифры[Уменьшаемое] + ЧислоНовое;
		Частное = Цел(Частное / ОснованиеНовое);
	КонецЦикла;

	Возврат ЧислоНовое;

КонецФункции // ПреобразоватьСистемуСчисления()

#КонецОбласти // СистемыСчисления

#Область РимскиеЧисла

// Возвращает римский литерал из юникода,
// соответствующий переданному числу.
//
// Параметры:
//	Число - Число - Целое число в пределах от 1 до 12.
//
// Возвращаемое значение:
//	Строка - Литерал.
//
Функция РимскийЛитерал(Число) Экспорт

	ЭтоВалидноеЧисло = (ТипЗнч(Число) = Тип("Число")) И (1 <= Число И Число <= 12) И (Число = Цел(Число));
	Если Не ЭтоВалидноеЧисло Тогда
		ВызватьИсключение "Параметр Число: Неожиданное значение";
	КонецЕсли;

	КодРимскойЕдиницы = КодСимвола("Ⅰ"); // U+2160 Roman Number One
	Смещение = Число - 1;
	РимскийЛитерал = Символ(КодРимскойЕдиницы + Смещение);

	Возврат РимскийЛитерал; 

КонецФункции // РимскийЛитерал()

// Преобразует число в римское.
// Аналогична функции РИМСКОЕ() из Microsoft Excel 
// см. https://support.microsoft.com/ru-ru/office/функция-римское-d6b0b99e-de46-4704-a518-b45a0f8b56f5
//
// Параметры:
//	Число	 - Число	 - Исходное целое число в диапазоне [1..3999]
//	Форма	 - Число	 - Форма упрощения числа, от 0 до 4, где 0 = Классическая, а 4 - упрощённая. См. примеры.
//			 - Булево	 - Истина соответствует классической формы написания, Ложь - Упрощённой.
//
// Возвращаемое значение:
//	Строка - Римское написание числа.
//
// Примеры:
//	РимскоеЧисло(499, 0); // "CDXCIX"
//	РимскоеЧисло(499, 1); // "LDVLIV"
//	РимскоеЧисло(499, 2); // "XDIX"
//	РимскоеЧисло(499, 3); // "VDIV"
//	РимскоеЧисло(499, 4); // "ID"
//
Функция РимскоеЧисло(Число, Знач Форма = Истина) Экспорт

	ЭтоВалидноеЧисло = (ТипЗнч(Число) = Тип("Число")) И (1 <= Число И Число <= 3999) И (Число = Цел(Число));
	Если Не ЭтоВалидноеЧисло Тогда
		ВызватьИсключение "Параметр Число: Неожиданное значение";
	КонецЕсли;
	
	ЭтоВалиднаяФорма = (ТипЗнч(Форма) = Тип("Число")) И (0 <= Форма И Форма <= 4) И (Число = Цел(Число))
		Или ТипЗнч(Форма) = Тип("Булево");
	Если Не ЭтоВалиднаяФорма Тогда
		ВызватьИсключение "Параметр Форма: Неожиданное значение";
	КонецЕсли;

	Если ТипЗнч(Форма) = Тип("Булево") Тогда
		Форма = ?(Форма = Истина, 0, 4);
	КонецЕсли;

	Разряды = Новый Соответствие;
	
	Разряды = Новый СписокЗначений;
	Разряды.Добавить(1000,	 "M");
	Разряды.Добавить(500,	 "D");
	Разряды.Добавить(100,	 "C");
	Разряды.Добавить(50,	 "L");
	Разряды.Добавить(10,	 "X");
	Разряды.Добавить(5,		 "V");
	Разряды.Добавить(1,		 "I");

	ЗначенияРазрядов = Новый Соответствие;
	Для каждого Разряд Из Разряды Цикл
		ЗначенияРазрядов[Разряд.Представление] = Разряд.Значение;
	КонецЦикла;

	Сочетания = Разряды.Скопировать();

	ТаблицаВычитаний = "
	// Описывает, какие вычитания возможны, в зависимости от формы:
	//	0	1	2	3	4	
	|M	C	L	X	V	I
	|D	C	L	X	V	I
	|C	X	V	I		
	|L	X	V	I		
	|X	I				
	|V	I				
	|";
	РазрядыСочетаний = СтрРазделить(ТаблицаВычитаний, Символы.ПС, Ложь);
	Для каждого РазрядСочетаний Из РазрядыСочетаний Цикл
		ТекущиеСочетания = СтрРазделить(РазрядСочетаний, Символы.Таб, Ложь);
		БазовыйРазряд = ТекущиеСочетания[0];
		База = ЗначенияРазрядов[БазовыйРазряд];
		МаксИндексСочетания = Мин(Форма + 1, ТекущиеСочетания.ВГраница());
		Для ИндексСочетания = 1 По МаксИндексСочетания Цикл
			ТекущийРазряд = ТекущиеСочетания[ИндексСочетания];
			СочетаниеЗначение = База - ЗначенияРазрядов[ТекущийРазряд];
			СочетаниеПредставление = ТекущийРазряд + БазовыйРазряд;
			Сочетания.Добавить(СочетаниеЗначение, СочетаниеПредставление);
		КонецЦикла;
	КонецЦикла;

	Сочетания.СортироватьПоЗначению(НаправлениеСортировки.Убыв);

	РимскоеЧисло = "";
	УменьшаемоеЗначение = Число;
	ИндексВычитаемого = 0;
	Пока УменьшаемоеЗначение > 0 Цикл
		Сочетание = Сочетания[ИндексВычитаемого];
		Если УменьшаемоеЗначение < Сочетание.Значение Тогда
			ИндексВычитаемого = ИндексВычитаемого + 1;
			Продолжить;
		Иначе
			РимскоеЧисло = РимскоеЧисло + Сочетание.Представление;
			УменьшаемоеЗначение = УменьшаемоеЗначение - Сочетание.Значение;
		КонецЕсли;
	КонецЦикла;

	Возврат РимскоеЧисло;
	
КонецФункции // РимскоеЧисло()

// Преобразует число из римской формы счисления.
//
// Параметры:
//	РимскоеЧисло - Строка - Строка в формате классического римского числа (Напр.: "MDCLXVI")
//
// Возвращаемое значение:
//	Число - Число в диапазоне [1..3999]
//
Функция ЧислоИзРимскогоЧисла(Знач РимскоеЧисло) Экспорт

	Если ТипЗнч(РимскоеЧисло) <> Тип("Строка") Или ПустаяСтрока(РимскоеЧисло) Тогда
		ВызватьИсключение "Параметр РимскоеЧисло: Неожиданное значение";
	КонецЕсли;

	РимскоеЧисло = ВРег(СокрЛП(РимскоеЧисло));

	ЗначенияСимволов = Новый Соответствие;
	ЗначенияСимволов.Вставить("M", 1000);
	ЗначенияСимволов.Вставить("D", 500);
	ЗначенияСимволов.Вставить("C", 100);
	ЗначенияСимволов.Вставить("L", 50);
	ЗначенияСимволов.Вставить("X", 10);
	ЗначенияСимволов.Вставить("V", 5);
	ЗначенияСимволов.Вставить("I", 1);

	ДлинаРимскогоЧисла = СтрДлина(РимскоеЧисло);
	
	ЗначенияРазрядов = Новый Соответствие;
	Для Позиция = 1 По ДлинаРимскогоЧисла Цикл
		ТекущийСимвол = Сред(РимскоеЧисло, Позиция, 1);
		ТекущееЗначение = ЗначенияСимволов[ТекущийСимвол];
		Если ТекущееЗначение = Неопределено Тогда
			ВызватьИсключение СтрШаблон("Параметр РимскоеЧисло: Неожиданный символ (%1)", ТекущийСимвол);
		КонецЕсли;
		ЗначенияРазрядов[Позиция] = ТекущееЗначение;
	КонецЦикла;

	Результат = 0;

	Для Позиция = 1 По ДлинаРимскогоЧисла Цикл
		ТекущийСимвол = Сред(РимскоеЧисло, Позиция, 1);
		ТекущееЗначение = ЗначенияРазрядов[Позиция];
		Если Позиция < ДлинаРимскогоЧисла Тогда
			СледующееЗначение = ЗначенияРазрядов[Позиция + 1];
			Если СледующееЗначение > ТекущееЗначение Тогда
				Результат = Результат + (СледующееЗначение - ТекущееЗначение);
				Позиция = Позиция + 1;
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		Результат = Результат + ТекущееЗначение;
	КонецЦикла;

	Возврат Результат;
	
КонецФункции // ЧислоИзРимскогоЧисла()

#КонецОбласти // РимскиеЧисла

#Область Транслитерация

// Выполняет транслитерацию строки.
// см. https://ru.wikipedia.org/wiki/Транслитерация_русского_алфавита_латиницей
//
// Параметры:
//  Фраза	 - Строка	 - Исходная строка
//  Стандарт - Строка	 - Стандарт транслитерации. Варианты:
//		* 4271	 - Приказ МИД N 4271 (2016-н/в) 
//				(см. http://www.consultant.ru/document/cons_doc_LAW_198429/c956ff01bf42465d7052431dec215b77d0404875)
//		* 310	 - Приказ МВД N 310 (1997-2010)
// 
// Возвращаемое значение:
//  Строка - Результат транслитерации
//
Функция ТранслитерироватьСтроку(Знач Фраза, Стандарт = "4271")
	
	// Контрольный пример: абвгдеёжзийклмнопрстуфхцчшщъыьэюя. Съешь этих мягких французских булочек, да выпей же чаю. ВЕРХНИЙРЕГИСТР, Перваязаглавная, нижнийрегистр, СмешанныйРегистр. Слова123с5434Цифрами.и_$ЗНАКАМИ%вперемешку.
	
	ФразаЛатиницей = "";
	
	СоответствиеБукв = Новый Соответствие;
	#Область ОбщиеДляВсехСтандартовСимволы
	
	// Те символы, которые различаются в стандартах - не заполнены
	СоответствиеБукв.Вставить("а", "a");
	СоответствиеБукв.Вставить("б", "b");
	СоответствиеБукв.Вставить("в", "v");
	СоответствиеБукв.Вставить("г", "g");
	СоответствиеБукв.Вставить("д", "d");
	СоответствиеБукв.Вставить("е", "");
	СоответствиеБукв.Вставить("ё", "");
	СоответствиеБукв.Вставить("ж", "");
	СоответствиеБукв.Вставить("з", "z");
	СоответствиеБукв.Вставить("и", "");
	СоответствиеБукв.Вставить("й", "");
	СоответствиеБукв.Вставить("к", "k");
	СоответствиеБукв.Вставить("л", "l");
	СоответствиеБукв.Вставить("м", "m");
	СоответствиеБукв.Вставить("н", "n");
	СоответствиеБукв.Вставить("о", "o");
	СоответствиеБукв.Вставить("п", "p");
	СоответствиеБукв.Вставить("р", "r");
	СоответствиеБукв.Вставить("с", "s");
	СоответствиеБукв.Вставить("т", "t");
	СоответствиеБукв.Вставить("у", "u");
	СоответствиеБукв.Вставить("ф", "f");
	СоответствиеБукв.Вставить("х", "");
	СоответствиеБукв.Вставить("ц", "");
	СоответствиеБукв.Вставить("ч", "");
	СоответствиеБукв.Вставить("ш", "");
	СоответствиеБукв.Вставить("щ", "");
	СоответствиеБукв.Вставить("ъ", "");
	СоответствиеБукв.Вставить("ы", "");
	СоответствиеБукв.Вставить("ь", "");
	СоответствиеБукв.Вставить("э", "");
	СоответствиеБукв.Вставить("ю", "");
	СоответствиеБукв.Вставить("я", "");
	
	// Буквы-исключения: Е, Ё, Ж, И, Й, Х, Ц, Ч, Ш, Щ, Ъ, Ы, Ь, Э, Ю, Я.
	БуквыИсключения = СтрРазделить("е, ё, ж, и, й, х, ц, ч, ш, щ, ъ, ы, ь, э, ю, я", ", ", Ложь);
	Для каждого ТекущийСимвол Из БуквыИсключения Цикл
		СоответствиеБукв.Вставить(ТекущийСимвол, "");
	КонецЦикла; 
	
	#КонецОбласти // ОбщиеДляВсехСтандартовСимволы 
	
	#Область ОписаниеСтандартов
	Если Стандарт = "4271" Тогда
		
		СоответствиеБукв.Вставить("е", "e");
		СоответствиеБукв.Вставить("ё", "e");
		СоответствиеБукв.Вставить("ж", "zh");
		СоответствиеБукв.Вставить("и", "i");
		СоответствиеБукв.Вставить("й", "i");
		СоответствиеБукв.Вставить("х", "kh");
		СоответствиеБукв.Вставить("ц", "ts");
		СоответствиеБукв.Вставить("ч", "ch");
		СоответствиеБукв.Вставить("ш", "sh");
		СоответствиеБукв.Вставить("щ", "shch");
		СоответствиеБукв.Вставить("ъ", "ie");
		СоответствиеБукв.Вставить("ы", "y");
		СоответствиеБукв.Вставить("ь", ""); // пропускается
		СоответствиеБукв.Вставить("э", "e");
		СоответствиеБукв.Вставить("ю", "iu");
		СоответствиеБукв.Вставить("я", "ia");		
		
	ИначеЕсли Стандарт = "310" Тогда
		
		// см. СтроковыеФункцииКлиентСервер.СоответствиеКириллицыИЛатиницы() 
		// или СтроковыеФункцииКлиентСервер.СоответствиеНациональногоАлфавитаИЛатиницы() (БСП)
		СоответствиеБукв.Вставить("е", "e");
		СоответствиеБукв.Вставить("ё", "e");
		СоответствиеБукв.Вставить("ж", "zh");
		СоответствиеБукв.Вставить("и", "i");
		СоответствиеБукв.Вставить("й", "y");
		СоответствиеБукв.Вставить("х", "kh");
		СоответствиеБукв.Вставить("ц", "ts");
		СоответствиеБукв.Вставить("ч", "ch");
		СоответствиеБукв.Вставить("ш", "sh");
		СоответствиеБукв.Вставить("щ", "shch");
		СоответствиеБукв.Вставить("ъ", """");
		СоответствиеБукв.Вставить("ы", "y");
		СоответствиеБукв.Вставить("ь", ""); // пропускается
		СоответствиеБукв.Вставить("э", "e");
		СоответствиеБукв.Вставить("ю", "yu");
		СоответствиеБукв.Вставить("я", "ya");	
		
	Иначе 
		
		Возврат "";
		
	КонецЕсли; 
	#КонецОбласти // ОписаниеСтандартов 
	
	ПредыдущийСимвол = "";
	
	Слово = "";
	СловоЛатиницей = "";
	ДлинаСтроки = СтрДлина(Фраза);
	Для Позиция = 1 По ДлинаСтроки Цикл
		
		ТекущийСимвол = Сред(Фраза, Позиция, 1);
		
		ЭтоБуква = СоответствиеБукв[НРег(ТекущийСимвол)] <> Неопределено;
		
		Если ЭтоБуква Тогда
			
			Буква = ТекущийСимвол;
			БукваЛатиницей = СоответствиеБукв[НРег(ТекущийСимвол)]; // Поиск соответствия без учета регистра.
			Если Буква = ВРег(Буква) Тогда
				БукваЛатиницей = ТРег(БукваЛатиницей);			
			КонецЕсли; 
			
			Слово = Слово + Буква;
			СловоЛатиницей = СловоЛатиницей + БукваЛатиницей;			
		
		КонецЕсли; 
		
		СловоЗакончилось = ЗначениеЗаполнено(Слово) и (не ЭтоБуква или Позиция = ДлинаСтроки);
		
		Если СловоЗакончилось Тогда
			
			Если Слово = Врег(Слово) Тогда
				СловоЛатиницей = ВРег(СловоЛатиницей);
			ИначеЕсли Слово = НРег(Слово) Тогда
				СловоЛатиницей = НРег(СловоЛатиницей);
			ИначеЕсли Слово = ТРег(Слово) Тогда
				СловоЛатиницей = ТРег(СловоЛатиницей);
			КонецЕсли; 
			ФразаЛатиницей = ФразаЛатиницей + СловоЛатиницей;	
			
			Слово = "";
			СловоЛатиницей = "";
		
		КонецЕсли; 
		
		Если не ЭтоБуква Тогда
		
			ФразаЛатиницей = ФразаЛатиницей + ТекущийСимвол;
		
		КонецЕсли; 
		
	КонецЦикла;
	
	Возврат ФразаЛатиницей;
	
КонецФункции // ТранслитерироватьСтроку

// Различающиеся символы раскладок клавиатуры Йцукен и Qwerty
//
// Возвращаемое значение:
//   Структура - Символы раскладок в порядке, соответствующем положению клавиш на клавиатуре.
//		* Йцукен - Строка - Символы раскладки кириллицы
//		* Qwerty - Строка - Символы раскладки латиницы
//
Функция РазличныеСимволыРаскладокЙцукенQwerty()
	
	Йцукен			= "ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,Ё!""№;%:?/"; // Заглавный алфавит, потом верхний ряд с Ё до 7, потом шифт-черта
	Qwerty			= "QWERTYUIOP{}ASDFGHJKL:""ZXCVBNM<>?~!@#$%^&|"; // Заглавный алфавит, потом верхний ряд с ~ до 7, потом шифт-черта
	Йцукен = Йцукен + "йцукенгшщзхъфывапролджэячсмитьбю.ё";			 // Строчный алфавит и ё
	Qwerty = Qwerty + "qwertyuiop[]asdfghjkl;'zxcvbnm,./`";			 // Строчный алфавит и `

	Раскладки = Новый Структура;
	Раскладки.Вставить("Йцукен", Йцукен);
	Раскладки.Вставить("Qwerty", Qwerty);

	Если СтрДлина(Йцукен) <> СтрДлина(Qwerty) Тогда // Контроль
		ВызватьИсключение "Количество символов в раскладках не совпадает";
	КонецЕсли;

	Возврат Раскладки;

КонецФункции // РазличныеСимволыРаскладокЙцукенQwerty()

// см. СтрокаИзДругойРаскладки()
//
Функция СтрокаQwertyИзЙцукен(ИсходнаяСтрока) Экспорт
	
	Возврат СтрокаИзДругойРаскладки(ИсходнаяСтрока, "Йцукен", "Qwerty");

КонецФункции // СтрокаQwertyИзЙцукен()

// см. СтрокаИзДругойРаскладки()
//
Функция СтрокаЙцукенИзQwerty(ИсходнаяСтрока) Экспорт
	
	Возврат СтрокаИзДругойРаскладки(ИсходнаяСтрока, "Qwerty", "Йцукен");

КонецФункции // СтрокаЙцукенИзQwerty()

// Посимвольно преобразует строку из другой раскладки в порядке расположения клавиш клавиатуры другой раскладки.
//
// Параметры:
//  ИсходнаяСтрока			 - Строка
//  ИмяРаскладкиИсточник	 - Строка - см. ИмяРаскладкиНазначение
//	ИмяРаскладкиНазначение	 - Строка:
//		* "Qwerty" - Латиница
//		* "Йцукен" - Кириллица
//
// Возвращаемое значение:
//   Строка   - Преобразованная строка
//
Функция СтрокаИзДругойРаскладки(ИсходнаяСтрока, ИмяРаскладкиИсточник, ИмяРаскладкиНазначение)
	
	Раскладки			 = РазличныеСимволыРаскладокЙцукенQwerty();
	РаскладкаИсточник	 = Раскладки[ИмяРаскладкиИсточник];
	РаскладкаНазначение	 = Раскладки[ИмяРаскладкиНазначение];

	Результат = "";
	ЕстьСимволыДругойРаскладки = Ложь;
	Для НомерСимвола = 1 По СтрДлина(ИсходнаяСтрока) Цикл
		
		ТекСимвол = Сред(ИсходнаяСтрока, НомерСимвола, 1);

		Если Не ЕстьСимволыДругойРаскладки Тогда
			ЕстьСимволыДругойРаскладки = Булево(СтрНайти(РаскладкаИсточник, ТекСимвол));
			Если ЕстьСимволыДругойРаскладки Тогда
				// Построим соответствия раскладок
				СоответствиеСимволов = Новый Соответствие;
				Для НомерСимволаРаскладки = 1 По СтрДлина(РаскладкаИсточник) Цикл
					СимволРаскладкиИсточник		 = Сред(РаскладкаИсточник,	 НомерСимволаРаскладки, 1);
					СимволРаскладкиНазначение	 = Сред(РаскладкаНазначение, НомерСимволаРаскладки, 1);
					СоответствиеСимволов[СимволРаскладкиИсточник] = СимволРаскладкиНазначение;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;

		Если ЕстьСимволыДругойРаскладки Тогда
			СимволНазначение = СоответствиеСимволов[ТекСимвол];
			Результат = Результат + ?(СимволНазначение <> Неопределено, СимволНазначение, ТекСимвол);
		Иначе
			Результат = Результат + ТекСимвол;
		КонецЕсли; 

	КонецЦикла;

	Возврат Результат;

КонецФункции // СтрокаИзДругойРаскладки()

#КонецОбласти // Транслитерация

// Производит поиск слова целиком
// Работает для русского и английского алфавитов
//
// Параметры:
//	Строка			 - Строка			 - Исходная строка.
//	ПодстрокаПоиска	 - Строка			 - Искомая подстрока.
//	Направление		 - НаправлениеПоиска - Указывает направление поиска подстроки в строке.
//	НачальнаяПозиция - Число			 - Указывает позицию в строке, с которой начинается поиск. См. СтрНайти().
//	НомерВхождения	 - Число			 - Указывает номер вхождения искомой подстроки в исходной строке.
//
// Возвращаемое значение:
//	Число - Позиция первого знака найденной подстроки. 
//			Нумерация символов в строке начинается с 1. 
//			Если строка не содержит указанной подстроки, то возвращается 0.
//
Функция СтрНайтиЦеликом(
	Строка, 
	ПодстрокаПоиска, 
	Знач Направление = Неопределено,
	НачальнаяПозиция = Неопределено,
	НомерВхождения = 1) Экспорт

	Если Направление = Неопределено Тогда
		Направление = НаправлениеПоиска.СНачала;
	КонецЕсли;
	Если ТипЗнч(Направление) <> Тип("НаправлениеПоиска") Тогда
		ВызватьИсключение "Параметр Направление: Ожидается тип НаправлениеПоиска";
	КонецЕсли;

	Если НачальнаяПозиция = Неопределено Тогда
		НачальнаяПозиция = ?(Направление = НаправлениеПоиска.СНачала, 1, СтрДлина(Строка));
	КонецЕсли;
	Если НачальнаяПозиция = Неопределено Тогда
		ВызватьИсключение "Параметр Направление: Ожидается тип Число";
	КонецЕсли;

	Возврат СтрНайти(Строка, ПодстрокаПоиска, Направление, НачальнаяПозиция, НомерВхождения);
	
КонецФункции // СтрНайтиЦеликом

// Проверяет букву на принадлежность к буквам русского алфавита
//
// Параметры:
//   Символ - Строка - Проверяемая буква
//
//  Возвращаемое значение:
//   Булево - Истина, если это буква кириллицы.
//
Функция ЭтоБукваКириллицы(Символ) Экспорт

	Если СтрДлина(Символ) <> 1 Тогда
		Возврат Ложь;
	КонецЕсли; 	
	
	КодСимвола = КодСимвола(Символ);
	
	Возврат КодСимвола("а") <= КодСимвола И КодСимвола <= КодСимвола("я")
			Или КодСимвола("А") <= КодСимвола И КодСимвола <= КодСимвола("Я")
			Или Символ = "Ё" Или Символ = "ё";

КонецФункции // ЭтоБукваКириллицы()
 
// Проверяет букву на принадлежность к буквам английского алфавита
//
// Параметры:
//   Символ - Строка - Проверяемая буква
//
//  Возвращаемое значение:
//   Булево - Истина, если это буква латиницы.
//
Функция ЭтоБукваЛатиницы(Символ) Экспорт

	Если СтрДлина(Символ) <> 1 Тогда
		Возврат Ложь;
	КонецЕсли; 	
	
	КодСимвола = КодСимвола(Символ);
	
	Возврат КодСимвола("a") <= КодСимвола И КодСимвола <= КодСимвола("z")
			Или КодСимвола("A") <= КодСимвола И КодСимвола <= КодСимвола("Z");

КонецФункции // ЭтоБукваЛатиницы()


// Проверяет, является ли переданное значение ссылкой
//
// Параметры:
//  Значение - Произвольный	 - Проверяемое значение
// 
// Возвращаемое значение:
//  Булево
//
Функция ЭтоСсылка(Значение) Экспорт
	
	Если ЭтоПримитивныйТип(Значение) 
		Или ТипЗнч(Значение) = Тип("УникальныйИдентификатор") Тогда
		Возврат Ложь;
	КонецЕсли;
	
    СтрокаXML = XMLСтрока(Значение);                         
	Если ЭтоУникальныйИдентификатор(СтрокаXML) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;

КонецФункции // ЭтоСсылка()

 
// Проверяет, имеет ли строка формат Base64
// см. RFC 2045 (https://datatracker.ietf.org/doc/html/rfc2045)
//
// Параметры:
//  Строка - Строка - Проверяемая строка
//
// Возвращаемое значение:
//   Булево   - Если это Base64, возвращается Истина.
//
Функция ЭтоСтрокаBase64(Строка) Экспорт

	Если ТипЗнч(Строка) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;

	Разряды = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" + Символы.ПС;
	ЕстьДваСуффикса = СтрЗаканчиваетсяНа(Строка, "==");
	ЕстьСуффикс = ЕстьДваСуффикса Или СтрЗаканчиваетсяНа(Строка, "=");
	Если Не ЕстьСуффикс Тогда
		Возврат Ложь;
	КонецЕсли;

	ДлинаСуффикса = ?(ЕстьДваСуффикса, 2, 1);
	Для НомерСимвола = 1 По СтрДлина(Строка) - ДлинаСуффикса Цикл
		Если СтрНайти(Разряды, Сред(Строка, НомерСимвола, 1)) = 0 Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;

	Возврат Истина; 

КонецФункции // ЭтоСтрокаBase64()

// Проверяет, является ли строка уникальным идентификатором
//  вида "123e4567-e89b-12d3-a456-426655440000"
//
// Параметры:
//  Строка				 - Строка	 - Проверяемая строка
//  ДопускатьСкобки		 - Булево	 - Идентификатор может быть обрамлён в (круглые) или {фигурные} скобки
//  ДопускатьПрефикс	 - Булево	 - Идентификатор может начинаться префиксом 0x.
// 
// Возвращаемое значение:
//  Булево
//
Функция ЭтоУникальныйИдентификатор(Строка, ДопускатьСкобки = Ложь, ДопускатьПрефикс = Ложь) Экспорт

	Если ПустаяСтрока(Строка) Тогда
		Возврат Ложь;
	КонецЕсли;

	Скобки = "(){}";
	ПервыйСимвол	 = Лев(Строка, 1);
	ПоследнийСимвол	 = Прав(Строка, 1);
	ЕстьСкобки = СтрНайти(Скобки, ПервыйСимвол) > 0 И СтрНайти(Скобки, ПоследнийСимвол) > 0;
	Если ЕстьСкобки И Не ДопускатьСкобки Тогда
		Возврат Ложь;
	КонецЕсли;

	ДвоичныйПрефикс = "0x";
	ПозицияПрефикса = ?(ЕстьСкобки, 2, 1);
	ЕстьПрефикс = НРег(Сред(Строка, ПозицияПрефикса, 2)) = ДвоичныйПрефикс;
	Если ЕстьПрефикс И Не ДопускатьПрефикс Тогда
		Возврат Ложь;
	КонецЕсли;

	ОжидаемаяДлина = 32;
	Если ЕстьПрефикс Тогда
		ОжидаемаяДлина = ОжидаемаяДлина + 2;	// Префикс
	Иначе
		ОжидаемаяДлина = ОжидаемаяДлина + 4;	// Дефисы
	КонецЕсли;
	Если ЕстьСкобки Тогда
		ОжидаемаяДлина = ОжидаемаяДлина + 2;	// Скобки
	КонецЕсли;
	Если СтрДлина(Строка) <> ОжидаемаяДлина Тогда
		Возврат Ложь;
	КонецЕсли;

	ЗначащаяЧасть = Строка;
	Если ЕстьСкобки Тогда
		Если СтрНайти(Скобки, ПервыйСимвол) + 1 <> СтрНайти(Скобки, ПоследнийСимвол) Тогда // Разные скобки
			Возврат Ложь;
		КонецЕсли;
		ЗначащаяЧасть = Сред(ЗначащаяЧасть, 2, СтрДлина(ЗначащаяЧасть) - 2);
	КонецЕсли;

	Если ЕстьПрефикс Тогда
		ЗначащаяЧасть = Сред(ЗначащаяЧасть, 3);
		Если СтрНайти(ЗначащаяЧасть, "-") Тогда
			Возврат Ложь;
		КонецЕсли;
	Иначе
		ДопустимыеПозицииДефиса = Новый Массив;
		ДопустимыеПозицииДефиса.Добавить(9);
		ДопустимыеПозицииДефиса.Добавить(14);
		ДопустимыеПозицииДефиса.Добавить(19);
		ДопустимыеПозицииДефиса.Добавить(24);
	КонецЕсли;

	ДопустимыеСимволы = "0123456789abcdef";
	Для НомерСимвола = 1 По СтрДлина(ЗначащаяЧасть) Цикл
		ТекущийСимвол = Сред(ЗначащаяЧасть, НомерСимвола, 1);
		ЭтоДефис = ТекущийСимвол = "-";
		ЭтоДефисВДопустимойПозиции = ЭтоДефис И ДопустимыеПозицииДефиса.Найти(НомерСимвола) <> Неопределено;
		ЭтоДопустимыйСимвол = Не ЭтоДефис И СтрНайти(ДопустимыеСимволы, ТекущийСимвол) > 0;
		Если Не ЭтоДопустимыйСимвол И Не ЭтоДефисВДопустимойПозиции Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;	

КонецФункции // ЭтоУникальныйИдентификатор()

#КонецОбласти // Строка

#Область УникальныйИдентификатор

// Преобразует уникальный идентификатор в шестнадцатеричное число,
//	которое используется в навигационных ссылках
//
// Параметры:
//  УникальныйИдентификатор	 - УникальныйИдентификатор, Строка	 - Преобразуемый идентификатор
//  ДобавитьПрефикс			 - Булево							 - Если Истина - к числу будет добавлен префикс "0x"
// 
// Возвращаемое значение:
//   - Строка   - Сформированное строковое представление числа, 
//					Если формат идентификатора не верен, возвращается Неопределено.
//
Функция УникальныйИдентификаторВШестнадцатеричноеЧисло(Знач УникальныйИдентификатор, ДобавитьПрефикс = Истина)

	// Входящее:	00112233-4455-6677-8899-aabbccddeeff
	// Ожидается:	[0x]8899aabbccddeeff6677445500112233
	
	СоставныеЧасти = СтрРазделить(Строка(УникальныйИдентификатор), "-", Ложь);
	Если СоставныеЧасти.Количество() <> 5 Тогда Возврат Неопределено КонецЕсли; 	
	
	ШестнадцатеричноеЧисло = 
	?(ДобавитьПрефикс, "0x", "")
	+ СоставныеЧасти[3]		// 8899 
	+ СоставныеЧасти[4]		// aabbccddeeff
	+ СоставныеЧасти[2]		// 6677
	+ СоставныеЧасти[1]		// 4455
	+ СоставныеЧасти[0];	// 00112233
	
	Возврат ШестнадцатеричноеЧисло;

КонецФункции // УникальныйИдентификаторВШестнадцатеричноеЧисло()

// Формирует уникальный идентификатор из шестнадцатеричного числа
//
// Параметры:
//  ШестнадцатеричноеЧисло	 - Строка	 - Шестнадцатеричное число. Может предваряться префиксом "0x"
// 
// Возвращаемое значение:
//  УникальныйИдентификатор - Сформированный уникальный идентификатор
//
Функция УникальныйИдентификаторИзШестнадцатеричногоЧисла(Знач ШестнадцатеричноеЧисло)

	// Входящее:	[0x]8899aabbccddeeff6677445500112233
	// Ожидается:	00112233-4455-6677-8899-aabbccddeeff
	
	ШестнадцатеричноеЧислоБезПрефикса = СтрЗаменить(ШестнадцатеричноеЧисло, "0x", "");
	Если СтрДлина(ШестнадцатеричноеЧислоБезПрефикса) <> 32 Тогда Возврат Неопределено КонецЕсли;
	
	// Разметка:        1   5           17  21  25
	// Входящее:	[0x]8899aabbccddeeff6677445500112233
	ЧастиЧисла = Новый Массив;
	ЧастиЧисла.Добавить(Сред(ШестнадцатеричноеЧислоБезПрефикса, 1,	 4));	// 8899
	ЧастиЧисла.Добавить(Сред(ШестнадцатеричноеЧислоБезПрефикса, 5,	 12));	// aabbccddeeff
	ЧастиЧисла.Добавить(Сред(ШестнадцатеричноеЧислоБезПрефикса, 17,	 4));	// 6677
	ЧастиЧисла.Добавить(Сред(ШестнадцатеричноеЧислоБезПрефикса, 21,	 4));	// 4455
	ЧастиЧисла.Добавить(Сред(ШестнадцатеричноеЧислоБезПрефикса, 25,	 8));	// 00112233
	
	УникальныйИдентификатор = Новый УникальныйИдентификатор(
			ЧастиЧисла[4]		// 00112233
	+ "-" + ЧастиЧисла[3]		// 4455
	+ "-" + ЧастиЧисла[2]		// 6677
	+ "-" + ЧастиЧисла[0]		// 8899 
	+ "-" + ЧастиЧисла[1]		// aabbccddeeff
	);
	
	Возврат УникальныйИдентификатор;

КонецФункции // УникальныйИдентификаторИзШестнадцатеричногоЧисла()

#КонецОбласти // УникальныйИдентификатор

#Область НавигационныеСсылки

// Формирует представления навигационных ссылок в формате Соответствия
//
// Параметры:
//	НавигационныеСсылки - Массив из Строка - Получаемые ссылки
//
// Возвращаемое значение:
//	Соответствие:
//		* Ключ		 - Строка		 - Переданная навигационная ссылка из параметра НавигационныеСсылки
//		* Значение	 - Строка		 - Представление навигационной ссылки.
//					 - Неопределено	 - Объект отсутствует в базе.
//
Функция ПредставленияНавигационныхСсылок(НавигационныеСсылки)
	
	Представления = Новый Соответствие;

	ПредставленияНавСсылок = ПолучитьПредставленияНавигационныхСсылок(НавигационныеСсылки);
	Для Индекс = 0 По НавигационныеСсылки.ВГраница() Цикл
		ПредставлениеНавСсылки = ПредставленияНавСсылок[Индекс];
		Если ТипЗнч(ПредставлениеНавСсылки) = Тип("ПредставлениеНавигационнойСсылки") Тогда
			Представление = ПредставлениеНавСсылки.Текст;
		Иначе
			Представление = Неопределено;
		КонецЕсли; 
		Представления.Вставить(НавигационныеСсылки[Индекс], Представление);
	КонецЦикла; 	
	
	Возврат Представления;

КонецФункции // ПредставленияНавигационныхСсылок()
 
// Получает представление навигационной ссылки
//
// Параметры:
//	НавигационнаяСсылка - Строка - Получаемая ссылка
//
// Возвращаемое значение:
//	Строка		 - Представление навигационной ссылки. Если объект отсутствует в базе - пустая строка.
//
Функция ПредставлениеНавигационнойСсылки(НавигационнаяСсылка)
	
	Представление = "";
	
	НавигационныеСсылки = Новый Массив;
	Если ЗначениеЗаполнено(НавигационнаяСсылка) Тогда
		НавигационныеСсылки.Добавить(НавигационнаяСсылка);
	КонецЕсли; 
	ПредставленияНавСсылок = ПолучитьПредставленияНавигационныхСсылок(НавигационныеСсылки);
	Если ЗначениеЗаполнено(ПредставленияНавСсылок) Тогда
		ПредставлениеНавСсылки = ПредставленияНавСсылок[0];
		Если ТипЗнч(ПредставлениеНавСсылки) = Тип("ПредставлениеНавигационнойСсылки") Тогда
			Представление = ПредставлениеНавСсылки.Текст;
		КонецЕсли; 
	КонецЕсли;

	Возврат Представление;
	
КонецФункции	// ПредставлениеНавигационнойСсылки()

#КонецОбласти // НавигационныеСсылки

#Область OneScript

#Область ФункцииБолванки

Функция ПолучитьПредставленияНавигационныхСсылок(НавигационныеСсылки)
	Возврат Новый Соответствие; 
КонецФункции

#КонецОбласти // ФункцииБолванки

СериализаторXDTO = Новый СериализаторXDTO;

#КонецОбласти // OneScript

