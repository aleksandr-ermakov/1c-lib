#Область ТаблицаЗначений

// Выгружает значения нескольких колонок таблицы значений в один массив.
//	Порядок следования значений в массиве соответствует порядку следования колонок.
//
// Параметры:
//	ИсходнаяТаблица		 - ТаблицаЗначений	 - Таблица, данные которой требуется выгрузить
//	Колонки				 - Строка			 - Перечисление колонок, которые слудует выгрузить. Если не указан, выгружаются все колонки.
//	Отбор				 - Структура		 - Отбор, строк таблицы для выгрузки.
//	ТолькоЗаполненные	 - Булево			 - Будут выгружены только заполненные значения. Значения проверяются функцией ЗначениеЗаполнено().
//	ТолькоУникальные	 - Булево			 - Полученный массив будет содержать только уникальные значения. Порядок следования значений в массиве - произвольный.
//
// Возвращаемое значение:
//	Массив - Значения колонок исходной таблицы.
//
Функция ЗначенияТаблицыЗначенийВМассив(ИсходнаяТаблица, Знач Колонки = "", Отбор = Неопределено, ТолькоЗаполненные = Ложь, ТолькоУникальные = Ложь)
	
	РезультирующийМассив = Новый Массив;
	Если Ложь Тогда ИсходнаяТаблица = Новый ТаблицаЗначений КонецЕсли;

	КоллекцияСтрок = ИсходнаяТаблица;
	Если ТипЗнч(Отбор) = Тип("Структура") Тогда
		КоллекцияСтрок = ИсходнаяТаблица.НайтиСтроки(Отбор);
	КонецЕсли;

	Если не ЗначениеЗаполнено(КоллекцияСтрок) Тогда Возврат РезультирующийМассив КонецЕсли;	// Пустой массив

	ИменаКолонок = Новый Массив;
	Если ЗначениеЗаполнено(Колонки) Тогда
		ИменаКолонок = СтрРазделить(Колонки, ", ", Ложь);
	Иначе
		Для Каждого Колонка Из ИсходнаяТаблица.Колонки Цикл
			ИменаКолонок.Добавить(Колонка.Имя);
		КонецЦикла;
	КонецЕсли;

	Для Каждого ИмяКолонки из ИменаКолонок Цикл
		Для каждого СтрокаТаблицы Из КоллекцияСтрок Цикл
			Значение = СтрокаТаблицы[ИмяКолонки];
			Если ТолькоЗаполненные и не ЗначениеЗаполнено(Значение) Тогда Продолжить КонецЕсли;
			Если ТолькоУникальные и РезультирующийМассив.Найти(Значение) <> Неопределено Тогда Продолжить КонецЕсли;
			РезультирующийМассив.Добавить(Значение);
		КонецЦикла;
	КонецЦикла;

	Возврат РезультирующийМассив;

КонецФункции // ЗначенияТаблицыЗначенийВМассив()

// Разносит значения из определённой колонки таблицы в самостоятельные колонки.
//
// Параметры:
//	ИсходнаяТаблица		 - ТаблицаЗначений	 - Таблица для обработки
//	Измерения			 - Строка			 - Измерения, сохраняемые в таблице значений.
//	КолонкаПоказателя	 - Строка			 - Имя колонки, значения из которой  будут вынесены в отдельные колонки.
//	КолонкиПоказателя	 - Соответствие		 - Значения, которые будут разнесены по колонкам. В результирующей таблице будут только значения показателя, указанного в этой коллекции.
//		Ключ	 - Произвольный	 - Значение, выделяемое в колонку 
//		Значение - Строка		 - Префикс поздаваемой колонки.
//	Ресурсы				 - Строка - Имена ресурсов, которые будут выделены в самостоятельные колонки. 
//		Если указано больше одного ресурса, являются суффиксами создаваемых колонок.
//		Числовые ресурсы
//
// Пример:
//	СтрокиТаблицыЗначенийВКолонки(ТаблицаЗначений, "Номенклатура", "Склад", {Склад1:"Первый", Склад2:"Второй"}, "Количество");	// ТаблицаЗначений{Номенклатура, Первый, Второй}
//	СтрокиТаблицыЗначенийВКолонки(ТаблицаЗначений, "Номенклатура", "Склад", {Склад1:"Первый", Склад2:"Второй"}, "Количество, Стоимость"); // ТаблицаЗначений{Номенклатура, ПервыйКоличество, ПервыйСтоимость, ВторойКоличество, ВторойСтоимость}
//
// Возвращаемое значение:
//	ТаблицаЗначений - Таблица, содержащая переданные измерения и выделенные ресурсы.
//		Таблица свёрнута по комплектам измерений (параметр измерения).
//		Числовые показатели, если встречаются многократно, просуммированы. 
//		Прочие показатели выражаются последним значением из набора исходных данных.
//
Функция СтрокиТаблицыЗначенийВКолонки(ИсходнаяТаблица, Знач Измерения, КолонкаПоказателя, Знач КолонкиПоказателя, Знач Ресурсы)

	ИменаКолонокРесурсов = Новый Соответствие;

	ЕстьИзмерения = ЗначениеЗаполнено(Измерения);

	#Область КонструкторРезультирующаяТаблица

	Если ЕстьИзмерения Тогда
		РезультирующаяТаблица = ИсходнаяТаблица.СкопироватьКолонки(Измерения);
		ИменаКолонокИзмерений = СтрРазделить(Измерения, ", ", Ложь);
	Иначе
		РезультирующаяТаблица = Новый ТаблицаЗначений;
		ИменаКолонокИзмерений = Новый Массив;
	КонецЕсли;

	ИменаКолонокРесурсов = СтрРазделить(Ресурсы, ", ", Ложь);
	ИспользоватьСуффиксРесурсов = ИменаКолонокРесурсов.Количество() > 1;
	ИменаКолонокПоказателей = Новый Массив;
	Для Каждого КолонкаПоказатель Из КолонкиПоказателя Цикл
		Если ИменаКолонокПоказателей.Найти(КолонкаПоказатель.Значение) = Неопределено Тогда
			ИменаКолонокПоказателей.Добавить(КолонкаПоказатель.Значение);
		КонецЕсли;
	КонецЦикла;
	Для каждого ИмяКолонкиПоказателя Из ИменаКолонокПоказателей Цикл
		Для каждого ИмяКолонкиРесурса Из ИменаКолонокРесурсов Цикл
			ИмяКолонкиЗначения = ИмяКолонкиПоказателя + ?(ИспользоватьСуффиксРесурсов, ИмяКолонкиРесурса, ""); 
			РезультирующаяТаблица.Колонки.Добавить(ИмяКолонкиЗначения, ИсходнаяТаблица.Колонки[ИмяКолонкиРесурса].ТипЗначения);
		КонецЦикла;
	КонецЦикла;
	Если ЕстьИзмерения Тогда
		РезультирующаяТаблица.Индексы.Добавить(Измерения);
	КонецЕсли;
	#КонецОбласти	// КонструкторРезультирующаяТаблица

	ПредыдущаяПозицияРезультат = Неопределено;
	Для каждого ПозицияИсходная Из ИсходнаяТаблица Цикл
		
		Значение = ПозицияИсходная[КолонкаПоказателя];
		ИмяКолонкиПоказателя = КолонкиПоказателя[Значение];
		Если КолонкаЗначения = Неопределено Тогда Продолжить КонецЕсли;

		ПозицияРезультат = Неопределено;
		Если ЕстьИзмерения и ПредыдущаяПозицияРезультат <> Неопределено Тогда
			НужноНайтиСтроку = Ложь;
			Для каждого ИмяКолонкиИзмерения Из ИменаКолонокИзмерений Цикл
				Если ПредыдущаяПозицияРезультат[ИмяКолонкиИзмерения] <> ПозицияИсходная[ИмяКолонкиИзмерения] Тогда
					НужноНайтиСтроку = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если НужноНайтиСтроку Тогда
				СтруктураПоиска = Новый Структура(Измерения);
				ЗаполнитьЗначенияСвойств(СтруктураПоиска, ПозицияИсходная);
			КонецЕсли;
		КонецЕсли; 
		Если ПозицияРезультат = Неопределено Тогда
			ПозицияРезультат = РезультирующаяТаблица.Добавить();
			Если ЗначениеЗаполнено(Измерения) Тогда
				ЗаполнитьЗначенияСвойств(ПозицияРезультат, ПозицияИсходная, Измерения);
			КонецЕсли;
		КонецЕсли; 
		
		Для каждого ИмяКолонкиРесурса Из ИменаКолонокРесурсов Цикл

			ИмяКолонкиПоказателя = ИмяКолонкиПоказателя + ?(ИспользоватьСуффиксРесурсов, ИмяКолонкиРесурса, "");

		КонецЦикла;


	КонецЦикла;

	Возврат РезультирующаяТаблица;

КонецФункции // СтрокиТаблицыЗначенийВКолонки()

// Получает итоги по колонкам таблицы с приминением отбора.
//
// Параметры:
//  ТаблицаЗначений	 - ТаблицаЗначений	 - Исходная таблица.
//  ПараметрыОтбора	 - Структура		 - Отбор строк, по которым будут подсчитаны итоги.
//  Ресурсы			 - Строка			 - Имена колонок итога.
// 
// Возвращаемое значение:
//   - Структура   - Полученные итоги. Ключ: Имя колонки, Значение: Число.
//
Функция ИтогиТаблицыЗначенийПоОтбору(ТаблицаЗначений, ПараметрыОтбора, Ресурсы)

	Итоги = Новый Структура(Ресурсы);
	ТаблицаИтогов = ТаблицаЗначений.Скопировать(ПараметрыОтбора, Ресурсы);
	ТаблицаИтогов.Свернуть(, Ресурсы);
	Если ЗначениеЗаполнено(ТаблицаИтогов) Тогда
		ЗаполнитьЗначенияСвойств(Итоги, ТаблицаИтогов[0]);
	Иначе
		Для каждого Элемент Из Итоги Цикл
			Элемент.Значение = 0;
		КонецЦикла;  	
	КонецЕсли; 
	
	Возврат Итоги;

КонецФункции // ИтогиТаблицыЗначенийПоОтбору()

// Позволяет разделить данные исходной таблицы на произвольное количество частей
// Например, таблицу из трёх строк на пять частей.
//
// Параметры:
//	ДелимаяТаблица		 - ТаблицаЗначений - Разделяемая таблица.
//	КлючевойРесурс		 - Строка - Имя поля ресурса, который подвергается делению.
//		Ключевой ресурс должен быть положительным числом.
//	Делители			 - Массив - Массив значений ресурса, на которые надо разделить исходную таблицу. Элемент: Число. 
//		Каждый делитель должен быть положительным числом.
//	ВедомыеРесурсы		 - Строка - Имена колонок делимой таблицы через запятую.
//		Значения в этих колонках в новой таблице будут распределены пропорционально значению ключевого ресурса.
//	СтрокиПоДелителям	 - Массив - Содержит строки, сгруппированные по делителям. 
//		Количество и порядок элементов соответствет делителям.
//		Элемент: Массив строк результирующей таблицы
//	КорреспонденцияСтрок - Соответствие - Отображает, какая строка исходной таблицы каким строкам целевой таблицы соответствует.
//		Ключ: СтрокаТаблицыЗначений, Значение: Массив элеметов типа СтрокаТаблицыЗначений.
//
// Возвращаемое значение:
//	ТаблицаЗначений - Результирующая таблица
//
Функция РазделитьТаблицуПоРесурсу(ДелимаяТаблица, КлючевойРесурс, Делители, Знач ВедомыеРесурсы, СтрокиПоДелителям = Неопределено, КорреспонденцияСтрок = Неопределено)
	
	Если Ложь Тогда ДелимаяТаблица = Новый ТаблицаЗначений КонецЕсли;
	Если Ложь Тогда Делители = Новый Массив КонецЕсли;
	
	#Область РезультирующаяТаблица
	
	РезультирующаяТаблица = ДелимаяТаблица.Скопировать();
	ИсходныеСтроки = Новый Соответствие;	// Для каждой строки результата содержит исходную строку
	Для Индекс = 0 По РезультирующаяТаблица.Количество() - 1 Цикл
		
		ИсходнаяСтрока = ДелимаяТаблица[Индекс];
		РезультирующаяСтрока = РезультирующаяТаблица[Индекс];
		ИсходныеСтроки.Вставить(РезультирующаяСтрока, ИсходнаяСтрока);
		
	КонецЦикла;
	
	#КонецОбласти // РезультирующаяТаблица
	
	#Область РазделениеПоКлючевомуРесурсу
	
	СтрокиПоДелителям = Новый Массив(Делители.Количество());
	Для ИндексДелителя = 0 По Делители.ВГраница() Цикл
		СтрокиПоДелителям.Установить(ИндексДелителя, Новый Массив);
	КонецЦикла; 
	
	ИндексРезультата = -1;
	МаксИндексРезультирующейТаблицы = РезультирующаяТаблица.Количество() - 1;
	ВсегоМожноРазделить	 = ДелимаяТаблица.Итог(КлючевойРесурс);
	ВсегоРазделено		 = 0;
	Для ИндексДелителя = 0 По Делители.ВГраница() Цикл
		Делитель = Делители[ИндексДелителя];
		СтрокиПоДелителю = СтрокиПоДелителям[ИндексДелителя];
		Банк = Делитель;
		Пока Банк > 0 Цикл
			Если ВсегоРазделено >= ВсегоМожноРазделить Тогда
				Прервать;
			КонецЕсли; 
			ИндексРезультата = ИндексРезультата + 1;
			СтрокаРезультата = РезультирующаяТаблица[ИндексРезультата];
			ИсходнаяСтрока = ИсходныеСтроки[СтрокаРезультата];
			Делимое = СтрокаРезультата[КлючевойРесурс];
			Транш = Мин(Банк, Делимое);
			РазделятьИсходнуюСтроку = (Транш < Делимое);
			Если РазделятьИсходнуюСтроку Тогда
				НоваяСтрокаРезультата = РезультирующаяТаблица.Добавить();
				ЗаполнитьЗначенияСвойств(НоваяСтрокаРезультата, СтрокаРезультата);
				НоваяСтрокаРезультата[КлючевойРесурс] = НоваяСтрокаРезультата[КлючевойРесурс] - Транш;
				СтрокаРезультата[КлючевойРесурс] = Транш;
				РезультирующаяТаблица.Сдвинуть(НоваяСтрокаРезультата, ИндексРезультата - РезультирующаяТаблица.Индекс(НоваяСтрокаРезультата) + 1);
				
				ИсходныеСтроки.Вставить(НоваяСтрокаРезультата, ИсходнаяСтрока);			// Запоминаем в исходную строку
				
				МаксИндексРезультирующейТаблицы = МаксИндексРезультирующейТаблицы + 1;
			КонецЕсли;
			СтрокиПоДелителю.Добавить(СтрокаРезультата);
			ВсегоРазделено = ВсегоРазделено + Транш;
			Банк = Банк - Транш;
		КонецЦикла;
		Если ИндексРезультата >= МаксИндексРезультирующейТаблицы Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	// Подготовим не попадающие строки результата к удалению
	УдаляемыеСтрокиРезультата = Новый Массив;
	Для ИндексРезультата = (ИндексРезультата + 1) По МаксИндексРезультирующейТаблицы Цикл
		УдаляемыеСтрокиРезультата.Добавить(РезультирующаяТаблица[ИндексРезультата]);
	КонецЦикла; 
	
	#КонецОбласти // РазделениеПоКлючевомуРесурсу
	
	#Область ВедомыеРесурсы
	
	ВедомыеРесурсыМассив = СтрРазделить(ВедомыеРесурсы, ", ", Ложь);
	
	РаспределятьВедомыеРесурсы = ЗначениеЗаполнено(ВедомыеРесурсы);
	
	Если РаспределятьВедомыеРесурсы Тогда
		
		#Область КорреспонденцияСтрок
		КорреспонденцияСтрок = Новый Соответствие; // {СтрокаТаблицыЗначений; Массив{СтрокаТаблицыЗначений}} - исходные строки и получившиеся в результате разделения строки
		Для каждого Элемент Из ИсходныеСтроки Цикл
			ИсходнаяСтрока		 = Элемент.Значение;
			РезультирующаяСтрока = Элемент.Ключ;
			СтрокиРезультата = КорреспонденцияСтрок[Элемент.Значение];
			Если СтрокиРезультата = Неопределено Тогда
				СтрокиРезультата = Новый Массив;
				КорреспонденцияСтрок.Вставить(ИсходнаяСтрока, СтрокиРезультата);
			КонецЕсли; 
			СтрокиРезультата.Добавить(РезультирующаяСтрока);
		КонецЦикла; 
		#КонецОбласти // КорреспонденцияСтрок 
		
		Для каждого ЭлементКорреспонденции Из КорреспонденцияСтрок Цикл
			
			ИсходнаяСтрока	 = ЭлементКорреспонденции.Ключ;
			СтрокиРезультата = ЭлементКорреспонденции.Значение;
			
			Если СтрокиРезультата.Количество() = 1 Тогда Продолжить КонецЕсли; 
			
			Для каждого ВедомыйРесурс Из ВедомыеРесурсыМассив Цикл
				
				// Подготовим распределение:
				РаспределяемаяСумма = ИсходнаяСтрока[ВедомыйРесурс];
				Коэффициенты = Новый Массив;
				Для каждого СтрокаРезультата Из СтрокиРезультата Цикл
					Коэффициенты.Добавить(СтрокаРезультата[КлючевойРесурс]);
				КонецЦикла; 
				Точность = РезультирующаяТаблица.Колонки[ВедомыйРесурс].ТипЗначения.КвалификаторыЧисла.РазрядностьДробнойЧасти;
				
				// Распределение, аналогичное БСП.РаспределитьСуммуПропорциональноКоэффициентам()
				#Область РаспределениеПропорционально
			
				ИндексМаксимальногоКоэффициента = 0;
				МаксимальныйКоэффициент = 0;
				РаспределеннаяСумма = 0;
				СуммаКоэффициентов  = 0;
		
				Для Индекс = 0 По Коэффициенты.Количество() - 1 Цикл
					Коэффициент = Коэффициенты[Индекс];
					
					АбсолютноеЗначениеКоэффициента = ?(Коэффициент > 0, Коэффициент, - Коэффициент);
					Если МаксимальныйКоэффициент < АбсолютноеЗначениеКоэффициента Тогда
						МаксимальныйКоэффициент = АбсолютноеЗначениеКоэффициента;
						ИндексМаксимальногоКоэффициента = Индекс;
					КонецЕсли;
					
					СуммаКоэффициентов = СуммаКоэффициентов + Коэффициент;
				КонецЦикла;
		
				РезультатРаспределения = Новый Массив(Коэффициенты.Количество());
				
				Если СуммаКоэффициентов <> 0 Тогда
				
					Для Индекс = 0 По Коэффициенты.Количество() - 1 Цикл
						РезультатРаспределения[Индекс] = Окр(РаспределяемаяСумма * Коэффициенты[Индекс] / СуммаКоэффициентов, Точность, 1);
						РаспределеннаяСумма = РаспределеннаяСумма + РезультатРаспределения[Индекс];
					КонецЦикла;
				
					// Погрешности округления отнесем на коэффициент с максимальным весом.
					Если Не РаспределеннаяСумма = РаспределяемаяСумма Тогда
						РезультатРаспределения[ИндексМаксимальногоКоэффициента] = РезультатРаспределения[ИндексМаксимальногоКоэффициента] + РаспределяемаяСумма - РаспределеннаяСумма;
					КонецЕсли;
					
				Иначе
					
					Для Индекс = 0 по РезультатРаспределения.ВГраница() Цикл
						РезультатРаспределения.Вставить(Индекс, 0);						
					КонецЦикла; 
					
				КонецЕсли; 

				#КонецОбласти // РаспределениеПропорционально 			
				
				// Применяем результаты распределения:
				Для Индекс = 0 По Коэффициенты.ВГраница() Цикл
					СтрокиРезультата[Индекс][ВедомыйРесурс] = РезультатРаспределения[Индекс];
				КонецЦикла;  
				
			КонецЦикла; 
		
		КонецЦикла; 				
	
	КонецЕсли;	// РаспределятьВедомыеРесурсы
	
	#КонецОбласти // ВедомыеРесурсы
	
	// Удалим лишние строки результата:
	Для каждого Строка Из УдаляемыеСтрокиРезультата Цикл
		РезультирующаяТаблица.Удалить(Строка);
	КонецЦикла; 
	
	Возврат РезультирующаяТаблица;
	
КонецФункции // РазделитьТаблицуПоРесурсу()

#КонецОбласти // ТаблицаЗначений

#Область ДеревоЗначений

// Получает различные значения указанных полей дерева значений.
//
// Параметры:
//  Узел	 - ДеревоЗначений	 - Дерево значений
//  Колонки	 - Строка			 - Имена получаемых полей
//  Значения - Неопределено		 - (служебный)
// 
// Возвращаемое значение:
//  ТаблицаЗначений - Полученные значения.
//
Функция ПолучитьРазличныеЗначенияКолонкиДереваЗначений(Узел, ИмяКолонки, Значения = Неопределено)
	
	ЭтоНачалоРекурсии = Значения = Неопределено;

	Если ТипЗнч(Узел) = Тип("СтрокаДереваЗначений") Тогда
		
		Значения.Вставить(Узел[ИмяКолонки]);
		Для каждого Ветвь Из Узел.Строки Цикл
			ПолучитьРазличныеЗначенияКолонкиДереваЗначений(Ветвь, ИмяКолонки, Значения)
		КонецЦикла;
	
	ИначеЕсли ТипЗнч(Узел) = Тип("ДеревоЗначений") Тогда
		
		Значения = Новый Соответствие;
		
		Для каждого Ветвь Из Узел.Строки Цикл
			ПолучитьРазличныеЗначенияКолонкиДереваЗначений(Ветвь, ИмяКолонки, Значения)
		КонецЦикла;
		
	ИначеЕсли ТипЗнч(Узел) = Тип("Строка") и ЭтоАдресВременногоХранилища(Узел) Тогда
		
		Возврат ПолучитьРазличныеЗначенияКолонкиДереваЗначений(ПолучитьИзВременногоХранилища(Узел), ИмяКолонки);
		
	КонецЕсли; 
	
	Если ЭтоНачалоРекурсии Тогда // Формируем результирующий массив
		
		МассивЗначений = Новый Массив;
		Для каждого Элемент Из Значения Цикл
			МассивЗначений.Добавить(Элемент.Ключ);
		КонецЦикла; 
		
		Возврат МассивЗначений;
			
	КонецЕсли; 
	
	Возврат Значения;

КонецФункции // ПолучитьРазличныеЗначенияКолонкиДереваЗначений()

// Получает различные значения указанного поля дерева значений.
//
// Параметры:
//  Узел					 - Строка, ДеревоЗначений, СтрокаДереваЗначений - Дерево значений, или его адрес во временном хранилище
//  ИмяКолонки				 - Строка			 - Имена получаемой колонки
//  ПромежуточнаяКоллекция	 - Неопределено		 - (служебный)
// 
// Возвращаемое значение:
//  Массив - Полученные значения.
//
Функция ПолучитьРазличныеЗначенияКолонкиДереваЗначений(Узел, ИмяКолонки, ПромежуточнаяКоллекция = Неопределено)
	
	ЭтоНачалоРекурсии = ПромежуточнаяКоллекция = Неопределено;

	Если ТипЗнч(Узел) = Тип("СтрокаДереваЗначений") Тогда
		
		ПромежуточнаяКоллекция.Вставить(Узел[ИмяКолонки]);
		Для каждого Ветвь Из Узел.Строки Цикл
			ПолучитьРазличныеЗначенияКолонкиДереваЗначений(Ветвь, ИмяКолонки, ПромежуточнаяКоллекция)
		КонецЦикла;
	
	ИначеЕсли ТипЗнч(Узел) = Тип("ДеревоЗначений") Тогда
		
		ПромежуточнаяКоллекция = Новый Соответствие;
		
		Для каждого Ветвь Из Узел.Строки Цикл
			ПолучитьРазличныеЗначенияКолонкиДереваЗначений(Ветвь, ИмяКолонки, ПромежуточнаяКоллекция)
		КонецЦикла;
		
	ИначеЕсли ТипЗнч(Узел) = Тип("Строка") и ЭтоАдресВременногоХранилища(Узел) Тогда
		
		ДеревоДанных = ПолучитьИзВременногоХранилища(Узел);
		Если ТипЗнч(ДеревоДанных) = Тип("ДеревоЗначений") Тогда
			Возврат ПолучитьРазличныеЗначенияКолонкиДереваЗначений(ДеревоДанных, ИмяКолонки);
		Иначе
			Возврат Новый Массив;
		КонецЕсли; 
		
	КонецЕсли; 
	
	Если ЭтоНачалоРекурсии и ПромежуточнаяКоллекция <> Неопределено Тогда // Формируем результирующий массив
		
		МассивЗначений = Новый Массив;
		Для каждого Элемент Из ПромежуточнаяКоллекция Цикл
			МассивЗначений.Добавить(Элемент.Ключ);
		КонецЦикла; 
		
		Возврат МассивЗначений;
			
	КонецЕсли; 
	
	Возврат ПромежуточнаяКоллекция;

КонецФункции // ПолучитьРазличныеЗначенияКолонокДереваЗначений()

// Получает адресацию конечных листьев, содержащих значения определенной колонки
//
// Параметры:
//  Узел		 - ДеревоЗначений, СтрокаДереваЗначений	 - Дерево значений, или его строка
//	ИмяКолонки	 - Строка	 - Имя колонки, содержащей перечень искодных значений
//  ТолькоЛистья - Булево	 - Если Истина - то расположение значений получается только для листьев дерева значений
// 
// Возвращаемое значение:
//  Соответствие - Тип ключа соответствует типу значений в колонке, Значение - Массив, содержащий узлы коллекции.
//
Функция РасположениеЗначенийКолонкиДереваЗначенийРекурсивно(Узел, ИмяКолонки, ТолькоЛистья = Ложь)

	Расположение = Новый Соответствие;	// {Произвольный; Массив:СтрокаДереваЗначений}

	Для каждого Ветвь Из Узел.Строки Цикл

		ЭтоЛист = не ЗначениеЗаполнено(Ветвь.Строки);

		Если ЭтоЛист или не ТолькоЛистья Тогда
			Если Расположение[Ветвь[ИмяКолонки]] = Неопределено Тогда
				Расположение[Ветвь[ИмяКолонки]] = Новый Массив;
			КонецЕсли;
			Расположение[Ветвь[ИмяКолонки]].Добавить(Ветвь);
		КонецЕсли;

		Для каждого Элемент Из РасположениеЗначенийКолонкиДереваЗначенийРекурсивно(Ветвь, ТолькоВидимые, ТолькоДоступные) Цикл
			РасположениеЗначения = Расположение.Получить(Элемент.Ключ);
			Если РасположениеЗначения = Неопределено Тогда
				Расположение.Вставить(Элемент.Ключ, Элемент.Значение);
			Иначе
				Для каждого Лист Из Элемент.Значение Цикл
					РасположениеЗначения.Добавить(Лист);	
				КонецЦикла; 
			КонецЕсли;
		КонецЦикла;
		
	КонецЦикла; 	
	
	Возврат Расположение;

КонецФункции // РасположениеЗначенийКолонкиДереваЗначенийРекурсивно()

#КонецОбласти	// ДеревоЗначений

#Область ПреобразованиеЗначений

// Формирует дерево значений по сгруппированой таблице значений
//
// Параметры:
//  ИсходнаяТаблица	 - ТаблицаЗначений		 - Исходная таблица значений
//  Группировки		 - Строка, Массив		 - Имена колонок группировок таблицы. Варианты использования:
//		* Строка - Имена полей, разделенные запятой
//		* Массив - Одна группировка может состоять из нескольких полей, разделенных запятыми. 
//  Ресурсы			 - Строка, Массив, Соответствие	 - Итоги дерева. Варианты использования:
//		* Строка		 - Имена полей итогов, разделенных запятой. Каждый итог считается как Сумма.
//		* Массив		 - Имена полей итогов. Каждый итог считается как Сумма.
//		* Соответствие	 - Ключ: Имя поля, Значение - Выражение языка компоновки данных для подсчёта ресурса. Например, "Сумма(Ресурс)"
// 
// Возвращаемое значение:
//   - ДеревоЗначений - Полученное дерево значений
//
Функция ТаблицаЗначенийВДеревоЗначенийКомпоновкой(ИсходнаяТаблица, Группировки, Ресурсы = Неопределено)

	Если Ложь Тогда ИсходнаяТаблица = Новый ТаблицаЗначений КонецЕсли;
	
	СхемаКомпоновки = Новый СхемаКомпоновкиДанных;
	ИсточникДанных = СхемаКомпоновки.ИсточникиДанных.Добавить();
	ИсточникДанных.Имя					 = "Local";
	ИсточникДанных.ТипИсточникаДанных	 = "Local";
	ИсточникДанных.СтрокаСоединения		 = "Local";
	
	#Область НаборДанных
	НаборДанныхОбъект = СхемаКомпоновки.НаборыДанных.Добавить(Тип("НаборДанныхОбъектСхемыКомпоновкиДанных"));
	НаборДанныхОбъект.ИсточникДанных = СхемаКомпоновки.ИсточникиДанных[0].Имя;
	НаборДанныхОбъект.Имя		 = "Исходная таблица";
	НаборДанныхОбъект.ИмяОбъекта = "ИсходнаяТаблица";
	ПоляНабора = НаборДанныхОбъект.Поля;
	Для каждого Колонка Из ИсходнаяТаблица.Колонки Цикл
		ПолеНабора = ПоляНабора.Добавить(Тип("ПолеНабораДанныхСхемыКомпоновкиДанных"));
		ПолеНабора.Поле			 = Колонка.Имя;
		ПолеНабора.ТипЗначения	 = Колонка.ТипЗначения;
		ПолеНабора.Заголовок	 = Колонка.Заголовок;
		ПолеНабора.ПутьКДанным	 = ПолеНабора.Поле;
	КонецЦикла; 		
	#КонецОбласти // НаборДанных 
	
	#Область Ресурсы
	Если ТипЗнч(Ресурсы) = Тип("Строка") 
		Или ТипЗнч(Ресурсы) = Тип("Массив") Тогда
		
		РесурсыМассив = ?(ТипЗнч(Ресурсы) = Тип("Строка"), СтрРазделить(Ресурсы, ", ", Ложь), Ресурсы);
		РесурсыСоответствие = Новый Соответствие;
		Для каждого Ресурс Из РесурсыМассив Цикл
			РесурсыСоответствие.Вставить(Ресурс, СтрШаблон("Сумма(%1)", Ресурс));
		КонецЦикла; 
	ИначеЕсли ТипЗнч(Ресурсы) = Тип("Соответствие") Тогда
		РесурсыСоответствие = Ресурсы;
	Иначе
		РесурсыСоответствие = Новый Соответствие;
	КонецЕсли; 
	
	ПоляИтогаСхемы = СхемаКомпоновки.ПоляИтога;
	Для каждого Элемент Из РесурсыСоответствие Цикл
		ПолеИтога = ПоляИтогаСхемы.Добавить();
		ПолеИтога.ПутьКДанным	 = Элемент.Ключ;
		ПолеИтога.Выражение		 = Элемент.Значение;
	КонецЦикла; 
	#КонецОбласти // Ресурсы 
	
	#Область Настройки
		
	#Область Структура
	ГруппировкиМассив = ?(ТипЗнч(Группировки) = Тип("Массив"), Группировки, СтрРазделить(Группировки, ", ", Ложь));
	КоллекцияЭлементовСтруктуры = СхемаКомпоновки.ВариантыНастроек[0].Настройки.Структура;
	Для каждого ГруппировкаСтрока Из ГруппировкиМассив Цикл
		Группировка = КоллекцияЭлементовСтруктуры.Добавить(Тип("ГруппировкаКомпоновкиДанных")); 
		Для каждого ИмяПоля Из СтрРазделить(ГруппировкаСтрока, ", ", Ложь) Цикл
			Группировка.ПоляГруппировки.Элементы.Добавить(Тип("ПолеГруппировкиКомпоновкиДанных")).Поле = Новый ПолеКомпоновкиДанных(ИмяПоля);
		КонецЦикла; 
		Группировка.Выбор.Элементы.Добавить(Тип("АвтоВыбранноеПолеКомпоновкиДанных"));
		КоллекцияЭлементовСтруктуры = Группировка.Структура;
	КонецЦикла;
	Группировка = КоллекцияЭлементовСтруктуры.Добавить(Тип("ГруппировкаКомпоновкиДанных"));
	Группировка.ПоляГруппировки.Элементы.Добавить(Тип("АвтоПолеГруппировкиКомпоновкиДанных"));
	Группировка.Выбор.Элементы.Добавить(Тип("АвтоВыбранноеПолеКомпоновкиДанных"));
	#КонецОбласти // Структура 
	
	#Область ВыбранныеПоля
	ВыбранныеПоля = СхемаКомпоновки.ВариантыНастроек[0].Настройки.Выбор;
	Для каждого ПолеНабора Из НаборДанныхОбъект.Поля Цикл
		ВыбранныеПоля.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных")).Поле = Новый ПолеКомпоновкиДанных(ПолеНабора.ПутьКДанным);		
	КонецЦикла; 
	Для каждого ВычисляемоеПоле Из СхемаКомпоновки.ВычисляемыеПоля Цикл
		ВыбранныеПоля.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных")).Поле = Новый ПолеКомпоновкиДанных(ВычисляемоеПоле.ПутьКДанным);		
	КонецЦикла; 
	#КонецОбласти // ВыбранныеПоля 
	
	#Область Параметрывывода
	СхемаКомпоновки.ВариантыНастроек[0].Настройки.ПараметрыВывода.УстановитьЗначениеПараметра(Новый ПараметрКомпоновкиДанных("ВертикальноеРасположениеОбщихИтогов"), РасположениеИтоговКомпоновкиДанных.Нет);
	#КонецОбласти // Параметрывывода 
	
	#КонецОбласти // Настройки 
	
	#Область КомпоновкаДанныхДляКоллекцииЗначений
	ВнешниеНаборыДанных		 = Новый Структура;
	ВнешниеНаборыДанных.Вставить("ИсходнаяТаблица", ИсходнаяТаблица);
	ВозможностьИспользованияВнешнихФункций = Истина;
	
	КомпоновщикНастроек = Новый КомпоновщикНастроекКомпоновкиДанных;
	КомпоновщикНастроек.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаКомпоновки));
	КомпоновщикНастроек.ЗагрузитьНастройки(СхемаКомпоновки.НастройкиПоУмолчанию);
	
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	МакетКомпоновки = КомпоновщикМакета.Выполнить(СхемаКомпоновки, КомпоновщикНастроек.ПолучитьНастройки(), , , Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"));
	
	ПроцессорКомпоновки = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновки.Инициализировать(МакетКомпоновки, ВнешниеНаборыДанных, , ВозможностьИспользованияВнешнихФункций);
	
	РезультатКомпоновки = Новый ДеревоЗначений;
	
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	ПроцессорВывода.УстановитьОбъект(РезультатКомпоновки);
	ПроцессорВывода.Вывести(ПроцессорКомпоновки);
	#КонецОбласти // КомпоновкаДанныхДляКоллекцииЗначений 	

	Возврат РезультатКомпоновки;
	
КонецФункции // ТаблицаЗначенийВДеревоЗначенийКомпоновкой()

#КонецОбласти // ПреобразованиеЗначений

// Проверяет существование ссылки в ИБ.
//	Функция - аналог БСП.СсылкаСуществует()
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - значение любой ссылки информационной базы данных
// 
// Возвращаемое значение:
//	Булево - Истина, если ссылка физически существует
//
Функция СсылкаСуществует(Ссылка) Экспорт
	
    ТекстЗапроса = "
	|ВЫБРАТЬ ПЕРВЫЕ 1	ИСТИНА
	|ИЗ					&ИмяТаблицы
	|ГДЕ				Ссылка = &Ссылка
	|";
	
    ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяТаблицы", Метаданные.НайтиПоТипу(ТипЗнч(Ссылка)).ПолноеИмя());
    
    Запрос = Новый Запрос;
    Запрос.Текст = ТекстЗапроса;
    Запрос.УстановитьПараметр("Ссылка", Ссылка);
    
    УстановитьПривилегированныйРежим(Истина);
    
    Возврат НЕ Запрос.Выполнить().Пустой();
    
КонецФункции // СсылкаСуществует()

// По навигационной ссылке получает ссылку на объект.
//
// Параметры:
//  НавигационнаяСсылка		 - Строка					 - Навигационная ссылка
//	УникальныйИдентификатор	 - УникальныйИдентификатор	 - Уникальный идентификатор объекта из навигационной ссылки
//  ИмяРеквизита			 - Строка					 - Имя реквизита объекта или колонки табличной части, если указано в навигационной ссылке.
//  ИмяТабличнойЧасти		 - Строка					 - Имя табличной части, если указано в навигационной ссылке.
//  ИндексТабЧасти			 - Число					 - Индекс в табличной части, если указан в навигационной ссылке.
// 
// Возвращаемое значение:
//  Ссылка - Если определить ссылку не удалось - возвращается Неопределено.
//
Функция СсылкаНаОбъектНавигационнойСсылки(НавигационнаяСсылка, ИмяРеквизита = Неопределено, ИмяТабличнойЧасти = Неопределено, ИндексТабЧасти = Неопределено)
	
	// Форматы ссылок (см. https://its.1c.ru/db/v8doc):
	// e1cib/data/<путькметаданным>?ref=<идентификаторссылки>
	// e1cib/data/<путькметаданным>.<имяреквизита>?ref=<идентификаторссылки>
	// e1cib/data/<путькметаданным>.<имятабличнойчасти>.<имяреквизита>?ref=<идентификаторссылки>&index=<индексстрокитабличнойчасти>
	
	ОперандДанных	 = "e1cib/data/";
	ОперандСсылки	 = "?ref=";
	ОперандИндекса	 = "&index=";
	
	ПозицияОперандаДанных	 = СтрНайти(НавигационнаяСсылка, ОперандДанных);
	ПозицияОперандаСсылки	 = СтрНайти(НавигационнаяСсылка, ОперандСсылки);
	ПозицияОперандаИндекса	 = СтрНайти(НавигационнаяСсылка, ПозицияОперандаИНдекса);
	
	ЕстьСсылка = Булево(ПозицияОперандаДанных) и Булево(ПозицияОперандаСсылки); 		
	Если не ЕстьСсылка Тогда Возврат Неопределено КонецЕсли;
	
	ПолноеИмяМетаданныхСсылки = Сред(
	НавигационнаяСсылка, 
	ПозицияОперандаДанных + СтрДлина(ОперандДанных),
	(ПозицияОперандаСсылки - 1) - (ПозицияОперандаДанных - 1 + СтрДлина(ОперандДанных))
	);
	
	СтекИмени = СтрРазделить(ПолноеИмяМетаданныхСсылки, ".", Ложь);
	Если СтекИмени.ВГраница() < 1 Тогда Возврат Неопределено КонецЕсли; 
	
	ИмяОбъектаМетаданных = СтекИмени[1];
	ПолноеИмяМетаданного = СтекИмени[0] + "." + СтекИмени[1];	// напр. Документ.ИмяДокумента
	
	ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ПолноеИмяМетаданного);
	Если ОбъектМетаданных = Неопределено Тогда Возврат Неопределено КонецЕсли; 
	
	УникальныйИдентификаторШестнЧисло = Сред(НавигационнаяСсылка, ПозицияОперандаСсылки + СтрДлина(ОперандСсылки), 32);
	
	УникальныйИдентификатор = УникальныйИдентификаторИзШестнадцатеричногоЧисла(УникальныйИдентификаторШестнЧисло);	// см. ОбщегоНазначенияКлиентСервер
	Если УникальныйИдентификатор = Неопределено Тогда Возврат Неопределено КонецЕсли; 
	
	Если		 Метаданные.Документы				.Содержит(ОбъектМетаданных) Тогда Ссылка = Документы				[ИмяОбъектаМетаданных].ПолучитьСсылку(УникальныйИдентификатор);
	ИначеЕсли	 Метаданные.Справочники				.Содержит(ОбъектМетаданных) Тогда Ссылка = Справочники				[ИмяОбъектаМетаданных].ПолучитьСсылку(УникальныйИдентификатор);
	ИначеЕсли	 Метаданные.ПланыВидовХарактеристик	.Содержит(ОбъектМетаданных) Тогда Ссылка = ПланыВидовХарактеристик	[ИмяОбъектаМетаданных].ПолучитьСсылку(УникальныйИдентификатор);
	ИначеЕсли	 Метаданные.ПланыСчетов				.Содержит(ОбъектМетаданных) Тогда Ссылка = ПланыСчетов				[ИмяОбъектаМетаданных].ПолучитьСсылку(УникальныйИдентификатор);
	ИначеЕсли	 Метаданные.ПланыВидовРасчета		.Содержит(ОбъектМетаданных) Тогда Ссылка = ПланыВидовРасчета		[ИмяОбъектаМетаданных].ПолучитьСсылку(УникальныйИдентификатор);
	ИначеЕсли	 Метаданные.ПланыОбмена				.Содержит(ОбъектМетаданных) Тогда Ссылка = ПланыОбмена				[ИмяОбъектаМетаданных].ПолучитьСсылку(УникальныйИдентификатор);
	ИначеЕсли	 Метаданные.Задачи					.Содержит(ОбъектМетаданных) Тогда Ссылка = Задачи					[ИмяОбъектаМетаданных].ПолучитьСсылку(УникальныйИдентификатор);
	ИначеЕсли	 Метаданные.БизнесПроцессы			.Содержит(ОбъектМетаданных) Тогда Ссылка = БизнесПроцессы			[ИмяОбъектаМетаданных].ПолучитьСсылку(УникальныйИдентификатор);
	Иначе Возврат Неопределено;
	КонецЕсли; 	
	
	ЕстьИмяТабличнойЧасти	 = СтекИмени.ВГраница() = 3;
	ЕстьРеквизит			 = СтекИмени.ВГраница() >= 2;

	Если ЕстьИмяТабличнойЧасти и ЕстьРеквизит Тогда	
		ИмяРеквизита		 = СтекИмени[3];
		ИмяТабличнойЧасти	 = СтекИмени[2];
		ЕстьИндекс = Булево(ПозицияОперандаИндекса);
		Если ЕстьИндекс Тогда
			ИндексТабЧастиСтрокой = Сред(НавигационнаяСсылка, ПозицияОперандаИндекса + СтрДлина(ОперандИндекса));
			Если ЗначениеЗаполнено(ИндексТабЧастиСтрокой) Тогда
				ИндексТабЧасти = Число(ИндексТабЧастиСтрокой);
			иначе
				ИндексТабЧасти = 0;
			КонецЕсли; 
		КонецЕсли; 
	ИначеЕсли ЕстьРеквизит Тогда
		ИмяРеквизита = СтекИмени[2];
	КонецЕсли; 
	
	Возврат Ссылка;
	
КонецФункции // СсылкаНаОбъектНавигационнойСсылки()

// Получает программный код для получения указанной ссылки через уникальный идентификатор
//
// Параметры:
//  СсылкаНаОбъект	 - ЛюбаяСсылка	 - Ссылка на объект.
// 
// Возвращаемое значение:
//  Строка - Команда для получения ссылки. Например: "Справочники.Номенклатура.ПолучитьСсылку(Новый УникальныйИдентификатор("00112233-4455-6677-8899-aabbccddeeff"))"
//
Функция ТекстМодуляПолученияСсылки(СсылкаНаОбъект)
	
	ТекстМодуля = "Неопределено";
		
	ОбъектМетаданных = СсылкаНаОбъект.Метаданные();
	
	Если		 Метаданные.Документы				.Содержит(ОбъектМетаданных) Тогда ИмяМенеджера = "Документы";
	ИначеЕсли	 Метаданные.Справочники				.Содержит(ОбъектМетаданных) Тогда ИмяМенеджера = "Справочники";
	ИначеЕсли	 Метаданные.ПланыВидовХарактеристик	.Содержит(ОбъектМетаданных) Тогда ИмяМенеджера = "ПланыВидовХарактеристик";
	ИначеЕсли	 Метаданные.ПланыСчетов				.Содержит(ОбъектМетаданных) Тогда ИмяМенеджера = "ПланыСчетов";
	ИначеЕсли	 Метаданные.ПланыВидовРасчета		.Содержит(ОбъектМетаданных) Тогда ИмяМенеджера = "ПланыВидовРасчета";
	ИначеЕсли	 Метаданные.ПланыОбмена				.Содержит(ОбъектМетаданных) Тогда ИмяМенеджера = "ПланыОбмена";
	ИначеЕсли	 Метаданные.Задачи					.Содержит(ОбъектМетаданных) Тогда ИмяМенеджера = "Задачи";
	ИначеЕсли	 Метаданные.БизнесПроцессы			.Содержит(ОбъектМетаданных) Тогда ИмяМенеджера = "БизнесПроцессы";
	Иначе Возврат ТекстМодуля;
	КонецЕсли; 	
	
	Если Не СсылкаНаОбъект.Пустая() Тогда
		ТекстМодуля = СтрШаблон(
			"%1.%2.ПолучитьСсылку(Новый УникальныйИдентификатор(""%3""))",
			ИмяМенеджера,
			ОбъектМетаданных.Имя,
			СсылкаНаОбъект.УникальныйИдентификатор()
		);
	Иначе
		ТекстМодуля = СтрШаблон(
			"%1.%2.ПустаяСсылка()",
			ИмяМенеджера,
			ОбъектМетаданных.Имя
		);
	КонецЕсли;
	
	Возврат ТекстМодуля;

КонецФункции // ТекстМодуляПолученияСсылки()

#Область СлучайныеЗначения

Процедура ЗаполнитьТаблицуЗначенийСлучайнымиЗначениями_АвтоТест()

	
	ЗаполняемаяТаблица = Новый ТаблицаЗначений;
	ЗаполняемаяТаблица.Колонки.Добавить("Числовая",						 новый ОписаниеТипов("Число"));
	ЗаполняемаяТаблица.Колонки.Добавить("ЧисловаяФиксНеотриц",			 новый ОписаниеТипов("Число", , , Новый КвалификаторыЧисла(15, 2, ДопустимыйЗнак.Неотрицательный)));
	ЗаполняемаяТаблица.Колонки.Добавить("ЧисловаяФиксНеотрицПереопред",	 новый ОписаниеТипов("Число", , , Новый КвалификаторыЧисла(15, 2, ДопустимыйЗнак.Неотрицательный)));
	ЗаполняемаяТаблица.Колонки.Добавить("Булевая",						 новый ОписаниеТипов("Булево"));
	ЗаполняемаяТаблица.Колонки.Добавить("УИД",							 новый ОписаниеТипов("УникальныйИдентификатор"));
	ЗаполняемаяТаблица.Колонки.Добавить("СтроковаяНеогр",				 новый ОписаниеТипов("Строка"));
	ЗаполняемаяТаблица.Колонки.Добавить("Строковая64Перем",				 новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(64, ДопустимаяДлина.Переменная)));
	ЗаполняемаяТаблица.Колонки.Добавить("Строковая32Фикс",				 новый ОписаниеТипов("Строка",,,, Новый КвалификаторыСтроки(32, ДопустимаяДлина.Фиксированная)));
	ЗаполняемаяТаблица.Колонки.Добавить("Датированная",					 новый ОписаниеТипов("Дата"));
	ЗаполняемаяТаблица.Колонки.Добавить("ДатированнаяТолькоВремя",		 новый ОписаниеТипов("Дата",,,,, Новый КвалификаторыДаты(ЧастиДаты.Время)));
	
	ЗаполняемаяТаблица.Колонки.Добавить("ДатаЧислоСтрока", Новый ОписаниеТипов("Строка, Дата, Число",
														   Новый КвалификаторыЧисла(3, 0, ДопустимыйЗнак.Любой),
														   Новый КвалификаторыСтроки(6, ДопустимаяДлина.Переменная),
														   Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя)));

	КоличествоСтрокТаблицы = 128;
	Для НомерСтроки = 1 По КоличествоСтрокТаблицы Цикл ЗаполняемаяТаблица.Добавить() КонецЦикла;
	
	ПереопределениеТиповКолонок = Новый Соответствие;
	ПереопределениеТиповКолонок.Вставить("ЧисловаяФиксНеотрицПереопред", новый ОписаниеТипов("Число", , , Новый КвалификаторыЧисла(5, 1, ДопустимыйЗнак.Неотрицательный)));
	
	МеткаВремени = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	ЗаполнитьТаблицуЗначенийСлучайнымиЗначениями(ЗаполняемаяТаблица, , ПереопределениеТиповКолонок, Истина);
	
	ВремяЗаполнения = ТекущаяУниверсальнаяДатаВМиллисекундах() - МеткаВремени;	
	
	ОписаниеТипов = Новый ОписаниеТипов("Неопределено");
	
КонецПроцедуры

// Заполняет таблицу случайными значениями
//
// Параметры:
//  ЗаполняемаяТаблица				 - ТаблицаЗначений	 - Заполняемая таблица
//  ЗаполняемыеКолонки			 - Строка			 - Имена заполняемых колонок, через запятые. Если не указан - заполняются все колонки.
//  ПереопределениеТиповКолонок	 - Соответствие		 - Типы значений, которыми заполняются колонки. 
//		Если не указан, или заполняемая колонка отсутствует в соответствии, типы определяются типом значений колонки.
//		Ключ	 - Строка		 - Имя колонки
//		Значение - ОписаниеТипов - Типы случайных значений для заполнения колонки
//  ИспользоватьНеопределено	 - Булево			 - Если колонка составного типа - будут присутствовать значения Неопределено.
//
Процедура ЗаполнитьТаблицуЗначенийСлучайнымиЗначениями(ЗаполняемаяТаблица, Знач ЗаполняемыеКолонки = "", ПереопределениеТиповКолонок = Неопределено, ИспользоватьНеопределено = Истина)

	Если Ложь Тогда ЗаполняемаяТаблица = Новый ТаблицаЗначений КонецЕсли;
	
	// Определяем, какие колонки будем заполнять
	Если ЗначениеЗаполнено(ЗаполняемыеКолонки) Тогда
		ИменаЗаполняемыхКолонок = СтрРазделить(ЗаполняемыеКолонки, ", ", Ложь);
	Иначе
		ИменаЗаполняемыхКолонок = Новый Массив;
		Для каждого Колонка Из ЗаполняемаяТаблица.Колонки Цикл
			ИменаЗаполняемыхКолонок.Добавить(Колонка.Имя);
		КонецЦикла; 
	КонецЕсли; 	
	
	ОписанияТиповКолонок = Новый Соответствие;
	Для каждого ИмяКолонки Из ИменаЗаполняемыхКолонок Цикл
		Если ПереопределениеТиповКолонок <> Неопределено
			И ТипЗнч(ПереопределениеТиповКолонок[ИмяКолонки]) = Тип("ОписаниеТипов") Тогда
			ОписаниеТипаКолонки = ПереопределениеТиповКолонок[ИмяКолонки];
		Иначе
			ОписаниеТипаКолонки = ЗаполняемаяТаблица.Колонки[ИмяКолонки].ТипЗначения;
		КонецЕсли; 
		ОписанияТиповКолонок.Вставить(ИмяКолонки, ОписаниеТипаКолонки);
	КонецЦикла;
	
	КоличествоЗаполняемыхЗначений = ЗаполняемаяТаблица.Количество();
	
	Для каждого ИмяКолонки Из ИменаЗаполняемыхКолонок Цикл
		ЗаполняемаяТаблица.ЗагрузитьКолонку(СлучайныеЗначения(ОписанияТиповКолонок[ИмяКолонки], КоличествоЗаполняемыхЗначений, ИспользоватьНеопределено), ИмяКолонки);
	КонецЦикла; 
	
КонецПроцедуры

// Получает коллекцию случайных значений заданного типа
// Поддерживаются типы:
//	* Число
//	* Строка
//	* Булево
//	* Дата
//	* УникальныйИдентификатор
//	* Null
//	* Неопределено
//
// Параметры:
//  ОписаниеТипов			 - ОписаниеТипов	 - Описание получаемого значения
//  КоличествоЭлементов		 - Число	 - Количество получаемых случайных значений
//  ИспользоватьНеопределено - Булево	 - Если получается значение составного типа, в коллекцию будут включаться значения Неопределено
// 
// Возвращаемое значение:
//   - Массив - Получаенные случайные значения
//
Функция СлучайныеЗначения(ОписаниеТипов, КоличествоЭлементов, ИспользоватьНеопределено = Истина)

	Если Ложь Тогда ОписаниеТипов = новый ОписаниеТипов КонецЕсли;
	
	ГенераторСлучайныхЧисел = Новый ГенераторСлучайныхЧисел(ТекущаяУниверсальнаяДатаВМиллисекундах());
	
	СлучайныеЗначения = Новый Массив;
	КоличествоТипов = ОписаниеТипов.Типы().Количество();
	
	Если КоличествоТипов = 1 Тогда
		
		Если ОписаниеТипов.СодержитТип(Тип("Число")) Тогда
			Для НомерЭлемента = 1 По КоличествоЭлементов Цикл
				СлучайныеЗначения.Добавить(СлучайноеЧисло(ОписаниеТипов.КвалификаторыЧисла, ГенераторСлучайныхЧисел));				
			КонецЦикла; 
			
		ИначеЕсли ОписаниеТипов.СодержитТип(Тип("Строка")) Тогда 	
			Для НомерЭлемента = 1 По КоличествоЭлементов Цикл
				СлучайныеЗначения.Добавить(СлучайнаяСтрока(ОписаниеТипов.КвалификаторыСтроки, , , , , , ГенераторСлучайныхЧисел));				
			КонецЦикла; 
			
		ИначеЕсли ОписаниеТипов.СодержитТип(Тип("Булево")) Тогда
			Для НомерЭлемента = 1 По КоличествоЭлементов Цикл
				СлучайныеЗначения.Добавить(Булево(ГенераторСлучайныхЧисел.СлучайноеЧисло(0, 1)));				
			КонецЦикла; 	
			
		ИначеЕсли ОписаниеТипов.СодержитТип(Тип("Дата")) Тогда
			Для НомерЭлемента = 1 По КоличествоЭлементов Цикл
				СлучайныеЗначения.Добавить(СлучайнаяДата(ОписаниеТипов.КвалификаторыДаты, , , ГенераторСлучайныхЧисел));				
			КонецЦикла; 	
			
		ИначеЕсли ОписаниеТипов.СодержитТип(Тип("УникальныйИдентификатор")) Тогда 	
			Для НомерЭлемента = 1 По КоличествоЭлементов Цикл
				СлучайныеЗначения.Добавить(Новый УникальныйИдентификатор);				
			КонецЦикла; 
			
		ИначеЕсли ОписаниеТипов.СодержитТип(Тип("Null")) Тогда 	
			Для НомерЭлемента = 1 По КоличествоЭлементов Цикл
				СлучайныеЗначения.Добавить(NULL);				
			КонецЦикла; 
			
		Иначе
			СлучайныеЗначения = Новый Массив(КоличествоЭлементов);
			
		КонецЕсли;  
		
		
	ИначеЕсли КоличествоТипов > 1 Тогда
		
		ПолученоСлучайныхЗначений = 0;
		ВсегоТиповЗначений = КоличествоТипов;
		Если ИспользоватьНеопределено Тогда
			ВсегоТиповЗначений = ВсегоТиповЗначений + 1;
		КонецЕсли; 
		
		ТаблицаСортировки = Новый ТаблицаЗначений;
		ТаблицаСортировки.Колонки.Добавить("Ид",		 Новый ОписаниеТипов("УникальныйИдентификатор"));
		ТаблицаСортировки.Колонки.Добавить("Значение",	 ОписаниеТипов);
		
		СлучайныеЗначенияПодтипов = Новый Массив;
		Для Индекс = 0 По ОписаниеТипов.Типы().ВГраница() Цикл
			
			Если Индекс < ОписаниеТипов.Типы().ВГраница() Или ИспользоватьНеопределено Тогда
				КоличествоЗначенийПодтипа = Цел(КоличествоЭлементов / ВсегоТиповЗначений);
			Иначе
				КоличествоЗначенийПодтипа = КоличествоЭлементов - ПолученоСлучайныхЗначений;
			КонецЕсли; 
			
			Подтипы = Новый Массив;
			Подтипы.Добавить(ОписаниеТипов.Типы()[Индекс]);
			ОписаниеПодтипа = Новый ОписаниеТипов(
			Подтипы, 
			ОписаниеТипов.КвалификаторыЧисла,
			ОписаниеТипов.КвалификаторыСтроки,
			ОписаниеТипов.КвалификаторыДаты,
			ОписаниеТипов.КвалификаторыДвоичныхДанных);
			
			СлучайныеЗначенияПодтипа = СлучайныеЗначения(ОписаниеПодтипа, КоличествоЗначенийПодтипа, ИспользоватьНеопределено);
			Для каждого СлучайноеЗначение Из СлучайныеЗначенияПодтипа Цикл
				Позиция = ТаблицаСортировки.Добавить();
				Позиция.Ид = новый УникальныйИдентификатор;
				Позиция.Значение = СлучайноеЗначение;
			КонецЦикла;
			
			ПолученоСлучайныхЗначений = ПолученоСлучайныхЗначений + КоличествоЗначенийПодтипа;
			
		КонецЦикла; 	
		
		Если ИспользоватьНеопределено Тогда
			Для Счетчик = 1 По КоличествоЭлементов - ПолученоСлучайныхЗначений Цикл
				Позиция = ТаблицаСортировки.Добавить();
				Позиция.Ид = новый УникальныйИдентификатор;
				Позиция.Значение = Неопределено;
			КонецЦикла; 		
		КонецЕсли; 		
		
		ТаблицаСортировки.Сортировать("Ид");
		
		СлучайныеЗначения = ТаблицаСортировки.ВыгрузитьКолонку("Значение");
		
	Иначе
		Возврат Новый Массив(КоличествоЭлементов);
		
	КонецЕсли; 
	
	Возврат СлучайныеЗначения;

КонецФункции // ПолучитьМассивСлучайныхЗначений()
 
// Получает случайное число по заданному описанию типа
//
// Параметры:
//  КвалификаторыЧисла		 - КвалификаторыЧисла	 - Описание получаемого числа. 
//		В общем случае, генерируется число вплоть до 4294967295 (см. ГенераторСлучайныхЧисел.СлучайноеЧисло())
//		При формировании числа используются параметры квалификаторав числа:
//		* ДопустимыйЗнак			 - Для получения положительного или отрицателного числа.
//		* Разрядность				 - Если не указана - получается число 
//		* РазрядностьДробнойЧасти	 - Если не указана - генерируются челые числа.
//  ГенераторСлучайныхЧисел	 - ГенераторСлучайныхЧисел	 - Если не задан, инициализируется в функции, используется повторно
// 
// Возвращаемое значение:
//   - Число   - Полученное случайное число
//
Функция СлучайноеЧисло(КвалификаторыЧисла, ГенераторСлучайныхЧисел = Неопределено)
	
	Если Ложь Тогда КвалификаторыЧисла = новый КвалификаторыЧисла КонецЕсли;
	
	ЧислоРезультат = 0;
	
	Если ГенераторСлучайныхЧисел = Неопределено Тогда
		ГенераторСлучайныхЧисел = Новый ГенераторСлучайныхЧисел(ТекущаяУниверсальнаяДатаВМиллисекундах());
	КонецЕсли; 
	
	МаксВерхГраница = Pow(2, 32) - 1;	// см. ГенераторСлучайныхЧисел.СлучайноеЧисло()
	
	ВерхняяГраница = МаксВерхГраница;
	
	ЧислоРезультат = ГенераторСлучайныхЧисел.СлучайноеЧисло(, ВерхняяГраница);
	
	Если КвалификаторыЧисла.ДопустимыйЗнак = ДопустимыйЗнак.Любой Тогда
		ЧислоРезультат = ЧислоРезультат - ГенераторСлучайныхЧисел.СлучайноеЧисло(, Цел(ВерхняяГраница / 2));
	КонецЕсли; 
	
	Если КвалификаторыЧисла.Разрядность <> 0 Тогда
		ЧислоРезультат = ЧислоРезультат % Pow(10, КвалификаторыЧисла.Разрядность);
	КонецЕсли; 
	
	Если КвалификаторыЧисла.РазрядностьДробнойЧасти <> 0 Тогда
		ЧислоРезультат = ЧислоРезультат / Pow(10, КвалификаторыЧисла.РазрядностьДробнойЧасти);
	КонецЕсли; 
	
	Возврат ЧислоРезультат

КонецФункции // СлучайноеЧисло()

// Получает случайную строку
//
// Параметры:
//  КвалификаторыСтроки		 - КвалификаторыСтроки	 - Описание типа получаемой строки. Получаются строки длиной не более 128 символов.
//  ИспользоватьЛатиницу	 - Булево	 - В состав строки будут входить символы латиницы
//  ИспользоватьКириллицу	 - Булево	 - В состав строки будут входить символы кириллицы
//  ИспользоватьЦифры		 - Булево	 - В состав строки будут входить цифры
//  ЧередоватьЗаглавные		 - БУлево	 - В состав строки будут входить как строчные, так и прописные буквы
//  ЧастотаПробела			 - Число	 - Сколько символов в среднем отделяется пробелом. 0 - пробел не используется.
//  ГенераторСлучайныхЧисел	 - ГенераторСлучайныхЧисел	 - Если не задан, инициализируется в функции, используется повторно
//	КоллекцияСимволов		 - Массив	 - Коллекция символов, которая генерируется по входящим параметрам использования символов. 
//		Используется повторно.
//		Может быть определена явно для переопределения набора символов для формирования строки.
// 
// Возвращаемое значение:
//   - Строка   - Строка, состоящая из случайных символов
//
Функция СлучайнаяСтрока(
	КвалификаторыСтроки,
	ИспользоватьЛатиницу	 = Истина,
	ИспользоватьКириллицу	 = Истина,
	ИспользоватьЦифры		 = Истина,
	ЧередоватьЗаглавные		 = Истина,
	ЧастотаПробела			 = 8,
	ГенераторСлучайныхЧисел	 = Неопределено,
	КоллекцияСимволов		 = Неопределено)
 
	Если Ложь Тогда КвалификаторыСтроки = новый КвалификаторыСтроки КонецЕсли;
	
	СтрокаРезультат = "";
	
	Если ГенераторСлучайныхЧисел = Неопределено Тогда
		ГенераторСлучайныхЧисел = Новый ГенераторСлучайныхЧисел(ТекущаяУниверсальнаяДатаВМиллисекундах());
	КонецЕсли; 
	
	Если КоллекцияСимволов = Неопределено Тогда
	
		КоллекцияСимволов = Новый Массив;
		
		Если ИспользоватьЛатиницу Тогда
			Для КодСимвола = КодСимвола("a") По КодСимвола("z") Цикл КоллекцияСимволов.Добавить(Символ(КодСимвола)) КонецЦикла; 
		    Если ЧередоватьЗаглавные Тогда
				Для КодСимвола = КодСимвола("A") По КодСимвола("Z") Цикл КоллекцияСимволов.Добавить(Символ(КодСимвола)) КонецЦикла; 
			КонецЕсли; 
		КонецЕсли; 
		
		Если ИспользоватьКириллицу Тогда
			Для КодСимвола = КодСимвола("а") По КодСимвола("я") Цикл КоллекцияСимволов.Добавить(Символ(КодСимвола)) КонецЦикла;
			КоллекцияСимволов.Добавить("ё");
		    Если ЧередоватьЗаглавные Тогда
				Для КодСимвола = КодСимвола("А") По КодСимвола("Я") Цикл КоллекцияСимволов.Добавить(Символ(КодСимвола)) КонецЦикла; 
				КоллекцияСимволов.Добавить("Ё");
			КонецЕсли; 
		КонецЕсли; 
		
		Если ИспользоватьЦифры Тогда
			Для КодСимвола = КодСимвола("0") По КодСимвола("9") Цикл КоллекцияСимволов.Добавить(Символ(КодСимвола)) КонецЦикла;
		КонецЕсли;
	
	КонецЕсли; 
	
	Если КоллекцияСимволов.ВГраница() = 0 Тогда Возврат "" КонецЕсли; 
	
	МаксДлинаСтроки = 128;
	
	ДлинаСтроки = ?(КвалификаторыСтроки.Длина = 0, МаксДлинаСтроки, КвалификаторыСтроки.Длина);
	Если КвалификаторыСтроки.ДопустимаяДлина = ДопустимаяДлина.Переменная Тогда
		ДлинаСтроки = ГенераторСлучайныхЧисел.СлучайноеЧисло(, ДлинаСтроки);
	КонецЕсли; 	
	
	СоставСтроки = Новый Массив;
	МаксИндексПулаСимволов = КоллекцияСимволов.ВГраница();
	Для ПозицияСтроки = 1 По ДлинаСтроки Цикл
		СоставСтроки.Добавить(КоллекцияСимволов[ГенераторСлучайныхЧисел.СлучайноеЧисло(, МаксИндексПулаСимволов)]);
		Если ЧастотаПробела <> 0 
			и ГенераторСлучайныхЧисел.СлучайноеЧисло(1, ЧастотаПробела) = 1
			и ПозицияСтроки < ДлинаСтроки Тогда
			СоставСтроки.Добавить(" ");
			ПозицияСтроки = ПозицияСтроки + 1;
		КонецЕсли; 
	КонецЦикла;
	СтрокаРезультат = СтрСоединить(СоставСтроки);
	
	Возврат СтрокаРезультат;
 
КонецФункции // СлучайнаяСтрока()
  
// Формирует случайную дату
//
// Параметры:
//  КвалификаторыДаты		 - КвалификаторыДаты	 - Описание получаемой даты
//  МинимальнаяДата			 - Дата	 - Минимальная граница получаемых дат
//  МаксимальнаяДата		 - Дата	 - Максимальная граница получаемых дат
//  ГенераторСлучайныхЧисел	 - ГенераторСлучайныхЧисел	 - Если не задан, инициализируется в функции, используется повторно
// 
// Возвращаемое значение:
//   - Дат   - Полученная случайная дата
//
Функция СлучайнаяДата(КвалификаторыДаты, МинимальнаяДата = '00010101', Знач МаксимальнаяДата = '39991231235959', ГенераторСлучайныхЧисел = Неопределено)

	Если Ложь Тогда КвалификаторыДаты = новый КвалификаторыДаты КонецЕсли;
	
	ДатаРезультат = '00010101';
	
	Если ГенераторСлучайныхЧисел = Неопределено Тогда
		ГенераторСлучайныхЧисел = Новый ГенераторСлучайныхЧисел(ТекущаяУниверсальнаяДатаВМиллисекундах());
	КонецЕсли; 
	
	Если КвалификаторыДаты.ЧастиДаты = ЧастиДаты.Время Тогда
		НижняяГраница	 = Дата(1, 1, 1, Час(МинимальнаяДата), Минута(МинимальнаяДата), Секунда(МинимальнаяДата)) - '00010101';
		ВерхняяГраница	 = Дата(1, 1, 1, Час(МаксимальнаяДата), Минута(МаксимальнаяДата), Секунда(МаксимальнаяДата)) - '00010101';
		ДатаРезультат = '00010101' + ГенераторСлучайныхЧисел.СлучайноеЧисло(НижняяГраница, ВерхняяГраница);
	Иначе
		РазностьДатСекунд = МаксимальнаяДата - МинимальнаяДата;	// Максимально 126 196 185 599
		МаксВерхняяГраница = Pow(2, 32) - 1;	// см. ГенераторСлучайныхЧисел.СлучайноеЧисло()
		Если РазностьДатСекунд > МаксВерхняяГраница  Тогда
			БольшоеСлучайноеЧисло = 
			ГенераторСлучайныхЧисел.СлучайноеЧисло(pow(2, 31), pow(2, 32) - 1) * pow(2, 32) 
			+ ГенераторСлучайныхЧисел.СлучайноеЧисло(pow(2, 31), pow(2, 32) - 1);
			ДатаРезультат = МинимальнаяДата + БольшоеСлучайноеЧисло % РазностьДатСекунд;
		Иначе
			ДатаРезультат = МинимальнаяДата + ГенераторСлучайныхЧисел.СлучайноеЧисло(, РазностьДатСекунд)
		КонецЕсли; 
		Если КвалификаторыДаты.ЧастиДаты = ЧастиДаты.Дата Тогда
			ДатаРезультат = НачалоДня(ДатаРезультат);
		КонецЕсли; 	
	КонецЕсли; 
	
	Возврат	ДатаРезультат;

КонецФункции // СлучайнаяДата()

#КонецОбласти	// СлучайныеЗначения

