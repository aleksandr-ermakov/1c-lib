
#Область ОписанияТипов

// Проверяет соответствие описаний типов
//
// Параметры:
//	ОписаниеТиповА			 - ОписаниеТипов
//	ОписаниеТиповБ			 - ОписаниеТипов
//	ПроверятьКвалификаторы	 - Булево	 - Кроме входящих описаний типов проверяются квалификаторы простых типов
//
// Возвращаемое значение:
//	Булево - Описания типов совпадают
//
Функция ОписанияТиповСовпадают(ОписаниеТиповА, ОписаниеТиповБ, ПроверятьКвалификаторы = Истина) Экспорт

	ТипыА = ОписаниеТиповА.Типы();
	ТипыБ = ОписаниеТиповБ.Типы();
	
	Если ТипыА.Количество() <> ТипыБ.Количество() Тогда
		Возврат Ложь;
	КонецЕсли;

	Для каждого ТипА Из ОписаниеТиповА.Типы() Цикл
		Если Не ОписаниеТиповБ.СодержитТип(ТипА) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Для каждого ТипБ Из ОписаниеТиповБ.Типы() Цикл
		Если Не ОписаниеТиповА.СодержитТип(ТипБ) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;

	Если Не ПроверятьКвалификаторы Тогда
		Возврат Истина;
	КонецЕсли;

	ТипыКвалификаторы = Новый Структура;
	ТипыКвалификаторы.Вставить("Дата",			 "КвалификаторыДаты");
	ТипыКвалификаторы.Вставить("ДвоичныеДанные", "КвалификаторыДвоичныхДанных");
	ТипыКвалификаторы.Вставить("Строка",		 "КвалификаторыСтроки");
	ТипыКвалификаторы.Вставить("Число",			 "КвалификаторыЧисла");
	Для каждого ТипКвалификатор Из ТипыКвалификаторы Цикл
		ИмяТипа			 = ТипКвалификатор.Ключ;
		ИмяКвалификатора = ТипКвалификатор.Значение;
		Если ОписаниеТиповА.СодержитТип(Тип(ИмяТипа)) 
			И Не КвалификаторыТиповСовпадают(
				ОписаниеТиповА[ИмяКвалификатора], 
				ОписаниеТиповБ[ИмяКвалификатора]) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;

	Возврат Истина;

КонецФункции // ОписанияТиповСовпадают()

// Проверяет совпадение квалификаторов типов
//
// Параметры:
//	КвалификаторыА	 - КвалификаторыДаты
//					 - КвалификаторыДвоичныхДанных
//					 - КвалификаторыСтроки
//					 - КвалификаторыЧисла
//	КвалификаторыБ	 - КвалификаторыДаты
//					 - КвалификаторыДвоичныхДанных
//					 - КвалификаторыСтроки
//					 - КвалификаторыЧисла
//
// Варианты вызова:
//	КвалификаторыТиповСовпадают(КвалификаторыДаты, КвалификаторыДаты)						 - Проверка квалификаторов даты
//	КвалификаторыТиповСовпадают(КвалификаторыДвоичныхДанных, КвалификаторыДвоичныхДанных)	 - Проверка квалификаторов строки
//	КвалификаторыТиповСовпадают(КвалификаторыСтроки, КвалификаторыСтроки)					 - Проверка квалификаторов двоичных данных
//	КвалификаторыТиповСовпадают(КвалификаторыЧисла, КвалификаторыЧисла)						 - Проверка квалификаторов числа
//
// Возвращаемое значение:
//   Булево   - Квалификаторы совпадают
//
Функция КвалификаторыТиповСовпадают(КвалификаторыА, КвалификаторыБ) Экспорт
	
	Если ТипЗнч(КвалификаторыА) <> ТипЗнч(КвалификаторыБ) Тогда
		Возврат Ложь;
	КонецЕсли;

	КвА = КвалификаторыА;
	КвБ = КвалификаторыБ;

	Если ТипЗнч(КвалификаторыА) = Тип("КвалификаторыДаты") Тогда

		КвалификаторыСовпадают	 = КвА.ЧастиДаты		 = КвБ.ЧастиДаты;

	ИначеЕсли	ТипЗнч(КвалификаторыА) = Тип("КвалификаторыДвоичныхДанных")
		Или		ТипЗнч(КвалификаторыА) = Тип("КвалификаторыСтроки") Тогда

		КвалификаторыСовпадают	 = КвА.Длина 			 = КвБ.Длина
								 И КвА.ДопустимаяДлина	 = КвБ.ДопустимаяДлина;

	ИначеЕсли ТипЗнч(КвалификаторыА) = Тип("КвалификаторыЧисла") Тогда

		КвалификаторыСовпадают	 = КвА.ДопустимыйЗнак 			 = КвБ.ДопустимыйЗнак
								 И КвА.Разрядность				 = КвБ.Разрядность
								 И КвА.РазрядностьДробнойЧасти	 = КвБ.РазрядностьДробнойЧасти;

	Иначе

		ВызватьИсключение "Непредвиденные параметры";

	КонецЕсли;

	Возврат КвалификаторыСовпадают;

КонецФункции // КвалификаторыТиповСовпадают()

// Сравнивает типы в составе описаний типов
// Без учета квалификаторов
//
// Параметры:
//	ОписаниеТиповА	 - ОписаниеТипов			 - Первое описание типов для сравнения
//					 - Массив Из ОписаниеТипов	 - Для сравнения трёх и более типов
//	ОписаниеТиповБ	 - ОписаниеТипов			 - Второе описание типов для сравнения. 
//												Не используется, если ОписаниеТиповА - это Массив
//
// Возвращаемое значение:
//	Соответствие:
//		* Ключ		 - ОписаниеТипов - Описание типов, поданное в параметре функции
//		* Значение	 - Массив Из Тип - Типы, присутствующие в этом описании, и отсутствующие в другом (любом из других)
//
// Варианты вызова:
//	СравнитьОписанияТипов(ОписаниеТипов, ОписаниеТипов) - Сравнение двух описаний типов
//	СравнитьОписанияТипов(Массив)						- Сравнивает трёх и более описаний типов
//
Функция СравнитьОписанияТипов(ОписаниеТиповА, ОписаниеТиповБ = Неопределено) Экспорт

	Если ТипЗнч(ОписаниеТиповА) = Тип("Массив") Тогда
		ОписанияТипов = ОписаниеТиповА;
	Иначе
		ОписанияТипов = Новый Массив;
		ОписанияТипов.Добавить(ОписаниеТиповА);
		ОписанияТипов.Добавить(ОписаниеТиповБ);
	КонецЕсли;

	Если ОписанияТипов.Количество() < 2 Тогда
		ВызватьИсключение "Описаний для сравнения должно быть 2 или более";
	КонецЕсли;

	СобственныеТипыОписаний = Новый Соответствие;
	Для каждого ОписаниеТипов Из ОписанияТипов Цикл
		СобственныеТипыОписаний.Вставить(ОписаниеТипов, Новый Массив);
	КонецЦикла;

	Для Каждого ТекущееОписаниеТипов Из ОписанияТипов Цикл
		ТипыТекущегоОписания = ТекущееОписаниеТипов.Типы();
		СобственныеТипыОписания = СобственныеТипыОписаний[ТекущееОписаниеТипов];
		Для Каждого ДругоеОписаниеТипов Из ОписанияТипов Цикл
			Если ТекущееОписаниеТипов = ДругоеОписаниеТипов Тогда
				Продолжить;
			КонецЕсли;
			ТипыДругогоОписания = ДругоеОписаниеТипов.Типы();
			Для каждого ТипТекущегоОписания Из ТипыТекущегоОписания Цикл
				Если ТипыДругогоОписания.Найти(ТипТекущегоОписания) = Неопределено
					И СобственныеТипыОписания.Найти(ТипТекущегоОписания) = Неопределено Тогда
					СобственныеТипыОписания.Добавить(ТипТекущегоОписания);
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;

	Возврат СобственныеТипыОписаний;

КонецФункции // СравнитьОписанияТипов()

// Сравнивает описания типов и формирует текстовое представление результата
//
// Параметры:
//	ОписаниеТиповА - ОписаниеТипов
//	ОписаниеТиповБ - ОписаниеТипов
//
// Возвращаемое значение:
//	Строка - Табличное представление результата сравнения
//
Функция СравнитьОписанияТиповСформироватьРезультатТекст(ОписаниеТиповА, ОписаниеТиповБ) Экспорт
	
	Если ТипЗнч(ОписаниеТиповА) = Тип("Массив") Тогда
		ОписанияТипов = ОписаниеТиповА;
	Иначе
		ОписанияТипов = Новый Массив;
		ОписанияТипов.Добавить(ОписаниеТиповА);
		ОписанияТипов.Добавить(ОписаниеТиповБ);
	КонецЕсли;

	РезультатСравнения = СравнитьОписанияТипов(ОписаниеТиповА, ОписаниеТиповБ);

	ВсеТипы = Новый СписокЗначений;
	Для каждого ОписаниеТипов Из ОписанияТипов Цикл
		СобственныеТипыОписания = РезультатСравнения[ОписаниеТипов];
		Для каждого Тип Из СобственныеТипыОписания Цикл
			Если ВсеТипы.НайтиПоЗначению(Тип) = Неопределено Тогда
				ВсеТипы.Добавить(Тип, Строка(Тип));
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	ЕстьРазличия = ЗначениеЗаполнено(ВсеТипы);
	Если Не ЕстьРазличия Тогда
		Возврат "Типы в составе описаний совпадают";
	КонецЕсли;

	ВсеТипы.СортироватьПоПредставлению();

	СоставТаблицы = Новый Массив;
	СоставСтроки = Новый Массив;
	Заголовок = "Тип \ Описание типов";
	СоставСтроки.Добавить(Заголовок);
	Для НомерТипа = 1 По ОписанияТипов.Количество() Цикл
		СоставСтроки.Добавить(Строка(НомерТипа));
	КонецЦикла;
	СоставТаблицы.Добавить(СоставСтроки);

	Для каждого ЭлементСписка Из ВсеТипы Цикл
		Тип = ЭлементСписка.Значение;
		ПредставлениеТипа = ЭлементСписка.Представление;
		СоставСтроки = Новый Массив;
		СоставСтроки.Добавить(ПредставлениеТипа);
		Для каждого ОписаниеТипов Из ОписанияТипов Цикл
			ТипЕстьВОписании = РезультатСравнения[ОписаниеТипов].Найти(Тип) <> Неопределено;
			СоставСтроки.Добавить(?(ТипЕстьВОписании, "+", "-"));
		КонецЦикла;
		СоставТаблицы.Добавить(СоставСтроки);
	КонецЦикла;

	ОтбиватьТабами			 = Ложь;
	ШиринаТаба				 = 4;

	МаксШиринаКолонки = 0;
	Для каждого СоставСтроки Из СоставТаблицы Цикл
		МаксШиринаКолонки = Макс(МаксШиринаКолонки, СтрДлина(СоставСтроки[0]));
	КонецЦикла;

	Если ОтбиватьТабами Тогда

		ШиринаКолонкиТабов	 = Цел(МаксШиринаКолонки / ШиринаТаба) + ?(МаксШиринаКолонки % ШиринаТаба, 1, 0);
		ФиксШиринаКолонки	 = ШиринаКолонкиТабов * ШиринаТаба;
		Для каждого СоставСтроки Из СоставТаблицы Цикл
			СодержимоеКолонки = СоставСтроки[0];
			ШиринаКолонки = СтрДлина(СодержимоеКолонки);
			РазницаШирины = ФиксШиринаКолонки - ШиринаКолонки;
			ДобавитьТабов = Цел(РазницаШирины / ШиринаТаба) + ?(РазницаШирины % ШиринаТаба, 1, 0);
			Для Номер = 1 По ДобавитьТабов Цикл
				СодержимоеКолонки = СодержимоеКолонки + Символы.Таб;
			КонецЦикла;
			СоставСтроки[0] = СодержимоеКолонки;
		КонецЦикла;

	Иначе // Выравнивание неразрывными пробелами

		Для каждого СоставСтроки Из СоставТаблицы Цикл
			СодержимоеКолонки = СоставСтроки[0];
			ШиринаКолонки = СтрДлина(СодержимоеКолонки);
			РазницаШирины = МаксШиринаКолонки - ШиринаКолонки;
			Для Номер = 1 По РазницаШирины Цикл
				СодержимоеКолонки = СодержимоеКолонки + Символы.НПП;
			КонецЦикла;
			СоставСтроки[0] = СодержимоеКолонки;
		КонецЦикла;
		
	КонецЕсли;

	ПредставлениеТаблицы = Новый Массив;
	РазделительКолонок = " | ";
	Для Каждого СоставСтроки Из СоставТаблицы Цикл
		ПредставлениеТаблицы.Добавить(СтрСоединить(СоставСтроки, РазделительКолонок));
	КонецЦикла;
	ПредставлениеТаблицы = СтрСоединить(ПредставлениеТаблицы, Символы.ПС);

	Возврат ПредставлениеТаблицы;

КонецФункции // СравнитьОписанияТиповСформироватьРезультатТекст()

#КонецОбласти

#Область ПримитивныеТипы

// Получает дату с точностью до секунды
//
// Параметры:
//	Дата - Дата - Исходная дата
//
// Возвращаемое значение:
//	Дата
//
Функция ДатаБезМиллисекунд(Дата) Экспорт

	 Возврат Дата(Год(Дата), Месяц(Дата), День(Дата), Час(Дата), Минута(Дата), Секунда(Дата));

КонецФункции // ДатаБезМиллисекунд()

// Проверяет, является тип примитивным.
//
// Параметры:
//  Тип						 - Тип		 - Проверяемый тип
//  СчитатьТипПримитивным	 - Булево	 - Если Истина - то Тип причисляется к примитивным типам.
// 
// Возвращаемое значение:
//  Булево
//
Функция ЭтоПримитивныйТип(Тип, СчитатьТипПримитивным = Истина) Экспорт

	Возврат Тип = Тип("Неопределено")
		Или Тип = Тип("Null")
		Или Тип = Тип("Число")
		Или Тип = Тип("Строка")
		Или Тип = Тип("Дата")  
		Или Тип = Тип("Булево")
		Или Тип = Тип("Тип") И СчитатьТипПримитивным;

КонецФункции // ЭтоПримитивныйТип()

// Разбивает заданный период на нериоды с заданной периодичностью
//
// Параметры:
//	Период	 - СтандартныйПериод - Разделяемый период
//	Периодичность	 - Строка - Вид периода. 
//		Возможные значения:
//		* Минута
//		* Час
//		* День
//		* Неделя
//		* Месяц
//		* Год
//
// Возвращаемое значение:
//	Массив - Массив периодов в результате разделения. Элемент: СтандартныйПериод
//
// Пример:
//	РазделитьНаПериоды(Новый СтандартныйПериод(ВариантСтандартногоПериода.ЭтотКвартал), "Месяц"); // Вернёт массив стандартных периодов - месяцов квартала
//
Функция РазделитьНаПериоды(Период, Периодичность = "Месяц")

	НачалоТекущегоПериода	 = '00010101';
	НачалоПоследнегоПериода	 = '00010101';

	Если Периодичность = "Минута" Тогда
		НачалоТекущегоПериода	 = НачалоМинуты(Период.ДатаНачала);
		НачалоПоследнегоПериода	 = НачалоМинуты(Период.ДатаОкончания);
	ИначеЕсли Периодичность = "Час" Тогда
		НачалоТекущегоПериода	 = НачалоЧаса(Период.ДатаНачала);
		НачалоПоследнегоПериода	 = НачалоЧаса(Период.ДатаОкончания);
	ИначеЕсли Периодичность = "День" Тогда
		НачалоТекущегоПериода	 = НачалоДня(Период.ДатаНачала);
		НачалоПоследнегоПериода	 = НачалоДня(Период.ДатаОкончания);
	ИначеЕсли Периодичность = "Неделя" Тогда
		НачалоТекущегоПериода	 = НачалоНедели(Период.ДатаНачала);
		НачалоПоследнегоПериода	 = НачалоНедели(Период.ДатаОкончания);
	ИначеЕсли Периодичность = "Месяц" Тогда
		НачалоТекущегоПериода	 = НачалоМесяца(Период.ДатаНачала);
		НачалоПоследнегоПериода	 = НачалоМесяца(Период.ДатаОкончания);
	ИначеЕсли Периодичность = "Год" Тогда
		НачалоТекущегоПериода	 = НачалоГода(Период.ДатаНачала);
		НачалоПоследнегоПериода	 = НачалоГода(Период.ДатаОкончания);
	Иначе
		ВызватьИсключение "Неверно указан период";
	КонецЕсли;

	Периоды = Новый Массив;

	Пока НачалоТекущегоПериода <= НачалоПоследнегоПериода Цикл

		Если Периодичность = "Минута" Тогда
			КонецТекущегоПериода = КонецМинуты(НачалоТекущегоПериода);
		ИначеЕсли Периодичность = "Час" Тогда
			КонецТекущегоПериода = КонецЧаса(НачалоТекущегоПериода);
		ИначеЕсли Периодичность = "День" Тогда
			КонецТекущегоПериода = КонецДня(НачалоТекущегоПериода);
		ИначеЕсли Периодичность = "Неделя" Тогда
			КонецТекущегоПериода = КонецНедели(НачалоТекущегоПериода);
		ИначеЕсли Периодичность = "Месяц" Тогда
			КонецТекущегоПериода = КонецМесяца(НачалоТекущегоПериода);
		ИначеЕсли Периодичность = "Год" Тогда
			КонецТекущегоПериода = КонецГода(НачалоТекущегоПериода);
		Иначе
			ВызватьИсключение "Что-то пошло не так";
		КонецЕсли;

		ТекущийПериод = Новый СтандартныйПериод(
			Макс(НачалоТекущегоПериода,	 Период.ДатаНачала),
			Мин(КонецТекущегоПериода,	 Период.ДатаОкончания)
		);
		Периоды.Добавить(ТекущийПериод);

		НачалоТекущегоПериода = КонецТекущегоПериода + 1;
			
	КонецЦикла;
	
	Возврат Периоды;

КонецФункции // РазделитьНаПериоды()

#КонецОбласти // ПримитивныеТипы

// Работает аналогично ЗаполнитьЗначенияСвойств(),
// но позволяет поменять имена свойств приёмника.
// Служит для того, когда имена свойств источника и приёмника отличаются
//
// Параметры:
//	Источник			 - Произвольный - Объект-источник.
//	Приемник			 - Произвольный - Объект-приемник.
//	СвойстваИсточника	 - Строка - Перечень имён свойств источника.
//	СвойстваИсточника	 - Строка - Перечень имён свойств приемника.
//	ПереноситьПрочие	 - Булево - Переносить свойства с именами, не указанными в СвойстваИсточника.
//	ИсключаяСвойства	 - Строка - Имена свойств, которые переносить не следует. 
//									Используется, если ПереноситьПрочие = Истина.
//
// Пример:
//	Источник = Новый Структура("Раз, Два, Три, Четыре, Пять", 1, 2, 3, 4, 5);
//	Приемник = Новый Структура("Раз, Два, Три, Четыре, Пять");
//	ПеренестиЗначенияСвойств(
//		Источник,
//		Приемник,
//		"Раз, Два, Три",
//		"Раз, Три, Два",
//		Истина,
//		"Пять");	// Приемник станет Структура("Раз, Два, Три, Четыре, Пять", 1, 3, 2, 4, Неопределено)
//
Процедура ПеренестиЗначенияСвойств(Источник, Приемник, СвойстваИсточника = "", СвойстваПриемника = "", ПереноситьПрочие = Ложь, ИсключаяСвойства = "")
	
	Если Не ЗначениеЗаполнено(СвойстваИсточника)
		И Не ЗначениеЗаполнено(СвойстваПриемника)
		И Не ПереноситьПрочие Тогда
		Возврат;
	КонецЕсли;

	КлючиИсточника = СтрРазделить(СвойстваИсточника, ", ", Ложь);
	КлючиПриемника = СтрРазделить(СвойстваИсточника, ", ", Ложь);

	Если КлючиИсточника.Количество() <> КлючиПриемника.Количество() Тогда
		ВызватьИсключение "Различается количество указанных ключей источника и приемника";
	КонецЕсли;

	Если ПереноситьПрочие Тогда

		// Для ситуаций, когда ключи источника присутствуют в приемнике,
		// но значения этих ключей переносятся на другие позиции,
		// что избежать изменения значения этих ключей,
		// Мы резервируем ключи Приемника, которые присутствуют в Источнике.
		ЗначенияПриемникаРезерв	 = Новый Структура;
		Для каждого Ключ Из КлючиИсточника Цикл
			ЗначенияПриемникаРезерв.Вставить(Ключ);
		КонецЦикла;
		ЗаполнитьЗначенияСвойств(ЗначенияПриемникаРезерв, Приемник);
		ЗаполнитьЗначенияСвойств(Приемник, Источник, , ИсключаяСвойства);
		ЗаполнитьЗначенияСвойств(Приемник, ЗначенияПриемникаРезерв);

	КонецЕсли;

	Если ЗначениеЗаполнено(КлючиИсточника) Тогда
		Для Индекс = 0 По СвойстваИсточника.ВГраница() Цикл
			Приемник[КлючиПриемника[Индекс]] = Источник[КлючиИсточника[Индекс]];
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры

#Область Коллекции

#Область ДревовидныеКоллекции

// Получает коллекцию подчиненных элементов
//
// Параметры:
//  Узел - ДанныеФормыДерево, ДанныеФормыЭлементДерева, ДеревоЗначений, СтрокаДереваЗначений - Узел или корень дерева
//
// Возвращаемое значение:
//   - ДанныеФормыКоллекцияЭлементовДерева, КоллекцияСтрокДереваЗначений
//
Функция ПолучитьВетви(Узел)

	ЭтоЭлементДереваФормы = ТипЗнч(Узел) = Тип("ДанныеФормыЭлементДерева")
		Или ТипЗнч(Узел) = Тип("ДанныеФормыДерево");
		
	Возврат ?(ЭтоЭлементДереваФормы, Узел.ПолучитьЭлементы(), Узел.Строки)

КонецФункции // ПолучитьВетви()

// Проверяет, является ли Узел элементом древовидной коллекции
//
// Параметры:
//  Узел - ДанныеФормыДерево, ДанныеФормыЭлементДерева, ДеревоЗначений, СтрокаДереваЗначений - Узел или корень дерева
//
// Возвращаемое значение:
//   - Булево
//
Функция ЭтоУзелДерева(Узел)
	ЭтоУзелДерева = ТипЗнч(Узел) = Тип("ДанныеФормыЭлементДерева");
	#Если Сервер Тогда
		ЭтоУзелДерева = ЭтоУзелДерева ИЛИ ТипЗнч(Узел) = Тип("СтрокаДереваЗначений");
	#КонецЕсли
	Возврат ЭтоУзелДерева;
КонецФункции	// ЭтоУзелДерева()

// Проверяет, является ли Узел листом древовидной коллекции
//
// Параметры:
//  Узел - ДанныеФормыДерево, ДанныеФормыЭлементДерева, Произвольный - Узел дерева
//
// Возвращаемое значение:
//   Булево - Признак того что проверяемый узел не имеет дочерних узлов.
//
Функция ЭтоЛистДерева(Узел)

	Если ТипЗнч(Узел) = Тип("ДанныеФормыЭлементДерева") Тогда
		Возврат Не ЗначениеЗаполнено(Узел.ПолучитьЭлементы());
	КонецЕсли;

	#Если Сервер Тогда
	Если ТипЗнч(Узел) = Тип("СтрокаДереваЗначений") Тогда
		Возврат Не ЗначениеЗаполнено(Узел.Строки);
	КонецЕсли;
	#КонецЕсли

	Возврат Ложь;

КонецФункции	// ЭтоЛистДерева()

// Проверяет, является ли Узел элементом древовидной коллекции формы
//
// Параметры:
//  Узел - ДанныеФормыДерево, ДанныеФормыЭлементДерева, ДеревоЗначений, СтрокаДереваЗначений - Узел или корень дерева
//
// Возвращаемое значение:
//   - Булево
//
Функция ЭтоЭлементДереваФормы(Узел)

	Возврат ТипЗнч(Узел) = Тип("ДанныеФормыЭлементДерева")
		ИЛИ ТипЗнч(Узел) = Тип("ДанныеФормыДерево")

КонецФункции // ЭтоЭлементДереваФормы()

// Получает конечные элементы предоставленной коллекции
//
// Параметры:
//  Узел - ДанныеФормыДерево, ДанныеФормыЭлементДерева, ДеревоЗначений, СтрокаДереваЗначений	 -
//
// Возвращаемое значение:
//   - Массив{ДанныеФормыЭлементДерева, СтрокаДереваЗначений}
//
Функция ПолучитьЛистьяДереваРекурсивно(Узел, Отбор = Неопределено)

	ВозвращаемоеЗначение = Новый Массив;
	Коллекция = ПолучитьВетви(Узел);
	Если ЗначениеЗаполнено(Коллекция) Тогда
		Для каждого Ветвь Из Коллекция Цикл
			Для каждого Лист Из ПолучитьЛистьяДереваРекурсивно(Ветвь, Отбор) Цикл 
				ВозвращаемоеЗначение.Добавить(Лист);
			КонецЦикла;
		КонецЦикла;
	ИначеЕсли ЭтоУзелДерева(Узел) Тогда
		Если Отбор = Неопределено Тогда
			ВозвращаемоеЗначение.Добавить(Узел)
		Иначе
			УзелСоответстветОтбору = Истина;
			Для каждого Элемент Из Отбор Цикл
				Если Узел[Элемент.Ключ] <> Элемент.Значение Тогда
					УзелСоответстветОтбору = Ложь;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если УзелСоответстветОтбору Тогда
				ВозвращаемоеЗначение.Добавить(Узел);
			КонецЕсли;
		КонецЕсли;
	Иначе
		ВызватьИсключение "Что-то пошло не так.";
	КонецЕсли;

	Возврат ВозвращаемоеЗначение;

КонецФункции // ПолучитьЛистьяДереваЗначенийРекурсивно()

// Получает поля листьев дерева
//
// Параметры:
//  Узел						 - ДанныеФормыДерево, ДанныеФормыЭлементДерева	 -
//  Поля						 - Строка										 - Имена полей
//  Отбор						 - Структура									 - Какие элементы опрашиваются
//
// Возвращаемое значение:
//  Массив - Структуры данных
//
Функция ПолучитьПоляЛистьевДерева(Узел, Поля = "", Отбор = Неопределено)

	ЕстьОтбор = Отбор <> Неопределено;

	КоллекцияДанных = Новый Массив;
	КоллекцияПодчиненных = ПолучитьВетви(Узел);

	Листья = ?(ЕстьОтбор, КоллекцияПодчиненных.НайтиСтроки(Отбор, Истина), ПолучитьЛистьяДереваРекурсивно(Узел));

	Для каждого Лист Из Листья Цикл
		Если ЕстьОтбор И Не ЭтоЛистДерева(Лист) Тогда 
			Продолжить; 
		КонецЕсли;	// По отбору могут быть подобраны узлы, имеющие подчиненные элементы.
		СтруктураДанных = Новый Структура(Поля);
		ЗаполнитьЗначенияСвойств(СтруктураДанных, Лист);
		КоллекцияДанных.Добавить(СтруктураДанных);
	КонецЦикла;

	Возврат КоллекцияДанных;

КонецФункции // ПолучитьПоляЛистьевДерева()

// Получает поля элементов дерева
//
// Параметры:
//  Узел						 - ДанныеФормыДерево, ДанныеФормыЭлементДерева	 -
//  Поля						 - Строка										 - Имена полей, через запятую
//  Отбор						 - Структура									 - Какие элементы опрашиваются
//
// Возвращаемое значение:
//  Массив - Структуры данных
//
Функция ПолучитьПоляДанныхДереваРекурсивно(Узел, Поля = "Идентификатор, ИдентификаторСтроки", Отбор = Неопределено)

	КоллекцияДанных = Новый Массив;

	Если ЭтоУзелДерева(Узел) и ЭлементСоответствуетОтбору(Узел, Отбор) Тогда
		СтруктураДанных = Новый Структура(Поля);
		ЗаполнитьЗначенияСвойств(СтруктураДанных, Узел);
		Если СтруктураДанных.Свойство("ИдентификаторСтроки") и ЭтоЭлементДереваФормы(Узел) Тогда
			СтруктураДанных.ИдентификаторСтроки = Узел.ПолучитьИдентификатор();
		КонецЕсли;
		КоллекцияДанных.Добавить(СтруктураДанных);
	КонецЕсли;

	Коллекция = ПолучитьВетви(Узел);

	Для каждого Ветвь Из Коллекция Цикл
		ДанныеПодчиненных = ПолучитьПоляДанныхДереваРекурсивно(Ветвь, Поля, Отбор);
		Для каждого СтруктураДанных Из ДанныеПодчиненных Цикл
			КоллекцияДанных.Добавить(СтруктураДанных);
		КонецЦикла;
	КонецЦикла;

	Возврат КоллекцияДанных;

КонецФункции // ПолучитьПоляДанныхДереваРекурсивно()

// Получает поля элементов дерева в иерархическом виде
//
// Параметры:
//  Узел						 - ДанныеФормыДерево, ДанныеФормыЭлементДерева	 -
//  Поля						 - Строка										 - Имена полей
//  ИмяКоллекцииВложенныхСтрок	 - Строка										 - Имя массива вложенных строк
//
// Возвращаемое значение:
//  Структура{[ИмяПоля], ИмяКоллекцииВложенныхСтрок} данных
//
Функция ПолучитьПоляДанныхДереваФормыИерархическиРекурсивно(Узел, Поля = "Идентификатор, ИдентификаторСтроки", ИмяКоллекцииВложенныхСтрок = "Строки", ИсключаяСлужебные = Истина)

	СтруктураДанных = Новый Структура(Поля);

	Если ТипЗнч(Узел) = Тип("ДанныеФормыЭлементДерева") Тогда
		ЗаполнитьЗначенияСвойств(СтруктураДанных, Узел);
		Если СтруктураДанных.Свойство("ИдентификаторСтроки") Тогда
			СтруктураДанных.ИдентификаторСтроки = Узел.ПолучитьИдентификатор();
		КонецЕсли;
	КонецЕсли;

	СтруктураДанных.Вставить(ИмяКоллекцииВложенныхСтрок, Новый Массив);

	Для каждого Ветвь Из Узел.ПолучитьЭлементы() Цикл
		Если ИсключаяСлужебные и Ветвь.Служебная Тогда Продолжить КонецЕсли;
		СтруктураДанных[ИмяКоллекцииВложенныхСтрок].Добавить(ПолучитьПоляДанныхДереваФормыИерархическиРекурсивно(Ветвь, Поля, ИмяКоллекцииВложенныхСтрок));
	КонецЦикла;

	Возврат СтруктураДанных;

КонецФункции // ПолучитьПоляДанныхДереваФормыИерархическиРекурсивно()

#КонецОбласти // ДревовидныеКоллекции

#Область Массив

// Удаляет незаполненные значения из массива.
// Заполненность значений проверяется методом ЗначениеЗаполнено()
// 
// Параметры:
//	Массив				 - Массив из Произвольный - Массив элементов.
//	ИгнорируемыеЗначения - Массив из Произвольный - Значения, которые следует оставить при проверке
//
Процедура УдалитьНезаполненныеЗначенияМассива(Массив, Знач ИгнорируемыеЗначения = Неопределено)

	Если ИгнорируемыеЗначения = Неопределено Тогда
		ИгнорируемыеЗначения = Новый Массив;
	КонецЕсли;

	Для ДопИндекс = - Массив.ВГраница() По 0 Цикл

		Индекс = - ДопИндекс;
		ЭлементМассива = Массив[Индекс];
		Если Не ЗначениеЗаполнено(ЭлементМассива) 
			И ИгнорируемыеЗначения.Найти(ЭлементМассива) = Неопределено Тогда

			Массив.Удалить(Индекс);

		КонецЕсли;

	КонецЦикла;
	
КонецПроцедуры // УдалитьНезаполненныеЗначенияМассива()

// Раскладывает строку на массив символов
// 
// Параметры:
//	ИсходнаяСтрока - Строка
//
// Возвращаемое значение:
//	Массив из Строка
//
Функция МассивСимволовИзСтроки(ИсходнаяСтрока) Экспорт

	МассивСимволов = Новый Массив(ДлинаСтроки);
	ДлинаСтроки = СтрДлина(ИсходнаяСтрока);
	Для Индекс = 0 По ДлинаСтроки - 1 Цикл
		МассивСимволов.Установить(Индекс, Сред(ИсходнаяСтрока, Индекс + 1, 1));
	КонецЦикла;

	Возврат МассивСимволов;

КонецФункции // МассивСимволовИзСтроки()

// Преобразует коллекцию в двумерный массив (массив массивов)
//
// Параметры:
//  ИсходнаяКоллекция		 - Произвольный	 - Любая коллекция, доступная для обхода "Для каждого ... Цикл". 
//  РазмерВложенногоМассива	 - Число		 - Максимальное количество элементов вложенного массива.
// 
// Возвращаемое значение:
//  Массив - Результирующий массив.
//
Функция ДвумерныйМассивИзКоллекции(Знач ИсходнаяКоллекция, Знач РазмерВложенногоМассива = 1)
	
	МаксИндексВложенногоМассива = РазмерВложенногоМассива - 1;
	ДвумерныйМассив = Новый Массив;
	ИндексВложенногоМассива = -1;
	Для каждого ТекущийЭлемент Из ИсходнаяКоллекция Цикл
		ИндексВложенногоМассива = ИндексВложенногоМассива + 1;
		Если ИндексВложенногоМассива > МаксИндексВложенногоМассива Тогда ИндексВложенногоМассива = 0 КонецЕсли; 
		Если ИндексВложенногоМассива = 0 Тогда
			ВложенныйМассив = Новый Массив;
			ДвумерныйМассив.Добавить(ВложенныйМассив);
		КонецЕсли; 
		ВложенныйМассив.Добавить(ТекущийЭлемент);
	КонецЦикла;
	
	Возврат ДвумерныйМассив;
	
КонецФункции // ДвумерныйМассивИзКоллекции

// Вырезает элементы из массива, и на их место вставляет новые элементы.
//
// Параметры:
//  Массив				 - Массив	 - Массив, из которого вырезаются/вставляются элементы.
//  Индекс				 - Число	 - Индекс первого удаляемого элемента, а также вставки элементов.
//  КоличествоУдаляемых	 - Число	 - Количество удаляемых элементов массива.
//  Вставка				 - Массив, Произвольный	 - Вставляемые элементы. 
//										Если указано значение типа, отличного от Массив, оно будет вставлено по указанонму указанному индексу.
//										Если требуется вставить Массив или Неопределено в качестве элемента - следует передать его в качестве вложенного в массив.
// 
// Возвращаемое значение:
//  Массив - Удаленные элементы
//
Функция СраститьМассив(Массив, Индекс = 0, КоличествоУдаляемых = 0, Вставка = Неопределено) Экспорт

	Удаленные = Новый Массив;
	ОсталосьУдалить = КоличествоУдаляемых;
	
	Пока ОсталосьУдалить Цикл
		Удаленные.Добавить(Массив[Индекс]);
		Массив.Удалить(Индекс);
		ОсталосьУдалить = ОсталосьУдалить - 1;
	КонецЦикла;   
	
	Если Вставка <> Неопределено Тогда
	
		Если ТипЗнч(Вставка) = Тип("Массив") Тогда
			Для каждого Элемент Из Вставка Цикл
				Массив.Вставить(Индекс, Элемент);	
			КонецЦикла; 	
		Иначе
			Массив.Вставить(Индекс, Вставка);	
		КонецЕсли; 
	
	КонецЕсли; 
	
	Возврат Удаленные;

КонецФункции // СраститьМассив()

#КонецОбласти	// Массив

// Вычисляет агрегатную функцию по значениям коллекции
//
// Параметры:
//	Коллекция			 - Произвольный	 - Коллекция, для которой доступен обход "Для Каждого ... Из ... Цикл"
//	АгрегатнаяФункция	 - Строка		 - Агрегатная функция. Допустимые значения:
//		* Сумм[а]
//		* Сред[нее]
//		* Мин[имум]
//		* Макс[имум]
//		* Кол[ичество]
//		* [Количество] Разл[ичные]
//	Поле				 - Строка	 - Имя поля коллекции
//						 - Число	 - Индекс поля коллекции
//						Может быть не указано, если в качестве коллекции выступает Массив
//
// Возвращаемое значение:
//	Число - ТекущееЗначение вычисленной функции		
//
Функция АгрегатКоллекции(Знач Коллекция, АгрегатнаяФункция = "Сумма", Поле = Неопределено) Экспорт

	Если Не ЗначениеЗаполнено(Коллекция) Тогда
		Возврат 0;
	КонецЕсли;

	// Функция:
	ЭтоСумма		 = Ложь;
	ЭтоСреднее		 = Ложь;
	ЭтоМинимум		 = Ложь;
	ЭтоМаксимум		 = Ложь;
	ЭтоКоличество	 = Ложь;
	ЭтоРазличные	 = Ложь;
	АгрегатнаяФункцияВрег = ВРег(АгрегатнаяФункция);
	Если СтрНачинаетсяС(АгрегатнаяФункцияВрег, "СУММ") Тогда
		ЭтоСумма		 = Истина;

	ИначеЕсли СтрНачинаетсяС(АгрегатнаяФункцияВрег, "СРЕД") Тогда
		ЭтоСреднее		 = Истина;

	ИначеЕсли СтрНачинаетсяС(АгрегатнаяФункцияВрег, "МИН") Тогда
		ЭтоМинимум		 = Истина;

	ИначеЕсли СтрНачинаетсяС(АгрегатнаяФункцияВрег, "МАКС") Тогда
		ЭтоМаксимум		 = Истина;

	ИначеЕсли СтрНайти(АгрегатнаяФункцияВрег, "РАЗЛ") Тогда
		ЭтоРазличные	 = Истина;

	ИначеЕсли СтрНачинаетсяС(АгрегатнаяФункцияВрег, "КОЛ") Тогда
		ЭтоКоличество	 = Истина;

	Иначе
		ВызватьИсключение "Параметр АгрегатнаяФункция: Непредвиденное значение";
	
	КонецЕсли;

	Агрегат				 = Неопределено;
	ЭтоАгрегатСравнения	 = ЭтоМинимум Или ЭтоМаксимум;
	ЭтоПервыйЭлемент	 = Истина;
	КоличествоЭлементов	 = 0;
	РазличныеЗначения = Новый Массив();
	Для каждого ЭлементКоллекции Из Коллекция Цикл

		ТекущееЗначение = ?(Поле = Неопределено, ЭлементКоллекции, ЭлементКоллекции[Поле]);
		Если ЭтоПервыйЭлемент Тогда
			Если ЭтоАгрегатСравнения Тогда
				Агрегат = ТекущееЗначение;
			Иначе
				Агрегат = 0;
			КонецЕсли;
			ЭтоПервыйЭлемент = Ложь;
		КонецЕсли;

		Если ЭтоСумма Или ЭтоСреднее Тогда
			Агрегат = Агрегат + ТекущееЗначение;

		ИначеЕсли ЭтоМинимум Тогда
			Агрегат = Мин(Агрегат, ТекущееЗначение);

		ИначеЕсли ЭтоМаксимум Тогда
			Агрегат = Макс(Агрегат, ТекущееЗначение);

		ИначеЕсли ЭтоКоличество Тогда
			Агрегат = Агрегат + 1;

		ИначеЕсли ЭтоРазличные Тогда
			Если РазличныеЗначения.Найти(ТекущееЗначение) = Неопределено Тогда
				РазличныеЗначения.Добавить(ТекущееЗначение);
			КонецЕсли;

		Иначе
			Прервать;	// Обработано исключением выше

		КонецЕсли;

		КоличествоЭлементов = КоличествоЭлементов + 1;

	КонецЦикла;

	ЗначениеПосчитаноВАгрегате = ЭтоСумма Или ЭтоМинимум Или ЭтоМаксимум Или ЭтоКоличество;
	Если ЗначениеПосчитаноВАгрегате Тогда
		ЗначениеАгрегата = Агрегат;

	ИначеЕсли ЭтоСреднее Тогда
		ЗначениеАгрегата = Агрегат / КоличествоЭлементов;

	ИначеЕсли ЭтоРазличные Тогда
		ЗначениеАгрегата = РазличныеЗначения.Количество();

	Иначе
		ЗначениеАгрегата = 0;
	КонецЕсли;

	Возврат ЗначениеАгрегата;

КонецФункции // АгрегатКоллекции()

// Производит поиск в однородной коллекции, состоящих из элементов с полями (например, Массив из Структура)
//
// Параметры:
//  Коллекция 		 - Произвольный	 - Коллекция, поддерживающая обход "Для Каждого ..."
//  ПараметрыПоиска  - Структура:
//		* Ключ			 - Поле элемента коллекции, в котором производится поиск
//		* Значение		 - Искомое значение
//					 - Произвольный	 - Искомое значение
//  ПоляПоиска 		 - Строка		 - Поля элемента коллекции, в которых производится поиск, через запятую.
//									 Поиск производится по значению в любом из указанных полей.
//									 Если указана пустая строка, проверяются все поля элементов коллекции.
//	Лимит			 - Число		 - Поиск вернет лишь указанное число значений
//
// Варианты вызова:
//	НайтиЭлементыКоллекции(Произвольный, Структура)				 - Поиск по значениям нескольких полей.
//	НайтиЭлементыКоллекции(Произвольный, Произвольный, Строка)	 - Поиск по значению в любом поле из указанных.
//
// Возвращаемое значение:
//   Массив   - Найденные элементы коллекции
//
Функция НайтиЭлементыКоллекции(
	Коллекция, 
	Знач ПараметрыПоиска, 
	Знач ПоляПоиска = Неопределено, 
	Лимит = Неопределено) Экспорт
	
	НайденныеЭлементы = Новый Массив;
	
	Если Не ЗначениеЗаполнено(Коллекция) Тогда
		Возврат НайденныеЭлементы;
	КонецЕсли;

	ЭтоПоискПоОдномуЗначению = ПоляПоиска <> Неопределено;
	Если ЭтоПоискПоОдномуЗначению Тогда
		ПоляПоиска = СтрРазделить(ПоляПоиска, ", ", Ложь);
		ИскомоеЗначение = ПараметрыПоиска;
	КонецЕсли;

	// Для пустого отбора - пустой результат, как для ТаблицаЗначений.НайтиСтроки():
	Если Не ЭтоПоискПоОдномуЗначению И Не ЗначениеЗаполнено(ПараметрыПоиска) Тогда
		Возврат НайденныеЭлементы;
	КонецЕсли;
	
	НайденоЭлементов = 0;
	Для каждого ЭлементКоллекции Из Коллекция Цикл
		
		Если Лимит <> Неопределено И НайденоЭлементов = Лимит Тогда
			Прервать;
		КонецЕсли;

		Если ЭтоПоискПоОдномуЗначению И ЗначениеЗаполнено(ПоляПоиска) Тогда

			ЭлементСоответствуетОтбору = Ложь;
			Для каждого ИмяПоля Из ПоляПоиска Цикл
				Если ЭлементКоллекции[ИмяПоля] = ИскомоеЗначение Тогда
					ЭлементСоответствуетОтбору = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;	
				
		ИначеЕсли ЭтоПоискПоОдномуЗначению И Не ЗначениеЗаполнено(ПоляПоиска) Тогда

			// При незаполненных полях поиска пытаемся проверить все поля элементов коллекции.
			ЭлементСоответствуетОтбору = Ложь;
			Для каждого ПолеЭлементаКоллекции Из ЭлементКоллекции Цикл
				ЭтоКлючЗначение = ТипЗнч(ПолеЭлементаКоллекции) = Тип("КлючИЗначение");
				ПроверяемоеЗначение = ?(ЭтоКлючЗначение, ПолеЭлементаКоллекции.Значение, ПолеЭлементаКоллекции);
				Если ПроверяемоеЗначение = ИскомоеЗначение Тогда
					ЭлементСоответствуетОтбору = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;

		ИначеЕсли ЗначениеЗаполнено(ПараметрыПоиска) Тогда

			ЭлементСоответствуетОтбору = Истина;
			Для каждого ПараметрПоиска Из ПараметрыПоиска Цикл
				Если ЭлементКоллекции[ПараметрПоиска.Ключ] <> ПараметрПоиска.Значение Тогда
					ЭлементСоответствуетОтбору = Ложь;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		
		Иначе // Пустая структура отбора

			Прервать;

		КонецЕсли;

		Если ЭлементСоответствуетОтбору Тогда
			НайденныеЭлементы.Добавить(ЭлементКоллекции);
			НайденоЭлементов = НайденоЭлементов + 1;
		КонецЕсли;

	КонецЦикла;

	Возврат НайденныеЭлементы;

КонецФункции // НайтиЭлементыКоллекции()

// Производит поиск в однородной коллекции, состоящих из элементов с полями (например, Массив из Структура)
//
// Параметры:
//  Коллекция 		 - Произвольный	 - Коллекция, поддерживающая обход "Для Каждого ..."
//  ПараметрыПоиска  - Структура:
//		* Ключ			 - Поле элемента коллекции, в котором производится поиск
//		* Значение		 - Искомое значение
//					 - Произвольный	 - Искомое значение
//  ПоляПоиска 		 - Строка		 - Поля элемента коллекции, в которых производится поиск, через запятую.
//									 Поиск производится по значению в любом из указанных полей.
//									 Если указана пустая строка, проверяются все поля элементов коллекции.
//
// Варианты вызова:
//	НайтиЭлементыКоллекции(Произвольный, Структура)				 - Поиск по значениям нескольких полей.
//	НайтиЭлементыКоллекции(Произвольный, Произвольный, Строка)	 - Поиск по значению в любом поле из указанных.
//
// Возвращаемое значение:
//   Произвольный   - Найденный элемент коллекции
//
Функция НайтиЭлементКоллекции(
	Коллекция, 
	Знач ПараметрыПоиска, 
	Знач ПоляПоиска = Неопределено) Экспорт

	НайденныеЭлементы = НайтиЭлементыКоллекции(Коллекция, ПараметрыПоиска, ПоляПоиска, 1);
	Если ЗначениеЗаполнено(НайденныеЭлементы) Тогда
		НайденныйЭлемент = НайденныеЭлементы[0];
	Иначе
		НайденныйЭлемент = Неопределено;
	КонецЕсли;

	Возврат НайденныйЭлемент;
	
КонецФункции // НайтиЭлементКоллекции() 

// Производит поиск элементов коллекции по типу значений.
//
// Параметры:
//  Коллекция			 - Произвольный		 - Коллекция, поддерживающая обход "Для Каждого ..."
//  Тип					 - Тип				 - Тип искомых значений
//						 - ОписаниеТипов	 - Допустимые типы искомых значений
//	ТолькоЗаполненные	 - Булево			 - Будут отобраны только заполненные значения.
//
// Возвращаемое значение:
//	Массив - Отобранные элементы в порядке следования в исходном массиве.
//
Функция НайтиЭлементыКоллекцииПоТипу(Коллекция, Тип, ТолькоЗаполненные = Ложь)
	
	ОтобранныеЭлементы = Новый Массив;

	Если ТипЗнч(Тип) = Тип("Тип") Тогда
		ТипЭтоОписаниеТипов = Ложь;

	ИначеЕсли ТипЗнч(Тип) = Тип("ОписаниеТипов") Тогда
		ТипЭтоОписаниеТипов = Истина;

	Иначе
		ВызватьИсключение "Параметр Тип: Неожиданный тип";

	КонецЕсли;

	Для каждого ЭлементКоллекции Из Коллекция Цикл
		ТипЭлемента = ТипЗнч(ЭлементКоллекции);
		Если Не ТипЭтоОписаниеТипов И ТипЭлемента <> Тип Тогда
			Продолжить;
		КонецЕсли;
		Если ТипЭтоОписаниеТипов И Не Тип.СодержитТип(ТипЭлемента) Тогда
			Продолжить;
		КонецЕсли;
		Если ТолькоЗаполненные И Не ЗначениеЗаполнено(ЭлементКоллекции) Тогда
			Продолжить;
		КонецЕсли;
		ОтобранныеЭлементы.Добавить(ЭлементКоллекции);
	КонецЦикла;				

	Возврат ОтобранныеЭлементы;

КонецФункции // НайтиЭлементыКоллекцииПоТипу()

// Нумерует элементы коллекции
//
// Параметры:
//	Коллекция		 - Произвольный	 - Коллекция для обработки
//	ИмяПоляНомер	 - Строка		 - Имя поля или колонки, содержащей номер
//	НачальныйНомер	 - Число		 - Номер пермого элемента в коллекции
//
Процедура ПронумероватьКоллекцию(Коллекция, ИмяПоляНомер, НачальныйНомер = 1)

	НомерЭлемента = НачальныйНомер - 1;
	Для каждого ЭлементКоллекции Из Коллекция Цикл
		НомерЭлемента = НомерЭлемента + 1;
		ЭлементКоллекции[ИмяПоляНомер] = НомерЭлемента;
	КонецЦикла;

КонецПроцедуры // ПронумероватьКоллекцию()

#КонецОбласти	// Коллекции

// Производит заполнение шаблона со строковыми параметрами
//
// Параметры:
//  Шаблон		 - Строка	 - Строка вида "Параметр %Параметр% содержит значение %Значение%"
//  Поля		 - Структура, Соответствие - Коллекция с именами параметров и текстом, который надо подставить в шаблон. 
//											 Например: Новый Структура("Параметр, Значение", "Цвет", "Красный")
//  ПрефиксПоля	 - Строка	 - Префикс поля в шаблоне
//  СуффиксПоля	 - Строка	 - Суффикс поля в шаблоне
// 
// Возвращаемое значение:
//  Строка - Шаблон с подставленными параметрами
//
Функция ЗаполнитьПоляШаблона(Шаблон, Поля, ПрефиксПоля = "%", СуффиксПоля = "%") Экспорт

	Результат = Шаблон;
	Для каждого Поле Из Поля Цикл
		Результат = СтрЗаменить(Результат, ПрефиксПоля + Поле.Ключ + СуффиксПоля, Поле.Значение);
	КонецЦикла; 
	
	Возврат Результат;

КонецФункции // ЗаполнитьПоляШаблона()

// Делит разыменование поля на составляющие с неполными путями
// Пример: Разыменование вида Поле1.Поле2.Поле3 будет разложено на массив вида [Поле1, Поле1.Поле2, Поле1.Поле2.Поле3]
//
// Параметры:
//  Разыменование	 - Строка	 - Делимое разыменование
// 
// Возвращаемое значение:
//  Массив - Элемент: Строка
//
// Пример: 
//	Разыменование вида Поле1.Поле2.Поле3 будет разложено на массив вида [Поле1, Поле1.Поле2, Поле1.Поле2.Поле3]
//
Функция РазделитьРазыменованиеНаНеполныеПути(Знач Разыменование)

	МассивПолей	= СтрРазделить(Разыменование, ".");
	МассивПутей = Новый Массив;
	Для Индекс = 0 по МассивПолей.ВГраница() Цикл
		НеполныйПуть = Новый Массив;
		Для НеполныйИндекс = 0 По Индекс Цикл
			НеполныйПуть.Добавить(МассивПолей[НеполныйИндекс]);
		КонецЦикла; 		
		МассивПутей.Добавить(СтрСоединить(НеполныйПуть, "."));
	КонецЦикла; 
	
	Возврат МассивПутей;	

КонецФункции // РазделитьРазыменованиеНаНеполныеПути()

// Проверяет элемент данных на соответствие отбору.
//
// Параметры:
//  Элемент	 - Произвольный				 - Произвольная коллекция, к которой возможно обращение по имени поля. Например, СтрокаДереваЗначений.
//  Отбор	 - Структура, Неопределено	 - Накладываемый отбор. Поля отбора должны присутствовать в проверяемом элементе. Если Неопределено - элемент считается соответствующим отбору.
// 
// Возвращаемое значение:
//  Булево - Истина, если элемент соответствет отбору или отбор не определён
//
Функция ЭлементСоответствуетОтбору(Знач Элемент, Знач Отбор)

	Если Отбор = Неопределено Тогда Возврат Истина КонецЕсли; 
	
	Для каждого ЭлементОтбора Из Отбор Цикл
		Если Элемент[ЭлементОтбора.Ключ] <> ЭлементОтбора.Значение Тогда Возврат Ложь КонецЕсли 
	КонецЦикла; 

	Возврат Истина
	
КонецФункции // ЭлементСоответствуетОтбору()

#Область Строка

// <Описание функции>
//
// Параметры:
//   Строка - <Тип.Вид> - <описание параметра>
//
//  Возвращаемое значение:
//   <Тип.Вид> - <описание возвращаемого значения>
//
Функция СтрокаНачинаетсяНаБуквуКириллицы(Строка) Экспорт

	Если Не ЗначениеЗаполнено(Строка) Тогда
		Возврат Ложь;
	КонецЕсли; 	
	
	ПервыйСимвол = Лев(Строка, 1);
	
	Возврат ЭтоБукваКириллицы(ПервыйСимвол);

КонецФункции // СтрокаНачинаетсяНаБуквуКириллицы()
 
// <Описание функции>
//
// Параметры:
//   Строка - <Тип.Вид> - <описание параметра>
//
//  Возвращаемое значение:
//   <Тип.Вид> - <описание возвращаемого значения>
//
Функция СтрокаНачинаетсяНаБуквуЛатиницы(Строка) Экспорт

	Если Не ЗначениеЗаполнено(Строка) Тогда
		Возврат Ложь;
	КонецЕсли; 	
	
	ПервыйСимвол = Лев(Строка, 1);
	
	Возврат ЭтоБукваЛатиницы(ПервыйСимвол);

КонецФункции // СтрокаНачинаетсяНаБуквуЛатиницы()
 
// <Описание функции>
//
// Параметры:
//   Символ - <Тип.Вид> - <описание параметра>
//
//  Возвращаемое значение:
//   <Тип.Вид> - <описание возвращаемого значения>
//
Функция ЭтоБукваКириллицы(Символ) Экспорт

	Если СтрДлина(Символ) <> 1 Тогда
		Возврат Ложь;
	КонецЕсли; 	
	
	КодСимвола = КодСимвола(Символ);
	
	Возврат КодСимвола("А") <= КодСимвола И КодСимвола <= КодСимвола("Я")
			Или КодСимвола("а") <= КодСимвола И КодСимвола <= КодСимвола("я")
			Или Символ = "Ё" или Символ = "ё";

КонецФункции // ЭтоБукваКириллицы()
 
// <Описание функции>
//
// Параметры:
//   Символ - <Тип.Вид> - <описание параметра>
//
//  Возвращаемое значение:
//   <Тип.Вид> - <описание возвращаемого значения>
//
Функция ЭтоБукваЛатиницы(Символ) Экспорт

	Если СтрДлина(Символ) <> 1 Тогда
		Возврат Ложь;
	КонецЕсли; 	
	
	КодСимвола = КодСимвола(Символ);
	
	Возврат КодСимвола("A") <= КодСимвола И КодСимвола <= КодСимвола("Z")
			Или КодСимвола("a") <= КодСимвола И КодСимвола <= КодСимвола("z");

КонецФункции // ЭтоБукваЛатиницы()

// Выполняет транслитерацию строки.
// см. https://ru.wikipedia.org/wiki/Транслитерация_русского_алфавита_латиницей
//
// Параметры:
//  Фраза	 - Строка	 - Исходная строка
//  Стандарт - Строка	 - Стандарт транслитерации. Варианты:
//		* 4271	 - Приказ МИД N 4271 (2016-н/в) (см. http://www.consultant.ru/document/cons_doc_LAW_198429/c956ff01bf42465d7052431dec215b77d0404875)
//		* 310	 - Приказ МВД N 310 (1997-2010)
// 
// Возвращаемое значение:
//  Строка - Результат транслитерации
//
Функция ТранслитерироватьСтроку(Знач Фраза, Стандарт = "4271")
	
	// Контрольный пример: абвгдеёжзийклмнопрстуфхцчшщъыьэюя. Съешь этих мягких французских булочек, да выпей же чаю. ВЕРХНИЙРЕГИСТР, Перваязаглавная, нижнийрегистр, СмешанныйРегистр. Слова123с5434Цифрами.и_$ЗНАКАМИ%вперемешку.
	
	ФразаЛатиницей = "";
	
	СоответствиеБукв = Новый Соответствие;
	#Область ОбщиеДляВсехСтандартовСимволы
	
	// Те символы, которые различаются в стандартах - не заполнены
	СоответствиеБукв.Вставить("а", "a");
	СоответствиеБукв.Вставить("б", "b");
	СоответствиеБукв.Вставить("в", "v");
	СоответствиеБукв.Вставить("г", "g");
	СоответствиеБукв.Вставить("д", "d");
	СоответствиеБукв.Вставить("е", "");
	СоответствиеБукв.Вставить("ё", "");
	СоответствиеБукв.Вставить("ж", "");
	СоответствиеБукв.Вставить("з", "z");
	СоответствиеБукв.Вставить("и", "");
	СоответствиеБукв.Вставить("й", "");
	СоответствиеБукв.Вставить("к", "k");
	СоответствиеБукв.Вставить("л", "l");
	СоответствиеБукв.Вставить("м", "m");
	СоответствиеБукв.Вставить("н", "n");
	СоответствиеБукв.Вставить("о", "o");
	СоответствиеБукв.Вставить("п", "p");
	СоответствиеБукв.Вставить("р", "r");
	СоответствиеБукв.Вставить("с", "s");
	СоответствиеБукв.Вставить("т", "t");
	СоответствиеБукв.Вставить("у", "u");
	СоответствиеБукв.Вставить("ф", "f");
	СоответствиеБукв.Вставить("х", "");
	СоответствиеБукв.Вставить("ц", "");
	СоответствиеБукв.Вставить("ч", "");
	СоответствиеБукв.Вставить("ш", "");
	СоответствиеБукв.Вставить("щ", "");
	СоответствиеБукв.Вставить("ъ", "");
	СоответствиеБукв.Вставить("ы", "");
	СоответствиеБукв.Вставить("ь", "");
	СоответствиеБукв.Вставить("э", "");
	СоответствиеБукв.Вставить("ю", "");
	СоответствиеБукв.Вставить("я", "");
	
	// Буквы-исключения: Е, Ё, Ж, И, Й, Х, Ц, Ч, Ш, Щ, Ъ, Ы, Ь, Э, Ю, Я.
	БуквыИсключения = СтрРазделить("е, ё, ж, и, й, х, ц, ч, ш, щ, ъ, ы, ь, э, ю, я", ", ", Ложь);
	Для каждого ТекущийСимвол Из БуквыИсключения Цикл
		СоответствиеБукв.Вставить(ТекущийСимвол, "");
	КонецЦикла; 
	
	#КонецОбласти // ОбщиеДляВсехСтандартовСимволы 
	
	#Область ОписаниеСтандартов
	Если Стандарт = "4271" Тогда
		
		СоответствиеБукв.Вставить("е", "e");
		СоответствиеБукв.Вставить("ё", "e");
		СоответствиеБукв.Вставить("ж", "zh");
		СоответствиеБукв.Вставить("и", "i");
		СоответствиеБукв.Вставить("й", "i");
		СоответствиеБукв.Вставить("х", "kh");
		СоответствиеБукв.Вставить("ц", "ts");
		СоответствиеБукв.Вставить("ч", "ch");
		СоответствиеБукв.Вставить("ш", "sh");
		СоответствиеБукв.Вставить("щ", "shch");
		СоответствиеБукв.Вставить("ъ", "ie");
		СоответствиеБукв.Вставить("ы", "y");
		СоответствиеБукв.Вставить("ь", ""); // пропускается
		СоответствиеБукв.Вставить("э", "e");
		СоответствиеБукв.Вставить("ю", "iu");
		СоответствиеБукв.Вставить("я", "ia");		
		
	ИначеЕсли Стандарт = "310" Тогда
		
		// см. СтроковыеФункцииКлиентСервер.СоответствиеКириллицыИЛатиницы() 
		// или СтроковыеФункцииКлиентСервер.СоответствиеНациональногоАлфавитаИЛатиницы() (БСП)
		СоответствиеБукв.Вставить("е", "e");
		СоответствиеБукв.Вставить("ё", "e");
		СоответствиеБукв.Вставить("ж", "zh");
		СоответствиеБукв.Вставить("и", "i");
		СоответствиеБукв.Вставить("й", "y");
		СоответствиеБукв.Вставить("х", "kh");
		СоответствиеБукв.Вставить("ц", "ts");
		СоответствиеБукв.Вставить("ч", "ch");
		СоответствиеБукв.Вставить("ш", "sh");
		СоответствиеБукв.Вставить("щ", "shch");
		СоответствиеБукв.Вставить("ъ", """");
		СоответствиеБукв.Вставить("ы", "y");
		СоответствиеБукв.Вставить("ь", ""); // пропускается
		СоответствиеБукв.Вставить("э", "e");
		СоответствиеБукв.Вставить("ю", "yu");
		СоответствиеБукв.Вставить("я", "ya");	
		
	Иначе 
		
		Возврат "";
		
	КонецЕсли; 
	#КонецОбласти // ОписаниеСтандартов 
	
	ПредыдущийСимвол = "";
	
	Слово = "";
	СловоЛатиницей = "";
	ДлинаСтроки = СтрДлина(Фраза);
	Для Позиция = 1 По ДлинаСтроки Цикл
		
		ТекущийСимвол = Сред(Фраза, Позиция, 1);
		
		ЭтоБуква = СоответствиеБукв[НРег(ТекущийСимвол)] <> Неопределено;
		
		Если ЭтоБуква Тогда
			
			Буква = ТекущийСимвол;
			БукваЛатиницей = СоответствиеБукв[НРег(ТекущийСимвол)]; // Поиск соответствия без учета регистра.
			Если Буква = ВРег(Буква) Тогда
				БукваЛатиницей = ТРег(БукваЛатиницей);			
			КонецЕсли; 
			
			Слово = Слово + Буква;
			СловоЛатиницей = СловоЛатиницей + БукваЛатиницей;			
		
		КонецЕсли; 
		
		СловоЗакончилось = ЗначениеЗаполнено(Слово) и (не ЭтоБуква или Позиция = ДлинаСтроки);
		
		Если СловоЗакончилось Тогда
			
			Если Слово = Врег(Слово) Тогда
				СловоЛатиницей = ВРег(СловоЛатиницей);
			ИначеЕсли Слово = НРег(Слово) Тогда
				СловоЛатиницей = НРег(СловоЛатиницей);
			ИначеЕсли Слово = ТРег(Слово) Тогда
				СловоЛатиницей = ТРег(СловоЛатиницей);
			КонецЕсли; 
			ФразаЛатиницей = ФразаЛатиницей + СловоЛатиницей;	
			
			Слово = "";
			СловоЛатиницей = "";
		
		КонецЕсли; 
		
		Если не ЭтоБуква Тогда
		
			ФразаЛатиницей = ФразаЛатиницей + ТекущийСимвол;
		
		КонецЕсли; 
		
	КонецЦикла;
	
	Возврат ФразаЛатиницей;
	
КонецФункции // ТранслитерироватьСтроку

// Различающиеся символы раскладок клавиатуры Йцукен и Qwerty
//
// Возвращаемое значение:
//   Структура - Символы раскладок в порядке, соответствующем положению клавиш на клавиатуре.
//		* Йцукен - Строка - Символы раскладки кириллицы
//		* Qwerty - Строка - Символы раскладки латиницы
//
Функция РазличныеСимволыРаскладокЙцукенQwerty()
	
	Йцукен			= "ЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ,Ё!""№;%:?/"; // Заглавный алфавит, потом верхний ряд с Ё до 7, потом шифт-черта
	Qwerty			= "QWERTYUIOP{}ASDFGHJKL:""ZXCVBNM<>?~!@#$%^&|"; // Заглавный алфавит, потом верхний ряд с ~ до 7, потом шифт-черта
	Йцукен = Йцукен + "йцукенгшщзхъфывапролджэячсмитьбю.ё";			 // Строчный алфавит и ё
	Qwerty = Qwerty + "qwertyuiop[]asdfghjkl;'zxcvbnm,./`";			 // Строчный алфавит и `

	Раскладки = Новый Структура;
	Раскладки.Вставить("Йцукен", Йцукен);
	Раскладки.Вставить("Qwerty", Qwerty);

	Если СтрДлина(Йцукен) <> СтрДлина(Qwerty) Тогда
		ВызватьИсключение "Количество символов в раскладках не совпадает";
	КонецЕсли;

	Возврат Раскладки;

КонецФункции // РазличныеСимволыРаскладокЙцукенQwerty()

// см. СтрокаИзДругойРаскладки()
//
Функция СтрокаQwertyИзЙцукен(ИсходнаяСтрока) Экспорт
	
	Возврат СтрокаИзДругойРаскладки(ИсходнаяСтрока, "Йцукен", "Qwerty");

КонецФункции // СтрокаQwertyИзЙцукен()

// см. СтрокаИзДругойРаскладки()
//
Функция СтрокаЙцукенИзQwerty(ИсходнаяСтрока) Экспорт
	
	Возврат СтрокаИзДругойРаскладки(ИсходнаяСтрока, "Qwerty", "Йцукен");

КонецФункции // СтрокаЙцукенИзQwerty()

// Посимвольно преобразует строку из другой раскладки в порядке расположения клавиш клиавиатуры другой раскладки.
//
// Параметры:
//  ИсходнаяСтрока			 - Строка
//  ИмяРаскладкиИсточник	 - Строка - см. ИмяРаскладкиНазначение
//	ИмяРаскладкиНазначение	 - Строка:
//		* "Qwerty" - Латиница
//		* "Йцукен" - Кириллица
//
// Возвращаемое значение:
//   Строка   - Преобразованная строка
//
Функция СтрокаИзДругойРаскладки(ИсходнаяСтрока, ИмяРаскладкиИсточник, ИмяРаскладкиНазначение)
	
	Раскладки			 = РазличныеСимволыРаскладокЙцукенQwerty();
	РаскладкаИсточник	 = Раскладки[ИмяРаскладкиИсточник];
	РаскладкаНазначение	 = Раскладки[ИмяРаскладкиНазначение];

	Результат = "";
	ЕстьСимволыДругойРаскладки = Ложь;
	Для НомерСимвола = 1 По СтрДлина(ИсходнаяСтрока) Цикл
		
		ТекСимвол = Сред(ИсходнаяСтрока, НомерСимвола, 1);

		Если Не ЕстьСимволыДругойРаскладки Тогда
			ЕстьСимволыДругойРаскладки = Булево(СтрНайти(РаскладкаИсточник, ТекСимвол));
			Если ЕстьСимволыДругойРаскладки Тогда
				// Построим соответствия раскладок
				СоответствиеСимволов = Новый Соответствие;
				Для НомерСимволаРаскладки = 1 По СтрДлина(РаскладкаИсточник) Цикл
					СимволРаскладкиИсточник		 = Сред(РаскладкаИсточник,	 НомерСимволаРаскладки, 1);
					СимволРаскладкиНазначение	 = Сред(РаскладкаНазначение, НомерСимволаРаскладки, 1);
					СоответствиеСимволов[СимволРаскладкиИсточник] = СимволРаскладкиНазначение;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;

		Если ЕстьСимволыДругойРаскладки Тогда
			СимволНазначение = СоответствиеСимволов[ТекСимвол];
			Результат = Результат + ?(СимволНазначение <> Неопределено, СимволНазначение, ТекСимвол);
		Иначе
			Результат = Результат + ТекСимвол;
		КонецЕсли; 

	КонецЦикла;

	Возврат Результат;

КонецФункции // СтрокаИзДругойРаскладки()



// Проверяет, является ли переданное значение ссылкой
//
// Параметры:
//  Значение - Произвольный	 - Проверяемое значение
// 
// Возвращаемое значение:
//  Булево
//
Функция ЭтоСсылка(Значение) Экспорт
	
	Если пм_ОбщегоНазначенияКлиентСервер.ЭтоПримитивныйТип(Значение) 
		Или ТипЗнч(Значение) = Тип("УникальныйИдентификатор") Тогда
		Возврат Ложь;
	КонецЕсли;
	
    СтрокаXML = СериализаторXDTO.XMLСтрока(Значение);                         
	Если пм_ОбщегоНазначенияКлиентСервер.ЭтоУникальныйИдентификатор(СтрокаXML) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;

КонецФункции // ЭтоСсылка()

 
// Проверяет, имеет ли строка формат Base64
// см. RFC 2045 (https://datatracker.ietf.org/doc/html/rfc2045)
//
// Параметры:
//  Строка - Строка - Проверяемая строка
//
// Возвращаемое значение:
//   Булево   - Если это Base64, возвращается Истина.
//
Функция ЭтоСтрокаBase64(Строка) Экспорт

	Если ТипЗначения(Строка) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;

	Алфавит = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/" + Символы.ПС;
	ЕстьДваСуффикса = СтрЗаканчиваетсяНа(Строка, "==");
	ЕстьСуффикс = ЕстьДваСуффикса Или СтрЗаканчиваетсяНа(Строка, "=");
	Если Не ЕстьСуффикс Тогда
		Возврат Ложь;
	КонецЕсли;

	ДлинаСуффикса = ?(ЕстьДваСуффикса, 2, 1);
	Для НомерСимвола = 1 По СтрДлина(Строка) - ДлинаСуффикса Цикл
		Если СтрНайти(Алфавит, Сред(Строка, НомерСимвола, 1)) = 0 Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;

	Возврат Истина; 

КонецФункции // ЭтоСтрокаBase64()

// Проверяет, является ли строка уникальным идентификатором
//  вида "123e4567-e89b-12d3-a456-426655440000"
//
// Параметры:
//  Строка					 - Строка	 - Проверяемая строка
//  ДопускатьСкобки			 - Булево	 - Идентификатор может быть обрамлён в (круглые) или {фигурные} скобки
//  ДопускатьДвоичныйФормат	 - Булево	 - Идентификатор может начинаться префиксом 0x.
// 
// Возвращаемое значение:
//  Булево
//
Функция ЭтоУникальныйИдентификатор(Строка, ДопускатьСкобки = Ложь, ДопускатьДвоичныйФормат = Ложь) Экспорт

	Если ПустаяСтрока(Строка) Тогда
		Возврат Ложь;
	КонецЕсли;

	Скобки = "(){}";
	ПервыйСимвол	 = Лев(Строка, 1);
	ПоследнийСимвол	 = Прав(Строка, 1);
	ЕстьСкобки = СтрНайти(Скобки, ПервыйСимвол) > 0 И СтрНайти(Скобки, ПоследнийСимвол) > 0;
	Если ЕстьСкобки И Не ДопускатьСкобки Тогда
		Возврат Ложь;
	КонецЕсли;

	ДвоичныйПрефикс = "0x";
	ПозицияПрефикса = ?(ЕстьСкобки, 2, 1);
	ЕстьПрефикс = НРег(Сред(Строка, ПозицияПрефикса, 2)) = ДвоичныйПрефикс;
	Если ЕстьПрефикс И Не ДопускатьДвоичныйФормат Тогда
		Возврат Ложь;
	КонецЕсли;

	ОжидаемаяДлина = 32;
	Если ЕстьПрефикс Тогда
		ОжидаемаяДлина = ОжидаемаяДлина + 2;	// Префикс
	Иначе
		ОжидаемаяДлина = ОжидаемаяДлина + 4;	// Дефисы
	КонецЕсли;
	Если ЕстьСкобки Тогда
		ОжидаемаяДлина = ОжидаемаяДлина + 2;	// Скобки
	КонецЕсли;
	Если СтрДлина(Строка) <> ОжидаемаяДлина Тогда
		Возврат Ложь;
	КонецЕсли;

	ЗначащаяЧасть = Строка;
	Если ЕстьСкобки Тогда
		Если СтрНайти(Скобки, ПервыйСимвол) + 1 <> СтрНайти(Скобки, ПоследнийСимвол) Тогда // Разные скобки
			Возврат Ложь;
		КонецЕсли;
		ЗначащаяЧасть = Сред(ЗначащаяЧасть, 2, СтрДлина(ЗначащаяЧасть) - 2);
	КонецЕсли;

	Если ЕстьПрефикс Тогда
		ЗначащаяЧасть = Сред(ЗначащаяЧасть, 3);
		Если СтрНайти(ЗначащаяЧасть, "-") Тогда
			Возврат Ложь;
		КонецЕсли;
	Иначе
		ДопустимыеПозицииДефиса = Новый Массив;
		ДопустимыеПозицииДефиса.Добавить(9);
		ДопустимыеПозицииДефиса.Добавить(14);
		ДопустимыеПозицииДефиса.Добавить(19);
		ДопустимыеПозицииДефиса.Добавить(24);
	КонецЕсли;

	ДопустимыеСимволы = "0123456789abcdef";
	Для НомерСимвола = 1 По СтрДлина(ЗначащаяЧасть) Цикл
		ТекущийСимвол = Сред(ЗначащаяЧасть, НомерСимвола, 1);
		ЭтоДефис = ТекущийСимвол = "-";
		ЭтоДефисВДопустимойПозиции = ЭтоДефис И ДопустимыеПозицииДефиса.Найти(НомерСимвола) <> Неопределено;
		ЭтоДопустимыйСимвол = Не ЭтоДефис И СтрНайти(ДопустимыеСимволы, ТекущийСимвол) > 0;
		Если Не ЭтоДопустимыйСимвол И Не ЭтоДефисВДопустимойПозиции Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;	

КонецФункции // ЭтоУникальныйИдентификатор()

// Преобразует число из шестнадцатеричной системы счисления в десятичную
//
// Параметры:
//   ЧислоСтрокой - Строка - Шестнадцатеричное число
//
//  Возвращаемое значение:
//   Число - Десятичное число
//
Функция ДесятЧислоИзШестн(Число) Экспорт
	ЧислоСтрокой = ПреобразоватьСистемуСчисления(Число, 16, 10);
	Возврат Число(ЧислоСтрокой); 
КонецФункции // ДесятЧислоИзШестн()

// Преобразует число из десятичной системы счисления в шестнадцатеричную
//
// Параметры:
//	Число - Число, Строка - Исходное число
//
// Возвращаемое значение:
//	Строка - Шестнадцатеричное число
//
Функция ШестнЧислоИзДесят(Знач Число) Экспорт
	Если ТипЗнч(Число) = Тип("Число") Тогда
		Число = Формат(Число, "ЧГ=;ЧН=0");
	КонецЕсли;
	Возврат ПреобразоватьСистемуСчисления(Число, 10, 16);
КонецФункции // ШестнЧислоИзДесят()

// Переводит число из одной позиционной системы счисления в другую.
//
// Параметры:
//	ЧислоСтрокой		 - Строка	 - Исходное число
//	ОснованиеИсходное	 - Число	 - Основание исходного числа. Для десятичной системы будет 10, для двоичной - 2.
//	ОснованиеНовое		 - Число	 - Целевое основание.
//
// Возвращаемое значение:
//	Строка - Строковое представление числа.
//
Функция ПреобразоватьСистемуСчисления(Знач ЧислоСтрокой, ОснованиеИсходное, ОснованиеНовое) Экспорт

	Если ОснованиеИсходное = ОснованиеНовое Тогда
		Возврат ЧислоСтрокой;
	КонецЕсли;

	Алфавит = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	ЕмкостьАлфавита = СтрДлина(Алфавит);
	
	МаксОснование = Макс(ОснованиеИсходное, ОснованиеНовое);
	Если МаксОснование > ЕмкостьАлфавита Тогда 
		ВызватьИсключение "Основание больше ёмкости алфавита";
	КонецЕсли;

	Если Мин(ОснованиеИсходное, ОснованиеНовое) < 2 Тогда
		ВызватьИсключение "Неверно указано Основание";
	КонецЕсли;

	Цифры = Новый Массив;
	Числа = Новый Соответствие;
	Для НомерСимвола = 1 По Мин(ЕмкостьАлфавита, МаксОснование) Цикл
		Символ = Сред(Алфавит, НомерСимвола, 1);
		Цифры.Добавить(Символ);
		Числа[Символ] = НомерСимвола - 1;
	КонецЦикла;

	ЧислоСтрокой = СокрЛП(ЧислоСтрокой);
	ДлинаЧислаИсх = СтрДлина(ЧислоСтрокой);

	// Из произвольной в десятичную:
	ЧислоДес = 0;
	Для НомерСимвола = 1 По ДлинаЧислаИсх Цикл
		Степень = ДлинаЧислаИсх - НомерСимвола;
		Символ = Сред(ЧислоСтрокой, НомерСимвола, 1);
		Число = Числа[Символ];
		Если Число = Неопределено Или Число >= ОснованиеИсходное Тогда
			ВызватьИсключение "Исходное число не соответствует своей системе счисления";
		КонецЕсли;
		ЧислоДес = ЧислоДес + Число * Pow(ОснованиеИсходное, Степень);
	КонецЦикла;

	Если ОснованиеНовое = 10 Тогда
		Возврат Формат(ЧислоДес, "ЧГ=;ЧН=0");
	КонецЕсли;

	// Из десятичного в произвольную:
	ЧислоНовое = "";
	Частное = ЧислоДес;
	Пока Частное > 0 Цикл
		Остаток = Частное % ОснованиеНовое;
		ЧислоНовое = Цифры[Остаток] + ЧислоНовое;
		Частное = Цел(Частное / ОснованиеНовое);
	КонецЦикла;

	Возврат ЧислоНовое;

КонецФункции // ПреобразоватьСистемуСчисления()

#КонецОбласти // Строка

#Область УникальныйИдентификатор

// Преобразует уникальный идентификатор в шестнадцатеричное число,
//	которое используется в навигационных ссылках
//
// Параметры:
//  УникальныйИдентификатор	 - УникальныйИдентификатор, Строка	 - Преобразуемый идентификатор
//  ДобавитьПрефикс			 - Булево							 - Если Истина - к числу будет добавлен префикс "0x"
// 
// Возвращаемое значение:
//   - Строка   - Сформированное строковое представление числа, 
//					Если формат идентификатора не верен, возвращается Неопределено.
//
Функция УникальныйИдентификаторВШестнадцатеричноеЧисло(Знач УникальныйИдентификатор, ДобавитьПрефикс = Истина)

	// Входящее:	00112233-4455-6677-8899-aabbccddeeff
	// Ожидается:	[0x]8899aabbccddeeff6677445500112233
	
	СоставныеЧасти = СтрРазделить(Строка(УникальныйИдентификатор), "-", Ложь);
	Если СоставныеЧасти.Количество() <> 5 Тогда Возврат Неопределено КонецЕсли; 	
	
	ШестнадцатеричноеЧисло = 
	?(ДобавитьПрефикс, "0x", "")
	+ СоставныеЧасти[3]		// 8899 
	+ СоставныеЧасти[4]		// aabbccddeeff
	+ СоставныеЧасти[2]		// 6677
	+ СоставныеЧасти[1]		// 4455
	+ СоставныеЧасти[0];	// 00112233
	
	Возврат ШестнадцатеричноеЧисло;

КонецФункции // УникальныйИдентификаторВШестнадцатеричноеЧисло()

// Формирует уникальный идентификатор из шестнадцатеричного числа
//
// Параметры:
//  ШестнадцатеричноеЧисло	 - Строка	 - Шестнадцатиричное число. Может предваряться префиксом "0x"
// 
// Возвращаемое значение:
//  УникальныйИдентификатор - Сформированный уникальный идентификатор
//
Функция УникальныйИдентификаторИзШестнадцатеричногоЧисла(Знач ШестнадцатеричноеЧисло)

	// Входящее:	[0x]8899aabbccddeeff6677445500112233
	// Ожидается:	00112233-4455-6677-8899-aabbccddeeff
	
	ШестнадцатеричноеЧислоБезПрефикса = СтрЗаменить(ШестнадцатеричноеЧисло, "0x", "");
	Если СтрДлина(ШестнадцатеричноеЧислоБезПрефикса) <> 32 Тогда Возврат Неопределено КонецЕсли;
	
	// Разметка:        1   5           17  21  25
	// Входящее:	[0x]8899aabbccddeeff6677445500112233
	ЧастиЧисла = Новый Массив;
	ЧастиЧисла.Добавить(Сред(ШестнадцатеричноеЧислоБезПрефикса, 1,	 4));	// 8899
	ЧастиЧисла.Добавить(Сред(ШестнадцатеричноеЧислоБезПрефикса, 5,	 12));	// aabbccddeeff
	ЧастиЧисла.Добавить(Сред(ШестнадцатеричноеЧислоБезПрефикса, 17,	 4));	// 6677
	ЧастиЧисла.Добавить(Сред(ШестнадцатеричноеЧислоБезПрефикса, 21,	 4));	// 4455
	ЧастиЧисла.Добавить(Сред(ШестнадцатеричноеЧислоБезПрефикса, 25,	 8));	// 00112233
	
	УникальныйИдентификатор = Новый УникальныйИдентификатор(
			ЧастиЧисла[4]		// 00112233
	+ "-" + ЧастиЧисла[3]		// 4455
	+ "-" + ЧастиЧисла[2]		// 6677
	+ "-" + ЧастиЧисла[0]		// 8899 
	+ "-" + ЧастиЧисла[1]		// aabbccddeeff
	);
	
	Возврат УникальныйИдентификатор;

КонецФункции // УникальныйИдентификаторИзШестнадцатеричногоЧисла()

#КонецОбласти // УникальныйИдентификатор

#Область НавигационныеСсылки

// Формирует представления навигационных ссылок в формате Соответствия
//
// Параметры:
//	НавигационныеСсылки - Массив из Строка - Получаемые ссылки
//
// Возвращаемое значение:
//	Соответствие:
//		* Ключ		 - Строка		 - Переданная навигационная ссылка из параметра НавигационныеСсылки
//		* Значение	 - Строка		 - Представление навигационной ссылки.
//					 - Неопределено	 - Объект отсутствует в базе.
//
Функция ПредставленияНавигационныхСсылок(НавигационныеСсылки)
	
	Представления = Новый Соответствие;

	ПредставленияНавСсылок = ПолучитьПредставленияНавигационныхСсылок(НавигационныеСсылки);
	Для Индекс = 0 По НавигационныеСсылки.ВГраница() Цикл
		ПредставлениеНавСсылки = ПредставленияНавСсылок[Индекс];
		Если ТипЗнч(ПредставлениеНавСсылки) = Тип("ПредставлениеНавигационнойСсылки") Тогда
			Представление = ПредставлениеНавСсылки.Текст;
		Иначе
			Представление = Неопределено;
		КонецЕсли; 
		Представления.Вставить(НавигационныеСсылки[Индекс], Представление);
	КонецЦикла; 	
	
	Возврат Представления;

КонецФункции // ПредставленияНавигационныхСсылок()
 
// Получает представление навигационной ссылки
//
// Параметры:
//	НавигационнаяСсылка - Строка - Получаемая ссылка
//
// Возвращаемое значение:
//	Строка		 - Представление навигационной ссылки. Если объект отсутствует в базе - пустая строка.
//
Функция ПредставлениеНавигационнойСсылки(НавигационнаяСсылка)
	
	Представление = "";
	
	НавигационныеСсылки = Новый Массив;
	Если ЗначениеЗаполнено(НавигационнаяСсылка) Тогда
		НавигационныеСсылки.Добавить(НавигационнаяСсылка);
	КонецЕсли; 
	ПредставленияНавСсылок = ПолучитьПредставленияНавигационныхСсылок(НавигационныеСсылки);
	Если ЗначениеЗаполнено(ПредставленияНавСсылок) Тогда
		ПредставлениеНавСсылки = ПредставленияНавСсылок[0];
		Если ТипЗнч(ПредставлениеНавСсылки) = Тип("ПредставлениеНавигационнойСсылки") Тогда
			Представление = ПредставлениеНавСсылки.Текст;
		КонецЕсли; 
	КонецЕсли;

	Возврат Представление;
	
КонецФункции	// ПредставлениеНавигационнойСсылки()

#КонецОбласти // НавигационныеСсылки
