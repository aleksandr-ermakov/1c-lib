
// Преобразовывает Дерево значений в Таблицу значений
//
// Параметры:
//	УзелДерева		 - ДеревоЗначений, СтрокаДереваЗначений - Дерево значений или его ветка, которую следует преобразовать.
//	ТолькоЛистья	 - Булево - Если Истина, в таблицу будут выгружены только строки дерева значений,
//								не имеющие подчиненных строк.
//	ТаблицаЗначений	 - ТаблицаЗначений - (служебный) Содержит выходную таблицу значений
//
Функция ТаблицаЗначенийИзДереваЗначений(УзелДерева, ТолькоЛистья = Ложь, ТаблицаЗначений = Неопределено)

	Если ТипЗнч(УзелДерева) <> Тип("СтрокаДереваЗначений") И ТипЗнч(УзелДерева) <> Тип("ДеревоЗначений") Тогда
		ВызватьИсключение "Параметр УзелДерева: Ожидается тип СтрокаДереваЗначений или ДеревоЗначений";
	КонецЕсли;

	ЭтоСтрокаДерева = ТипЗнч(УзелДерева) = Тип("СтрокаДереваЗначений");
	ЭтоКореньДерева = Не ЭтоСтрокаДерева;
	ЭтоЛистДерева = Не ЗначениеЗаполнено(УзелДерева.Строки);

	Если ТипЗнч(ТаблицаЗначений) <> Тип("ТаблицаЗначений") Тогда

		ТаблицаЗначений = Новый ТаблицаЗначений;
		Если ЭтоКореньДерева Тогда
			Колонки = УзелДерева.Колонки;
		Иначе
			Колонки = УзелДерева.Владелец().Колонки;
		КонецЕсли;
		Для каждого Колонка Из Колонки Цикл
			ТаблицаЗначений.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения, Колонка.Заголовок, Колонка.Ширина);
		КонецЦикла;

	КонецЕсли;

	Если ЭтоСтрокаДерева 
		И (ЭтоЛистДерева Или Не ТолькоЛистья) Тогда

		СтрокаТаблицы = ТаблицаЗначений.Добавить();
		Для каждого Колонка Из ТаблицаЗначений.Колонки Цикл
			СтрокаТаблицы[Колонка.Имя] = УзелДерева[Колонка.Имя];
		КонецЦикла;
		
	КонецЕсли;

	Для каждого СтрокаДерева Из УзелДерева.Строки Цикл
		ТаблицаЗначенийИзДереваЗначений(СтрокаДерева, ТолькоЛистья, ТаблицаЗначений)
	КонецЦикла;

	Возврат ТаблицаЗначений;

КонецФункции // ТаблицаЗначенийИзДереваЗначений()

// Создаёт типизированную таблицу значений из соответствия
//
// Параметры:
//  Соответствие - Соответствие	 - Исходное соответствие.
//  ИменаКолонок - Строка		 - Имена двух колонок новой таблицы через запятую.
// 
// Возвращаемое значение:
//  ТаблицаЗначений - Сформированная таблица
//
Функция ТаблицаЗначенийИзСоответствия(Соответствие, Знач ИменаКолонок = "Ключ, Значение") Экспорт
	
	Если ТипЗнч(Соответствие) <> Тип("Соответствие") Тогда
		ВызватьИсключение "Параметр Соответствие: Ожидается тип Соответствие";
	ИначеЕсли ТипЗнч(ИменаКолонок) <> Тип("Строка") Тогда
		ВызватьИсключение "Параметр ИменаКолонок: Ожидается тип Строка";
	ИначеЕсли Не СтрНайти(ИменаКолонок, ",") Тогда
		ВызватьИсключение "Параметр ИменаКолонок: Ожидается два имени через запятую";
	КонецЕсли; 
	
	ИменаКолонок = СтрРазделить(ИменаКолонок, ", ", Ложь);
	ЗначенияКлючей			 = Новый Массив;
	ЗначенияЗначений		 = Новый Массив;
	ТипыКлючей				 = Новый Массив;
	ТипыЗначений			 = Новый Массив;
	ПредыдущийТипКлюча		 = Неопределено;
	ПредыдущийТипЗначения	 = Неопределено;
	
	ТаблицаЗначений = Новый ТаблицаЗначений;
	
	Для каждого ЭлементСоответствия Из Соответствие Цикл
		
		ТаблицаЗначений.Добавить();
		ЗначенияКлючей.Добавить(ЭлементСоответствия.Ключ);
		ЗначенияЗначений.Добавить(ЭлементСоответствия.Значение);
		
		ТипКлюча = ТипЗнч(ЭлементСоответствия.Ключ);
		Если ТипКлюча <> ПредыдущийТипКлюча
			И ТипыКлючей.Найти(ТипКлюча) = Неопределено Тогда
			ТипыКлючей.Добавить(ТипКлюча);
		КонецЕсли; 
		ПредыдущийТипКлюча = ТипКлюча;
		
		ТипЗначения = ТипЗнч(ЭлементСоответствия.Значение);
		Если ТипЗначения <> ПредыдущийТипЗначения
			И ТипыЗначений.Найти(ТипЗначения) = Неопределено Тогда
			ТипыЗначений.Добавить(ТипЗначения);
		КонецЕсли; 
		ПредыдущийТипЗначения = ТипЗначения;
		
	КонецЦикла; 
	
	ТаблицаЗначений.Колонки.Добавить(ИменаКолонок[0], Новый ОписаниеТипов(ТипыКлючей));	
	ТаблицаЗначений.Колонки.Добавить(ИменаКолонок[1], Новый ОписаниеТипов(ТипыЗначений));	
	ТаблицаЗначений.ЗагрузитьКолонку(ЗначенияКлючей,	 0);
	ТаблицаЗначений.ЗагрузитьКолонку(ЗначенияЗначений,	 1);
	
	Возврат ТаблицаЗначений;
	
КонецФункции

// Создаёт типизированную таблицу значений из массива.
//
// Параметры:
//  Массив		 - Массив - Исходный массив.
//  ИмяКолонки	 - Строка - Имя единственной колонки создавамой таблицы
// 
// Возвращаемое значение:
//  ТаблицаЗначений - Результирующая таблица
//
Функция ТаблицаЗначенийИзМассива(Массив, ИмяКолонки = "Значение") Экспорт

	Если ТипЗнч(Массив) <> Тип("Массив") Тогда
		ВызватьИсключение "Параметр Массив: Ожидается тип Массив";
	ИначеЕсли ТипЗнч(ИмяКолонки) <> Тип("Строка") Тогда
		ВызватьИсключение "Параметр ИменаКолонок: Ожидается тип Строка";
	КонецЕсли; 
	
	ТипыЗначений			 = Новый Массив;
	ПредыдущийТипЗначения	 = Неопределено;
	
	ТаблицаЗначений = Новый ТаблицаЗначений;
	
	Для каждого ЭлементМассива Из Массив Цикл
		
		ТаблицаЗначений.Добавить();
		
		ТипЗначения = ТипЗнч(ЭлементМассива);
		Если ТипЗначения <> ПредыдущийТипЗначения
			И ТипыЗначений.Найти(ТипЗначения) = Неопределено Тогда
			ТипыЗначений.Добавить(ТипЗначения);
		КонецЕсли; 
		ПредыдущийТипЗначения = ТипЗначения;
		
	КонецЦикла; 
	
	ТаблицаЗначений.Колонки.Добавить(ИмяКолонки, Новый ОписаниеТипов(ТипыЗначений));	
	ТаблицаЗначений.ЗагрузитьКолонку(Массив, 0);

	Возврат ТаблицаЗначений;
	
КонецФункции // ТаблицаЗначенийИзМассива()

// Формирует таблицу значений из списка с разделителями (CSV).
// Опирается на RFC 4180.
//
// Параметры:
//  ТекстCSV 		 - Строка - Исходный текст для преобразования.
//  Разделитель 	 - Строка - Разделитель значений.
//	ЕстьЗаголовки	 - Булево - Первая строка текста считается заголовком.
//								Если заголовки, указанные в CSV, отвечают правилам именования,
//								тогда колонкам таблицы будут присвоены соответствующие имена.
//								В противном случае, имена будут "Колонка1..КолонкаN".
//	ПривестиЗначения - Булево - Если Истина, значения значения в списке, не заключенные в кавычки,
//								будут приведены к соответствующему типу (Число, Дата, Булево).
//								Если Ложь, все значения будут строкового типа.
//
// Возвращаемое значение:
//   ТаблицаЗначений   - Полученная таблица.
//
Функция ТаблицаЗначенийИзCSV(ТекстCSV, Разделитель = ",", ЕстьЗаголовки = Истина, ПривестиЗначения = Ложь) Экспорт
	
	ТаблицаРезультат = Новый ТаблицаЗначений;

	НомерСтроки = 1;
	ВсегоСтрок = СтрЧислоСтрок(ТекстCSV);
	ТекущаяСтрока = "";
	ТекущаяСтрокаСобрана = Ложь;
	Кавычка = """";

	#Область ИзвлечениеСтрок
	ИзвлеченныеСтроки = Новый Массив; // Строки с учетом переносов в CSV. Каждый элемент - строка.
	Пока Истина Цикл

		ТекущаяСтрокаCSV = СтрПолучитьСтроку(ТекстCSV, НомерСтроки);
		ТекущаяСтрока = ТекущаяСтрока + ТекущаяСтрокаCSV;

		ТекущаяСтрокаСобрана = СтрЧислоВхождений(ТекущаяСтрока, Кавычка) % 2 = 0;
		Если ТекущаяСтрокаСобрана Тогда
			ИзвлеченныеСтроки.Добавить(ТекущаяСтрока);
			ТекущаяСтрока = "";
		КонецЕсли;

		Если НомерСтроки = ВсегоСтрок Тогда
			Прервать;
		КонецЕсли;
		НомерСтроки = НомерСтроки + 1;

	КонецЦикла;
	#КонецОбласти // ИзвлечениеСтрок

	#Область ПодготовкаПриведенияЗначений
	ЭкранированныеЯчейки = Новый Соответствие;	// {ИндексСтроки; Массив из Число: ИндексКолонки}
	АдресацияПриводимыхЗначений	 = Новый Соответствие;
	ПриведенныеЗначения	 = Новый Соответствие;	
	#КонецОбласти // ПодготовкаПриведенияЗначений

	#Область РазборСтрок
	РазобранныеСтроки = Новый Массив;
	Для ИндексСтроки = 0 По ИзвлеченныеСтроки.ВГраница() Цикл

		ТекущаяСтрока = ИзвлеченныеСтроки[ИндексСтроки];

		СоставСтроки = Новый Массив;
		Буфер = "";
		КавычкаОткрыта = Ложь;
		ДлинаСтроки = СтрДлина(ТекущаяСтрока);
		Для НомерСимвола = 1 По ДлинаСтроки Цикл
			ТекущийСимвол = Сред(ТекущаяСтрока, НомерСимвола, 1);
			ЭтоКонецСтроки = НомерСимвола = ДлинаСтроки;
			Если ТекущийСимвол = Разделитель И Не КавычкаОткрыта 
				Или ЭтоКонецСтроки Тогда
				Если ЭтоКонецСтроки Тогда
					Буфер = Буфер + ТекущийСимвол;
				КонецЕсли;
				СоставСтроки.Добавить(СокрЛП(Буфер));	// Убираем незначащие символы -- требование формата.
				Буфер = "";
				Продолжить;
			КонецЕсли;
			Буфер = Буфер + ТекущийСимвол;
		КонецЦикла;

		Если ПривестиЗначения Тогда
			ЭкранированныеЯчейки[ИндексСтроки] = Новый Массив;
			АдресацияПриводимыхЗначений[ИндексСтроки] = Новый Соответствие;
		КонецЕсли;

		Для ИндексКолонки = 0 По СоставСтроки.ВГраница() Цикл
			Представление = СоставСтроки[ИндексКолонки];

			// Убираем обрамляющие кавычки:
			ЗначениеВКавычках = СтрНачинаетсяС(Представление, Кавычка);
			Если ЗначениеВКавычках Тогда
				Представление = Сред(Представление, 1, СтрДлина(Представление) - 2);
			КонецЕсли;

			// Разворачиваем экранированные кавычки:
			Представление = СтрЗаменить(Представление, Кавычка + Кавычка, Кавычка);

			Если ПривестиЗначения И (ИндексСтроки > 0 = ЕстьЗаголовки) Тогда
				Если ЗначениеВКавычках Тогда
					ЭкранированныеЯчейки[ИндексСтроки].Добавить(ИндексКолонки);
				Иначе
					АдресацияПриводимыхЗначений[ИндексСтроки][ИндексКолонки] = Представление;
					ПриведенныеЗначения.Вставить(Представление);
				КонецЕсли;
			КонецЕсли;

			СоставСтроки[ИндексКолонки] = Представление;
			
		КонецЦикла;

		РазобранныеСтроки.Добавить(СоставСтроки);
		
	КонецЦикла;
	Если Не ЗначениеЗаполнено(РазобранныеСтроки) Тогда
		ВызватьИсключение "Исходная строка не содержит данных";
	КонецЕсли;
	#КонецОбласти // РазборСтрок

	#Область КолонкиТаблицы
	КоличествоКолонок = РазобранныеСтроки[0].Количество();
	Для каждого СоставСтроки Из РазобранныеСтроки Цикл
		Если СоставСтроки.Количество() <> КоличествоКолонок Тогда
			ВызватьИсключение "Различное количество колонок в исходных данных";
		КонецЕсли;
	КонецЦикла;
	ШаблонИмениКолонки = "Колонка%1";
	Для НомерКолонки = 1 По КоличествоКолонок Цикл
		ИмяКолонки = СтрШаблон(ШаблонИмениКолонки, XMLСтрока(НомерКолонки));
		ТаблицаРезультат.Колонки.Добавить(ИмяКолонки);
	КонецЦикла;
	Если ЕстьЗаголовки Тогда
		СоставЗаголовка = РазобранныеСтроки[0];
		Для ИндексКолонки = 0 По КоличествоКолонок - 1 Цикл
			ТаблицаРезультат.Колонки[ИндексКолонки].Заголовок = СоставЗаголовка[ИндексКолонки];
		КонецЦикла;
		// Имена колонок:
		Буквы = "";
		Буквы = Буквы + "абвгдеёжзийклмнопрстуфхцчшщъыьэюяАБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ";
		Буквы = Буквы + "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
		Цифры = "0123456789";
		АлфавитИмен = Буквы + Цифры + "_";
		АлфавитПервогоСимвола = Буквы + "_";
		// Проверяем заголовки колонок на валидность.
		// Если они соответствуют правилам именования, устанавливаем имена колонок.
		УстановитьИменаКолонокCSV = Истина;
		Для каждого Колонка Из ТаблицаРезультат.Колонки Цикл
			Заголовок = Колонка.Заголовок;
			Если ПустаяСтрока(Заголовок) Тогда
				УстановитьИменаКолонокCSV = Ложь;
				Прервать;
			КонецЕсли;
			ПервыйСимвол = Лев(Заголовок, 1);
			Если Не СтрНайти(АлфавитПервогоСимвола, ПервыйСимвол) Тогда
				УстановитьИменаКолонокCSV = Ложь;
				Прервать;
			КонецЕсли;
			Для НомерСимвола = 2 По СтрДлина(Заголовок) Цикл
				ТекущийСимвол = Сред(Заголовок, НомерСимвола, 1);
				Если Не СтрНайти(АлфавитИмен, ТекущийСимвол) Тогда
					УстановитьИменаКолонокCSV = Ложь;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
		Если УстановитьИменаКолонокCSV Тогда
			Для каждого Колонка Из ТаблицаРезультат.Колонки Цикл
				Колонка.Имя = Колонка.Заголовок;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	#КонецОбласти // КолонкиТаблицы

	#Область ПриведениеЗначений
	СтартовыйИндекс = ?(ЕстьЗаголовки, 1, 0);
	Если ПривестиЗначения Тогда

		Цифры			 = "0123456789";
		АлфавитЧисла	 = Цифры + ".," + Символы.НПП;

		АлфавитДаты		 = Цифры + " :.";
		КороткаяДата	 = "01.01.0001 0:00:00";
		ДлиннаяДата		 = "31.12.3999 23:59:59";
		МинДлинаДаты	 = СтрДлина(КороткаяДата);
		МаксДлинаДаты	 = СтрДлина(ДлиннаяДата);
		ЧислоТочекДаты			 = 2;
		ЧислоДвоеточийДаты		 = 2;
		ЧислоПробеловДаты		 = 1;
		ПозицияПервойТочкиДаты	 = СтрНайти(ДлиннаяДата, ".",,, 1);
		ПозицияВторойТочкиДаты	 = СтрНайти(ДлиннаяДата, ".",,, 2);
		ПозицияПервогоДвоеточия	 = СтрНайти(ДлиннаяДата, ":",,, 1);
		ПозицияВторогоДвоеточия	 = СтрНайти(ДлиннаяДата, ":",,, 2);
		ПозицияПробелаДаты		 = СтрНайти(ДлиннаяДата, " ");
		ДлинаЧастиДаты			 = ПозицияПробелаДаты - 1;
		МинДлинаЧастиВремени	 = МинДлинаДаты - ПозицияПробелаДаты;
		
		ВариантыБулево = Новый Соответствие;
		ВариантыБулево[Врег("Истина")]	 = Истина;
		ВариантыБулево[Врег("Да")]		 = Истина;
		ВариантыБулево[Врег("True")]	 = Истина;
		ВариантыБулево[Врег("Yes")]		 = Истина;
		ВариантыБулево[Врег("Ложь")]	 = Ложь;
		ВариантыБулево[Врег("Нет")]		 = Ложь;
		ВариантыБулево[Врег("False")]	 = Ложь;
		ВариантыБулево[Врег("No")]		 = Ложь;
		МаксДлинаБулево	 = СтрДлина("Истина");

		// Преобразование значений:
		Для каждого ПриводимоеЗначение Из ПриведенныеЗначения Цикл

			Представление = ПриводимоеЗначение.Ключ;

			#Область ЗначениеЭтоЧисло
			ЗначениеЭтоЧисло = Не ПустаяСтрока(Представление)
				И (СтрЧислоВхождений(Представление, ",") 
					+ СтрЧислоВхождений(Представление, ".")) <= 1;
			Если ЗначениеЭтоЧисло Тогда
				Для НомерСимвола = 1 По СтрДлина(Представление) Цикл
					Если АлфавитЧисла.Найти(Сред(Представление, НомерСимвола, 1)) = Неопределено Тогда
						ЗначениеЭтоЧисло = Ложь;
						Прервать;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
			Если ЗначениеЭтоЧисло Тогда
				Попытка
					Значение = Число(Представление);
					ПриведенныеЗначения[Представление] = Значение;
					Продолжить;
				Исключение
					ЗначениеЭтоЧисло = Ложь;
				КонецПопытки;
			КонецЕсли;
			#КонецОбласти // ЗначениеЭтоЧисло

			ДлинаПредставления = СтрДлина(Представление);

			#Область ЗначениеЭтоДата
			ЗначениеЭтоДата = МинДлинаДаты <= ДлинаПредставления И ДлинаПредставления <= МаксДлинаДаты
				И СтрЧислоВхождений(Представление, ".") = ЧислоТочекДаты 
				И СтрЧислоВхождений(Представление, ":") = ЧислоДвоеточийДаты
				И СтрЧислоВхождений(Представление, " ") = ЧислоПробеловДаты
				И СтрНайти(Представление, ".",,, 1) = ПозицияПервойТочкиДаты
				И СтрНайти(Представление, ".",,, 2) = ПозицияВторойТочкиДаты
				И СтрНайти(Представление, " ") = ПозицияПробелаДаты
				И ((СтрНайти(Представление, ":",,, 1) = (ПозицияПервогоДвоеточия - 1)
						И СтрНайти(Представление, ":",,, 2) = (ПозицияВторогоДвоеточия - 1))
					Или (СтрНайти(Представление, ":",,, 1) = ПозицияПервогоДвоеточия
						И СтрНайти(Представление, ":",,, 2) = ПозицияВторогоДвоеточия));			
			Если ЗначениеЭтоДата Тогда
				Для НомерСимвола = 1 По МаксДлинаДаты Цикл
					Если СтрНайти(АлфавитДаты, Сред(Представление, НомерСимвола, 1)) = Неопределено Тогда
						ЗначениеЭтоДата = Ложь;
						Прервать;						
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
			Если ЗначениеЭтоДата Тогда
				Попытка
					Значение = Дата(Представление);
					ПриведенныеЗначения[Представление] = Значение;
					Продолжить;
				Исключение
					ЗначениеЭтоДата = Ложь;
				КонецПопытки;
			КонецЕсли;
			#КонецОбласти // ЗначениеЭтоДата

			#Область ЗначениеЭтоБулево
			ЗначениеЭтоБулево = Не ПустаяСтрока(Представление)
				И ВариантыБулево[Врег(Представление)] <> Неопределено;
			Если ЗначениеЭтоБулево Тогда
				Значение = ВариантыБулево[Врег(Представление)];
				ПриведенныеЗначения[Представление] = Значение;
				Продолжить;
			КонецЕсли;
			#КонецОбласти // ЗначениеЭтоБулево

			// Строка
			ПриведенныеЗначения[Представление] = Представление;

		КонецЦикла;

		// Перенос в таблицу:
		Для каждого АдресацияСтрок Из АдресацияПриводимыхЗначений Цикл
			ИндексСтроки = АдресацияСтрок.Ключ;
			Для каждого АдресацияКолонок Из АдресацияСтрок.Значение Цикл
				ИндексКолонки = АдресацияКолонок.Ключ;
				РазобранныеСтроки[ИндексСтроки][ИндексКолонки] = ПриведенныеЗначения[АдресацияКолонок.Значение];
			КонецЦикла;
		КонецЦикла;
		
	КонецЕсли;
	#КонецОбласти // ПриведениеЗначений

	#Область ЗаполнениеТаблицы
	СтартовыйИндекс = ?(ЕстьЗаголовки, 1, 0);
	Для ИндексСтроки = СтартовыйИндекс По РазобранныеСтроки.ВГраница() Цикл
		СтрокаТаблицы = ТаблицаРезультат.Добавить();
		Для ИндексКолонки = 0 По КоличествоКолонок - 1 Цикл
			СтрокаТаблицы[ИндексКолонки] = РазобранныеСтроки[ИндексСтроки][ИндексКолонки];
		КонецЦикла;
	КонецЦикла;
	#КонецОбласти // ЗаполнениеТаблицы

	Возврат ТаблицаРезультат; 

КонецФункции // ТаблицаЗначенийИзCSV()

// Создаёт типизированную таблицу значений из списка значений.
//
// Параметры:
//  СписокЗначений	 - СписокЗначений - Исходный список значений.
// 
// Возвращаемое значение:
//  ТаблицаЗначений - Результирующая таблица. Колонки:
//		* Значение		 - Произвольный
//		* Представление	 - Строка
//		* Пометка		 - Булево
//
Функция ТаблицаЗначенийИзСпискаЗначений(СписокЗначений) Экспорт

	Если ТипЗнч(СписокЗначений) <> Тип("СписокЗначений") Тогда
		ВызватьИсключение "Параметр СписокЗначений: Ожидается тип СписокЗначений";
	КонецЕсли; 
	
	Значения		 = Новый Массив;
	Представления	 = Новый Массив;
	Пометки			 = Новый Массив;
	
	ТипыЗначений			 = Новый Массив;
	ПредыдущийТипЗначения	 = Неопределено;
	
	ТаблицаЗначений = Новый ТаблицаЗначений;
	
	Для каждого ЭлементСписка Из СписокЗначений Цикл
		
		Значения.Добавить(ЭлементСписка.Значение);
		Представления.Добавить(ЭлементСписка.Представление);
		Пометки.Добавить(ЭлементСписка.Пометка);
		
		ТаблицаЗначений.Добавить();
		
		ТипЗначения = ТипЗнч(ЭлементСписка.Значение);
		Если ТипЗначения <> ПредыдущийТипЗначения
			И ТипыЗначений.Найти(ТипЗначения) = Неопределено Тогда
			ТипыЗначений.Добавить(ТипЗначения);
		КонецЕсли; 
		ПредыдущийТипЗначения = ТипЗначения;
		
	КонецЦикла; 
	
	ТаблицаЗначений.Колонки.Добавить("Значение",		 Новый ОписаниеТипов(ТипыЗначений));	
	ТаблицаЗначений.Колонки.Добавить("Представление",	 Новый ОписаниеТипов("Строка"));	
	ТаблицаЗначений.Колонки.Добавить("Пометка",			 Новый ОписаниеТипов("Булево"));	
	ТаблицаЗначений.ЗагрузитьКолонку(Значения,		 0);
	ТаблицаЗначений.ЗагрузитьКолонку(Представления,	 1);
	ТаблицаЗначений.ЗагрузитьКолонку(Пометки,		 2);

	Возврат ТаблицаЗначений;
	
КонецФункции // ТаблицаЗначенийИзМассива()

// Формирует массив структур с именами колонок таблицы.
//
// Параметры:
//	ТаблицаЗначений	 - ТаблицаЗначений	 - Исходная таблица.
//	ИменаКолонок	 - Строка			 - Имена колонок таблицы, и ключей выгружаемых структур.
//
// Возвращаемое значение:
//	Массив из Структура
//
Функция МассивСтруктурИзТаблицыЗначений(ТаблицаЗначений, Знач ИменаКолонок = Неопределено) Экспорт
	
	Если ИменаКолонок = Неопределено Тогда
		ИменаКолонок = Новый Массив;
		Для каждого Колонка Из ТаблицаЗначений.Колонки Цикл
			ИменаКолонок.Добавить(Колонка.Имя);
		КонецЦикла;
		ИменаКолонок = СтрСоединить(ИменаКолонок, ", ");
	ИначеЕсли ТипЗнч(ИменаКолонок) = Тип("Строка") Тогда
		Для каждого ИмяКолонки Из ИменаКолонок Цикл
			Если ТаблицаЗначений.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
				ВызватьИсключение СтрШаблон("Таблица не содержит колонки с именем %1", ИмяКолонки);
			КонецЕсли;
		КонецЦикла;
	Иначе
		ВызватьИсключение "Параметр ИменаКолонок: Ожидается Строка";
	КонецЕсли;

	Если Не ЗначениеЗаполнено(ТаблицаЗначений) 
		Или ПустаяСтрока(ИменаКолонок) Тогда
		Возврат Новый Массив;
	КонецЕсли;

	МассивСтруктур = Новый Массив;
	Для каждого СтрокаТаблицы Из ТаблицаЗначений Цикл
		Структура = Новый Структура(ИменаКолонок);
		ЗаполнитьЗначенияСвойств(Структура, СтрокаТаблицы);
		МассивСтруктур.Добавить(Структура);
	КонецЦикла;

	Возврат МассивСтруктур; 

КонецФункции // МассивСтруктурИзТаблицыЗначений()

// Формирует структуру из дерева значений.
// Отличия структуры от дерева:
//	Корневой элемент - это тоже Структура.
//	У элементов первого уровня будет заполнен Родитель - элементом первого уровня.
//	Владелец всех элементов будет указывать на корневой элемент,
//		даже если структура построена от промежуточного узла дерева.
//
// Параметры:
//	НачальныйУзел	 - ДеревоЗначений		 - Исходное дерево значений.
//					 - СтрокаДереваЗначений	 - Исходный узел дерева значений.
//	Колонки			 - Строка - Имена выгружаемых колонок дерева. Если не указан, будут выгружены все колонки.
//	КлючСтроки		 - Строка - Обязательный. Элемент структуры, содержащий коллекцию вложенных структур.
//	КлючРодитель	 - Строка - Элемент структуры, содержащий структуру-родителя.
//	КлючВладелец	 - Строка - Элемент структуры, содержащий корневую структуру.
//
// Возвращаемое значение:
//	Структура - Полученная структура. Каждый элемент коллекции подчиненных строк будет иметь ключ СтрокаN, 
//				где N - это индекс подчиненной строки дерева.
//				Если передано ДеревоЗначений, то корневой элемент будет содержать только элемент <КлючСтроки>;
//
Функция СтруктураИзДереваЗначений(
	НачальныйУзел,
	Колонки = Неопределено, 
	КлючСтроки = "Строки", 
	КлючРодитель = "Родитель", 
	КлючВладелец = "Владелец") Экспорт

	Если ПустаяСтрока(КлючСтроки) Тогда
		ВызватьИсключение "Параметр Строки: Ожидается значение";
	КонецЕсли;

	Если ТипЗнч(НачальныйУзел) = Тип("ДеревоЗначений") Тогда
		Корень = НачальныйУзел;
	ИначеЕсли ТипЗнч(НачальныйУзел) = Тип("СтрокаДереваЗначений") Тогда
		Корень = НачальныйУзел.Владелец();
	Иначе
		ВызватьИсключение "Параметр НачальныйУзел: Ожидается тип ДеревоЗначений, СтрокаДереваЗначений";
	КонецЕсли;

	ЕстьКлючРодитель = Не ПустаяСтрока(КлючРодитель);
	ЕстьКлючВладелец = Не ПустаяСтрока(КлючВладелец);

	#Область ПоляСтруктуры

	ПоляСтруктуры = Новый Массив;
	Если ЗначениеЗаполнено(Колонки) Тогда
		ИменаКолонок = СтрРазделить(Колонки, ", ", Ложь);
		Для каждого ИмяКолонки Из ИменаКолонок Цикл
			Если Корень.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
				ВызватьИсключение СтрШаблон("Параметр Колонки: Нет колонки с именем «%1»", ИмяКолонки);
			КонецЕсли;
			ПоляСтруктуры.Добавить(ИмяКолонки);
		КонецЦикла;
	Иначе
		Для каждого Колонка Из Корень.Колонки Цикл
			ПоляСтруктуры.Добавить(Колонка.Имя);
		КонецЦикла;
	КонецЕсли;
	
	СлужебныеКолонки = Новый Массив;
	СлужебныеКолонки.Добавить(КлючСтроки);
	Если ЕстьКлючРодитель Тогда
		СлужебныеКолонки.Добавить(КлючРодитель);
	КонецЕсли;
	Если ЕстьКлючВладелец Тогда
		СлужебныеКолонки.Добавить(КлючВладелец);
	КонецЕсли;
	Для Индекс = 0 По СлужебныеКолонки.ВГраница() Цикл
		ИмяКолонки = СлужебныеКолонки[Индекс];
		Если СлужебныеКолонки.Найти(ИмяКолонки) < Индекс Тогда
			ВызватьИсключение СтрШаблон("Дублируется служебная колонка с именем «%1»", ИмяКолонки);
		КонецЕсли;		
		Если ПоляСтруктуры.Найти(ИмяКолонки) <> Неопределено  Тогда
			ВызватьИсключение СтрШаблон("Колонка с именем «%1» уже выбрана для выгрузки из дерева!", ИмяКолонки);
		КонецЕсли;
	КонецЦикла;

	ПоляСтруктуры = СтрСоединить(ПоляСтруктуры, ", ");

	#КонецОбласти // ПоляСтруктуры

	СоответствиеУзлов = Новый Соответствие;	// {СтрокаДереваЗначений; СтруктураУзла: Структура}
	СтруктураДерева = Новый Структура;

	Узлы = Новый Массив;
	Узлы.Добавить(НачальныйУзел);

	НачальныйУзелЭтоДерево = (ТипЗнч(НачальныйУзел) = Тип("ДеревоЗначений"));
	Если НачальныйУзелЭтоДерево Тогда // Чтобы не проверять в цикле.
		СтруктураУзла = Новый Структура(КлючСтроки, Новый Структура);
		СоответствиеУзлов[НачальныйУзел]			 = СтруктураУзла;
		Для каждого Ветвь Из НачальныйУзел.Строки Цикл
			Узлы.Добавить(Ветвь);
		КонецЦикла;
	КонецЕсли;

	Индекс = ?(НачальныйУзелЭтоДерево, 1, 0); // Узел дерева уже обработан
	Пока Индекс <= Узлы.ВГраница() Цикл

		Узел = Узлы[Индекс];
		
		СтруктураУзла = Новый Структура(ПоляСтруктуры);
		ЗаполнитьЗначенияСвойств(СтруктураУзла, Узел);
		СтруктураУзла.Вставить("Строки", Новый Структура);
		СоответствиеУзлов[Узел] = СтруктураУзла;

		Для каждого Ветвь Из Узел.Строки Цикл
			Узлы.Добавить(Ветвь);
		КонецЦикла;

		УзелРодитель = Узел.Родитель;
		Если УзелРодитель = Неопределено И НачальныйУзелЭтоДерево Тогда
			УзелРодитель = НачальныйУзел;
		КонецЕсли;
		СтруктураРодитель = СоответствиеУзлов[УзелРодитель];
		Если ЕстьКлючРодитель Тогда
			СтруктураУзла.Вставить(КлючРодитель, СтруктураРодитель);
		КонецЕсли;
		Если СтруктураРодитель <> Неопределено Тогда
			ИндексУзла = УзелРодитель.Строки.Индекс(Узел);
			КлючВетви = СтрШаблон("Строка%1", XMLСтрока(ИндексУзла));
			СтруктураРодитель.Строки.Вставить(КлючВетви, СтруктураУзла);
		КонецЕсли;
		Индекс = Индекс + 1;

	КонецЦикла;

	Если ЕстьКлючВладелец Тогда
		СтруктураВладелец = СоответствиеУзлов[НачальныйУзел];
		Для Индекс = 1 По Узлы.ВГраница() Цикл
			СоответствиеУзлов[Узлы[Индекс]].Вставить(КлючВладелец, СтруктураВладелец);
		КонецЦикла;
	КонецЕсли;

	СтруктураДерева = СоответствиеУзлов[НачальныйУзел];

	Возврат СтруктураДерева;
	
КонецФункции // СтруктураИзДереваЗначений()

#Область ПримитивныеТипы

// Получает булево из строки.
//
// Параметры:
//	Строка			 - Строка		 - Исходная строка
//	Локаль			 - Строка		 - Перечисление строк локалей через запятую (см. описание функции Формат()).
//										Используется, если ожидаются строки на других языках,
//										а также упрощенное представление Булево (Дат/Нет).
//	СловарьПовтИсп	 - Соответствие	 - Служебные значения для повторного использования.
//
// Возвращаемое значение:
//	- Булево		 - Полученное значение
//	- Неопределено	 - Если значение не удалось получить
//
Функция БулевоИзСтроки(Строка, Локаль = "ru, en", СловарьПовтИсп = Неопределено) Экспорт
	
	Если СловарьПовтИсп = Неопределено Тогда
		СловарьПовтИсп = Новый Соответствие;
		СловарьПовтИсп[ВРег(Строка(Истина))] = Истина;
		СловарьПовтИсп[ВРег(Строка(Ложь))]	 = Ложь;
		СловарьПовтИсп[ВРег("Истина")]	 = Истина;
		СловарьПовтИсп[Врег("Ложь")]	 = Ложь;
		СловарьПовтИсп[Врег("True")]	 = Истина;
		СловарьПовтИсп[Врег("False")]	 = Ложь;
		СловарьПовтИсп[Врег("")]		 = Ложь;
		Для каждого ТекущаяЛокаль Из СтрРазделить(Локаль, ";, ", Ложь) Цикл
			ФорматнаяСтрока = СтрШаблон("L=%1", ТекущаяЛокаль);
			СловарьПовтИсп[Врег(Формат(Истина, ФорматнаяСтрока))] = Истина;
			СловарьПовтИсп[Врег(Формат(Ложь, ФорматнаяСтрока))] = Ложь;
		КонецЦикла;
	КонецЕсли;

	Возврат СловарьПовтИсп[ВРег(Строка)];

КонецФункции // БулевоИзСтроки()

// Получает дату из строки.
// Поддерживаемые форматы:
//	* дд.ММ.гггг чч:мм:сс	// Каноничный формат
//	* дд.ММ.гггг			// Только дата
//	* чч:мм:сс				// Только время
//	* чч:мм					// Время, без секунд
//	* гггг-ММ-дд			// Дата, сначала год
//	* дд.ММ.ггггTчч:мм:сс	// Формат даты по ISO 8601
//	* (сочетания различных вариаций даты и времени)
// Поддерживаются различные разделители дат: точка, косая черта, дефис.
//
// Параметры:
//	Строка - Строка - Исходная строка.	
//
Функция ДатаИзСтроки(Строка, ТекстИсключения = "") Экспорт

	ДатаСтрокой = СокрЛП(Строка);

	ПустаяДата = '00010101';
	Если ПустаяСтрока(ДатаСтрокой) Тогда
		Возврат ПустаяДата; 
	КонецЕсли;

	РазделителиЧастейДаты = "./-";
	РазделительДатыВремениISO = "T";
	РазделителиДатыВремени = Символы.НПП + " " + РазделительДатыВремениISO;

	Цифры			 = "0123456789";
	АлфавитДаты = Цифры + РазделителиЧастейДаты;
	АлфавитВремени = Цифры + ":";
	АлфавитДатыВремени = АлфавитДаты + РазделителиДатыВремени + АлфавитВремени;

	ЕстьДата = Ложь;
	ЕстьВремя = Ложь;
	Для НомерСимвола = 1 По СтрДлина(ДатаСтрокой) Цикл
		ТекущийСимвол = Сред(ДатаСтрокой, НомерСимвола, 1);
		Если Не СтрНайти(АлфавитДатыВремени, ТекущийСимвол) Тогда
			ТекстИсключения = "Неожиданный символ";
			Возврат Неопределено;
		КонецЕсли;
		ЕстьДата = ЕстьДата Или СтрНайти(РазделителиЧастейДаты, ТекущийСимвол);
		ЕстьВремя = ЕстьВремя Или ТекущийСимвол = ":";
	КонецЦикла;

	Если Не ЕстьДата И Не ЕстьВремя Тогда
		ТекстИсключения = "Строка не содержит ни даты, ни времени";
		Возврат Неопределено; 
	КонецЕсли;

	КоличествоРазличныхРазделителейДатыВремени = 0;
	Для НомерСимвола = 1 По СтрДлина(РазделителиДатыВремени) Цикл
		Разделитель = Сред(РазделителиДатыВремени, НомерСимвола, 1);
		КоличествоРазделителей = СтрЧислоВхождений(ДатаСтрокой, Разделитель);
		Если КоличествоРазделителей > 1 Тогда
			ТекстИсключения = "Строка содержит несколько разделителей даты и времени";
			Возврат Неопределено;
		ИначеЕсли КоличествоРазделителей = 1 Тогда
			КоличествоРазличныхРазделителейДатыВремени = КоличествоРазличныхРазделителейДатыВремени + 1;
		Иначе
			Продолжить;
		КонецЕсли;
	КонецЦикла;
	Если КоличествоРазличныхРазделителейДатыВремени > 1
		Или (ЕстьДата И ЕстьВремя И КоличествоРазличныхРазделителейДатыВремени = 0) Тогда
		ТекстИсключения = "Строка содержит несколько различных разделителей даты и времени";
		Возврат Неопределено;
	КонецЕсли;

	ДатаВремяСтроками = СтрРазделить(ДатаСтрокой, РазделителиДатыВремени, Ложь);
	СоставДаты = Новый Структура("Год, Месяц, День, Час, Минута, Секунда", 1, 1, 1, 0, 0, 0);

	Если ЕстьДата Тогда

		ЧастьДатыСтрокой = ДатаВремяСтроками[0];

		КоличествоРазделителей = Новый Соответствие;
		Для НомерСимвола = 1 По СтрДлина(ЧастьДатыСтрокой) Цикл
			ТекущийСимвол = Сред(ЧастьДатыСтрокой, НомерСимвола, 1);
			Если Не СтрНайти(АлфавитДаты, ТекущийСимвол) Тогда
				ТекстИсключения = "Неверный формат даты";
				Возврат Неопределено;
			КонецЕсли;
		КонецЦикла;

		КоличествоРазличныхРазделителейДаты = 0;
		Для НомерСимвола = 1 По СтрДлина(РазделителиЧастейДаты) Цикл
			Разделитель = Сред(РазделителиЧастейДаты, НомерСимвола, 1);
			КоличествоРазделителей = СтрЧислоВхождений(ЧастьДатыСтрокой, Разделитель);
			Если КоличествоРазделителей = 1 Или КоличествоРазделителей > 2 Тогда
				ТекстИсключения = "Неверный формат разделителей даты";
				Возврат Неопределено; 
			ИначеЕсли КоличествоРазделителей = 2 Тогда
				КоличествоРазличныхРазделителейДаты = КоличествоРазличныхРазделителейДаты + 1;
			КонецЕсли;
		КонецЦикла;
		Если КоличествоРазличныхРазделителейДаты = 0
			Или КоличествоРазличныхРазделителейДаты > 1 Тогда
			ТекстИсключения = "Строка содержит несколько различных разделителей даты";
			Возврат Неопределено;
		КонецЕсли;
		СоставДатыСтроками = СтрРазделить(ЧастьДатыСтрокой, РазделителиЧастейДаты, Ложь);

		СначалаГод = (СтрДлина(СоставДатыСтроками[0]) = 4);

		ГодСтрокой = СоставДатыСтроками[?(СначалаГод, 0, 2)];
		Если СтрДлина(ГодСтрокой) <> 4 Тогда
			ТекстИсключения = "Год не указан четырехзначным числом";
			Возврат Неопределено;
		КонецЕсли;
		ГодЧислом = Число(ГодСтрокой);

		МесяцСтрокой = СоставДатыСтроками[1];
		Если СтрДлина(МесяцСтрокой) <> 2 Тогда
			ТекстИсключения = "Месяц не указан двузначным числом";
			Возврат Неопределено;
		КонецЕсли;
		МесяцЧислом = Число(МесяцСтрокой);
		Если МесяцЧислом < 1 Или 12 < МесяцЧислом Тогда
			ТекстИсключения = "Месяц указан неправильно";
			Возврат Неопределено;
		КонецЕсли;

		ДеньСтрокой = СоставДатыСтроками[?(СначалаГод, 2, 0)];
		Если СтрДлина(ДеньСтрокой) > 2 Тогда
			ТекстИсключения = "День указан неправильно";
			Возврат Неопределено;
		КонецЕсли;
		ДеньЧислом = Число(ДеньСтрокой);
		МесяцыГдеДней31 = "01 03 05 07 08 10 12";
		Если ДеньЧислом < 1 Или 31 < ДеньЧислом Тогда
			ТекстИсключения = "День указан неправильно";
			Возврат Неопределено;
		ИначеЕсли ДеньЧислом = 31 И Не СтрНайти(МесяцыГдеДней31, МесяцСтрокой) Тогда
			ТекстИсключения = "День не соответствует месяцу";
			Возврат Неопределено;
		ИначеЕсли МесяцЧислом = 2 Тогда
			ГодВисокосный = (ГодЧислом % 4 = 0) И Не (ГодЧислом % 100 = 0 И ГодЧислом % 400 > 0);
			Если ДеньЧислом > 29 Тогда
				ТекстИсключения = "День не соответствует месяцу";
				Возврат Неопределено;
			КонецЕсли;
			Если ДеньЧислом = 29 И Не ГодВисокосный Тогда
				ТекстИсключения = "Указано 29 февраля, но год не високосный";
				Возврат Неопределено;
			КонецЕсли;
		КонецЕсли;
		ДеньЧислом = Число(ДеньСтрокой);

		СоставДаты.Год	 = ГодЧислом;
		СоставДаты.Месяц = МесяцЧислом;
		СоставДаты.День	 = ДеньЧислом;

	КонецЕсли;

	Если ЕстьВремя Тогда

		ВремяСтрокой = ДатаВремяСтроками[?(ЕстьДата, 1, 0)];

		Для НомерСимвола = 1 По СтрДлина(ВремяСтрокой) Цикл
			ТекущийСимвол = Сред(ВремяСтрокой, НомерСимвола, 1);
			Если Не СтрНайти(АлфавитВремени, ТекущийСимвол) Тогда
				ТекстИсключения = "Время указано в неверном формате";
				Возврат Неопределено;
			КонецЕсли;
		КонецЦикла;

		ЧастиВремени = СтрРазделить(ВремяСтрокой, ":");
		КоличествоЧастейВремени = ЧастиВремени.Количество();
		Если КоличествоЧастейВремени < 2 Или 3 < КоличествоЧастейВремени Тогда
			ТекстИсключения = "Время указано в неверном формате";
			Возврат Неопределено;
		КонецЕсли;

		ЧасыСтрокой = ЧастиВремени[0];
		ЧасыЧислом = Число(ЧасыСтрокой);
		Если ЧасыЧислом > 23 Тогда
			ТекстИсключения = "Часы указаны неверно";
			Возврат Неопределено;
		КонецЕсли;

		МинутыСтрокой = ЧастиВремени[1];
		МинутыЧислом = Число(МинутыСтрокой);
		Если МинутыЧислом > 59  Тогда
			ТекстИсключения = "Минуты указаны неверно";
			Возврат Неопределено;
		КонецЕсли;


		ЕстьСекунды = (КоличествоЧастейВремени = 3);
		Если ЕстьСекунды Тогда
			СекундыЧислом = Число(ЧастиВремени[2]);
			Если СекундыЧислом > 59 Тогда
				ТекстИсключения = "Секунды указаны неверно";
				Возврат Неопределено;
			КонецЕсли;
		Иначе
			СекундыЧислом = 0;
		КонецЕсли;

		СоставДаты.Час = ЧасыЧислом;
		СоставДаты.Минута = МинутыЧислом;
		СоставДаты.Секунда = СекундыЧислом;

	КонецЕсли;
	
	Возврат Дата(
			СоставДаты.Год, СоставДаты.Месяц, СоставДаты.День,
			СоставДаты.Час, СоставДаты.Минута, СоставДаты.Секунда);

КонецФункции // ДатаИзСтроки()

// Получает число из строки.
//
// Параметры:
//	Строка - Строка - Исходная строка. Число в десятичной системе.
//
// Возвращаемое значение:
//	- Число			 - Полученное число.
//	- Неопределено	 - Если число получить не удалось.
//
Функция ЧислоИзСтроки(Строка) Экспорт

	Если ПустаяСтрока(Строка) Тогда
		Возврат 0;
	КонецЕсли;

	Цифры		 = "0123456789";
	АлфавитЧисла = Цифры + ".," + Символы.НПП;

	Если (СтрЧислоВхождений(Строка, ",") + СтрЧислоВхождений(Строка, ".")) > 1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Для НомерСимвола = 1 По СтрДлина(Строка) Цикл
		Если Не СтрНайти(АлфавитЧисла, Сред(Строка, НомерСимвола, 1)) Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЦикла;

	ЧислоСтрокой = Строка;
	ЧислоСтрокой = СтрЗаменить(ЧислоСтрокой, ",", ".");
	ЧислоСтрокой = СтрЗаменить(ЧислоСтрокой, Символы.НПП, "");

	Возврат Число(ЧислоСтрокой);
	
КонецФункции // ЧислоИзСтроки()

#КонецОбласти // ПримитивныеТипы