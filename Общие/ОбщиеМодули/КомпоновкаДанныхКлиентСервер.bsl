// Формирует отбор в формате языка запросов по отбору СКД
//
// Параметры:
//  Узел				 - ОтборКомпоновкиДанных, ГруппаЭлементовОтбораКомпоновкиДанных, ЭлементОтбораКомпоновкиДанных	 - Текущий узел обхода.
//  КомпоновщикНастроек	 - КомпоновщикНастроекКомпоновкиДанных															 - Компоновщик текущей схемы
//  ПараметрыЗапроса	 - Структура																					 - Содержит параметры, которые необходимо передать в запрос
//  ПрефиксПоляДанных	 - Строка																						 - Префикс, который будет использоваться в тексте запроса для обозначения поля данных
// 
// Возвращаемое значение:
//   - Строка
//
Функция ПолучитьТекстЗапросаОтбораКомпоновкиДанных(Узел, КомпоновщикНастроек, ПараметрыЗапроса, ПрефиксПоляДанных = "#") Экспорт
	
	ТекстОтбора = "";
	
	Если (ТипЗнч(Узел) = Тип("ЭлементОтбораКомпоновкиДанных") ИЛИ ТипЗнч(Узел) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных"))
		И НЕ Узел.Использование Тогда
		Возврат ТекстОтбора;
	КонецЕсли; 	
	
	Если ТипЗнч(Узел) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		
		ТекстОтбора = ПолучитьТекстЗапросаЭлементаОтбораКомпоновкиДанных(Узел, КомпоновщикНастроек, ПараметрыЗапроса, ПрефиксПоляДанных);
		
	ИначеЕсли ТипЗнч(Узел) = Тип("ОтборКомпоновкиДанных") ИЛИ ТипЗнч(Узел) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
		
		ЛогическийПрефикс	= ""; 
		ЛогическаяОперация	= "И";
		Если ТипЗнч(Узел) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
			Если  Узел.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли Тогда
				ЛогическаяОперация = "ИЛИ";
			ИначеЕсли Узел.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе Тогда	
				ЛогическийПрефикс	= "НЕ";
				ЛогическаяОперация	= "И";
			Иначе 	
				ЛогическаяОперация = "И";
			КонецЕсли; 
		КонецЕсли; 
		
		ЭтоСоставнойОператор = Узел.Элементы.Количество() > 1;
		Для каждого Элемент Из Узел.Элементы Цикл 
			ТекстПодчиненногоОтбора = ПолучитьТекстЗапросаОтбораКомпоновкиДанных(Элемент, КомпоновщикНастроек, ПараметрыЗапроса, ПрефиксПоляДанных);
			Если ЗначениеЗаполнено(ТекстПодчиненногоОтбора) Тогда
				ТекстОтбора = ТекстОтбора 
				+ ?(ЗначениеЗаполнено(ТекстОтбора), Символы.ПС + ЛогическаяОперация + " ", "")
				+ ?(ЭтоСоставнойОператор, "(", "")
				+ ТекстПодчиненногоОтбора
				+ ?(ЭтоСоставнойОператор, ")", "");
			КонецЕсли; 
		КонецЦикла; 
		
		Если ЗначениеЗаполнено(ЛогическийПрефикс) Тогда
			ТекстОтбора = СтрШаблон("%1 (%2)", ЛогическийПрефикс, ТекстОтбора);
		КонецЕсли; 
		
	КонецЕсли;
	
	Возврат ТекстОтбора;

КонецФункции

// Получает представление конечного эдемента отбора компоновки данных в формате языка запросов
//
// Параметры:
//  ЭлементОтбора		 - ЭлементОтбораКомпоновкиДанных		 - Элемент, который будет преобразовн
//  КомпоновщикНастроек	 - КомпоновщикНастроекКомпоновкиДанных	 - Связанынй компоновщик настроек
//  ПараметрыЗапроса	 - Структура							 - Содержит параметры, которые необходимо передать в запрос
//  ПрефиксПоляДанных	 - Строка								 - Префикс, который будет использоваться в тексте запроса для обозначения поля данных. 
//																В дальнейшем, префикс заменяется на псевдоним таблицы - источника данных.
// 
// Возвращаемое значение:
//  Строка - Текст для подстановки в запрос.
//
Функция ПолучитьТекстЗапросаЭлементаОтбораКомпоновкиДанных(ЭлементОтбора, КомпоновщикНастроек, ПараметрыЗапроса, ПрефиксПоляДанных = "")
	
	Виды = ВидСравненияКомпоновкиДанных;
	ПрефиксОтрицания = "НЕ ";
	ОперацииСравнения = Новый Соответствие;
	ОперацииСравнения.Вставить(Виды.Равно,					"=");
	ОперацииСравнения.Вставить(Виды.НеРавно,				ПрефиксОтрицания + "=");
	ОперацииСравнения.Вставить(Виды.Меньше,					"<");
	ОперацииСравнения.Вставить(Виды.МеньшеИлиРавно,			"<=");
	ОперацииСравнения.Вставить(Виды.Больше,					">");
	ОперацииСравнения.Вставить(Виды.БольшеИлиРавно,			">=");
	ОперацииСравнения.Вставить(Виды.ВСписке,				"В");
	ОперацииСравнения.Вставить(Виды.ВСпискеПоИерархии,		"В ИЕРАРХИИ");
	ОперацииСравнения.Вставить(Виды.ВИерархии,				"В ИЕРАРХИИ");
	ОперацииСравнения.Вставить(Виды.НеВСписке,				ПрефиксОтрицания + "В");
	ОперацииСравнения.Вставить(Виды.НеВСпискеПоИерархии,	ПрефиксОтрицания + "В ИЕРАРХИИ");
	ОперацииСравнения.Вставить(Виды.НеВИерархии,			ПрефиксОтрицания + "В ИЕРАРХИИ");
	// Подобия:
	ОперацииСравнения.Вставить(Виды.Подобно,				"ПОДОБНО");
	ОперацииСравнения.Вставить(Виды.НачинаетсяС,			"ПОДОБНО");
	ОперацииСравнения.Вставить(Виды.Содержит,				"ПОДОБНО");
	ОперацииСравнения.Вставить(Виды.НеПодобно,				ПрефиксОтрицания + "ПОДОБНО");
	ОперацииСравнения.Вставить(Виды.НеНачинаетсяС,			ПрефиксОтрицания + "ПОДОБНО");
	ОперацииСравнения.Вставить(Виды.НеСодержит,				ПрефиксОтрицания + "ПОДОБНО");
	// Хитрые операции:
	ОперацииСравнения.Вставить(Виды.Заполнено,				ПрефиксОтрицания + "В");	// В качестве аргумента будут пустые значения
	ОперацииСравнения.Вставить(Виды.НеЗаполнено,			"В");
	
	ТипыКоллекций = Новый Массив;
	ТипыКоллекций.Добавить(Тип("СписокЗначений"));
	ТипыКоллекций.Добавить(Тип("Массив"));
	ТипыКоллекций.Добавить(Тип("ФиксированныйМассив"));
	
	ОперацияСравнения = ОперацииСравнения.Получить(ЭлементОтбора.ВидСравнения);
	Если ОперацияСравнения <> Неопределено Тогда
		
		ЭтоОтрицание = СтрНачинаетсяС(ОперацияСравнения, ПрефиксОтрицания);
		Если ЭтоОтрицание Тогда
			ОперацияСравнения = Прав(ОперацияСравнения, СтрДлина(ОперацияСравнения) - СтрДлина(ПрефиксОтрицания));	
		КонецЕсли; 
		
		ТекстШаблона = "%1 %2 %3";
		
		ЛевоеЗначениеЭтоМножество	= ТипыКоллекций.Найти(ТипЗнч(ЭлементОтбора.ЛевоеЗначение)) <> Неопределено;
		ПравоеЗначениеЭтоМножество	= ТипыКоллекций.Найти(ТипЗнч(ЭлементОтбора.ПравоеЗначение)) <> Неопределено ИЛИ Найти(ОперацияСравнения, "В");
		Если ЛевоеЗначениеЭтоМножество Тогда ТекстШаблона = СтрЗаменить(ТекстШаблона, "%1", "(%1)") КонецЕсли;
		Если ПравоеЗначениеЭтоМножество Тогда ТекстШаблона = СтрЗаменить(ТекстШаблона, "%3", "(%3)") КонецЕсли;
		
		ЛевоеВыражениеЗапроса	= ПолучитьПредставлениеПоляДляТекстаЗапроса(ЭлементОтбора.ЛевоеЗначение, ПараметрыЗапроса, ПрефиксПоляДанных);
		ПодстрокаПоиска = ПрефиксПоляДанных + ЭлементОтбора.ЛевоеЗначение;
		Если СтрНайти(ЛевоеВыражениеЗапроса, ".") и СтрНайти(ЛевоеВыражениеЗапроса, ПодстрокаПоиска) Тогда	// Это подчиненное поле компоновки данных
			КоллекцияДоступныхПолей = КомпоновщикНастроек.Настройки.ДоступныеПоляОтбора.Элементы;
			ДоступноеПоле = НайтиДоступноеПолеКомпоновкиДанных(ЭлементОтбора.ЛевоеЗначение, КоллекцияДоступныхПолей);
			Если ДоступноеПоле <> Неопределено Тогда
				ПодстрокаЗамены = СтрШаблон("ЕСТЬNULL(%1, %2)", ПодстрокаПоиска, Запросы.ПривестиПустоеЗначениеВыраженияЗапроса(ДоступноеПоле.ТипЗначения));
				ЛевоеВыражениеЗапроса = СтрЗаменить(ЛевоеВыражениеЗапроса, ПодстрокаПоиска, ПодстрокаЗамены);
			КонецЕсли;	
		КонецЕсли;
		
		Если ЭлементОтбора.ВидСравнения = Виды.Заполнено ИЛИ ЭлементОтбора.ВидСравнения = Виды.НеЗаполнено Тогда
			
			//Найдём доступное поле:
			ДоступноеПоле = Неопределено;
			КоллекцияДоступныхПолей = КомпоновщикНастроек.Настройки.ДоступныеПоляОтбора.Элементы;
			ДоступноеПоле = НайтиДоступноеПолеКомпоновкиДанных(ЭлементОтбора.ЛевоеЗначение, КоллекцияДоступныхПолей);
			Если ДоступноеПоле <> Неопределено Тогда
				ПравоеВыражениеЗапроса	= ПолучитьПредставлениеПоляДляТекстаЗапроса(ДоступноеПоле, ПараметрыЗапроса, ПрефиксПоляДанных);
			Иначе	// Нет доступного поля, действуем по резервному сценарию - берём поле из правого значения
				ПравоеВыражениеЗапроса	= ПолучитьПредставлениеПоляДляТекстаЗапроса(ЭлементОтбора.ПравоеЗначение, ПараметрыЗапроса, ПрефиксПоляДанных);
			КонецЕсли; 
			
		Иначе	
			
			ПравоеВыражениеЗапроса	= ПолучитьПредставлениеПоляДляТекстаЗапроса(ЭлементОтбора.ПравоеЗначение, ПараметрыЗапроса, ПрефиксПоляДанных);
			ПодстрокаПоиска = ПрефиксПоляДанных + ЭлементОтбора.ПравоеЗначение;
			Если СтрНайти(ПравоеВыражениеЗапроса, ".") и СтрНайти(ПравоеВыражениеЗапроса, ПодстрокаПоиска) Тогда	// Это подчиненное поле компоновки данных
				КоллекцияДоступныхПолей = КомпоновщикНастроек.Настройки.ДоступныеПоляОтбора.Элементы;
				ДоступноеПоле = НайтиДоступноеПолеКомпоновкиДанных(ЭлементОтбора.ПравоеЗначение, КоллекцияДоступныхПолей);
				Если ДоступноеПоле <> Неопределено Тогда
					ПодстрокаЗамены = СтрШаблон("ЕСТЬNULL(%1, %2)", ПодстрокаПоиска, Запросы.ПривестиПустоеЗначениеВыраженияЗапроса(ДоступноеПоле.ТипЗначения));
					ПравоеВыражениеЗапроса = СтрЗаменить(ПравоеВыражениеЗапроса, ПодстрокаПоиска, ПодстрокаЗамены);
				КонецЕсли;	
			КонецЕсли;
			
		КонецЕсли; 
		
		// Подобия:
		Если ЭлементОтбора.ВидСравнения = Виды.НачинаетсяС Тогда
			ПравоеВыражениеЗапроса = Лев(ПравоеВыражениеЗапроса, СтрДлина(ПравоеВыражениеЗапроса) - 1) + "%""";	// В аргумент % справа внутрь скобок
		КонецЕсли; 
		Если ЭлементОтбора.ВидСравнения = Виды.Содержит Тогда
			ПравоеВыражениеЗапроса = """%" + Сред(ПравоеВыражениеЗапроса, 2, СтрДлина(ПравоеВыражениеЗапроса) - 2) + "%""";	// В аргумент % слева и справа внутрь скобок
		КонецЕсли; 
		
		ТекстОтбора = СтрШаблон(ТекстШаблона, ЛевоеВыражениеЗапроса, ОперацияСравнения, ПравоеВыражениеЗапроса);
		
		Если ЭтоОтрицание Тогда	
			ТекстОтбора = ПрефиксОтрицания + ТекстОтбора;		
		КонецЕсли; 
	КонецЕсли; 
	
	Возврат ТекстОтбора;

КонецФункции // ПолучитьТекстЗапросаЭлементаОтбораКомпоновкиДанных()

// Формирует текстовое представление поля для использования в запросе.
//
// Параметры:
//  Поле - ПолеКомпоновкиДанных - Дополняется префиксом и помещается в текст запроса.
//  	 - ДоступноеПолеОтбораКомпоновкиДанных - В параметры помещается коллекция возможных пустых значений поля.
//		 - Произвольный - Значения примитивных типов преобразуются в литералы. Прочите типы помещаются в параметр.
//  ПараметрыЗапроса	 - Структура	 - Параметры, полученные из полей
//  ПрефиксПоляДанных	 - Строка		 - Префикс поля данных
// 
// Возвращаемое значение:
//   - Строка - Текстовое представление поля
//
Функция ПолучитьПредставлениеПоляДляТекстаЗапроса(Поле, ПараметрыЗапроса, ПрефиксПоляДанных = "#")
	
	Если ТипЗнч(Поле) = Тип("ПолеКомпоновкиДанных") Тогда
		Возврат	ПрефиксПоляДанных + Строка(Поле);
	ИначеЕсли ТипЗнч(Поле) = Тип("Булево") Тогда
		Возврат ?(Поле, "ИСТИНА", "ЛОЖЬ");
	ИначеЕсли ТипЗнч(Поле) = Тип("Число") Тогда
		Возврат Формат(Поле, "ЧГ=0");
	ИначеЕсли ТипЗнч(Поле) = Тип("Строка") Тогда
		Возврат СтрШаблон("""%1""", Поле);
	ИначеЕсли ТипЗнч(Поле) = Тип("Неопределено") Тогда
		Возврат "НЕОПРЕДЕЛЕНО";
	ИначеЕсли ТипЗнч(Поле) = Тип("Null") Тогда
		Возврат "NULL";
	ИначеЕсли ТипЗнч(Поле) = Тип("СтандартнаяДатаНачала") Тогда
		Возврат СтрШаблон("ДАТАВРЕМЯ(%1, %2, %3, %4, %5, %6)", Формат(Год(Поле.Дата), "ЧГ=0"), Месяц(Поле.Дата), День(Поле.Дата), Час(Поле.Дата), Минута(Поле.Дата), Секунда(Поле.Дата));
	ИначеЕсли ТипЗнч(Поле) = Тип("ДоступноеПолеОтбораКомпоновкиДанных") Тогда
		// Получаем все варианты не заданного значения
		ПустыеЗначения = Новый СписокЗначений;
		КоллекцияТипов = Поле.Тип.Типы();
		Если КоллекцияТипов.Количество() Тогда
			ПустыеЗначения.Добавить(Неопределено);
		КонецЕсли; 
		Для каждого Тип Из КоллекцияТипов Цикл
			Типы = Новый Массив;
			Типы.Добавить(Тип);
			ОписаниеТипов = Новый ОписаниеТипов(Типы);
			ПустыеЗначения.Добавить(ОписаниеТипов.ПривестиЗначение());
		КонецЦикла; 
		ИмяПараметра = "Параметр" + Формат(ПараметрыЗапроса.Количество() + 1, "ЧГ=0");
		ПредставлениеПоля = "&" + ИмяПараметра;
		ПараметрыЗапроса.Вставить(ИмяПараметра, ПустыеЗначения);
		Возврат ПредставлениеПоля;
	Иначе
		ИмяПараметра = "Параметр" + Формат(ПараметрыЗапроса.Количество() + 1, "ЧГ=0");
		ПредставлениеПоля = "&" + ИмяПараметра;
		ПараметрыЗапроса.Вставить(ИмяПараметра, Поле);
		Возврат ПредставлениеПоля;
	КонецЕсли; 
	
	Возврат "";
	
КонецФункции 

// Производит поиск доступного поля компоновки данных
//
// Параметры:
//  Поле					 - ПолеКомпоновкиДанных, Строка				 - Например, "Контрагент.ИНН"
//  КоллекцияДоступныхПолей	 - КоллекцияДоступныхПолейКомпоновкиДанных	 - Коллекция, в которой будет осуществлён поиск
// 
// Возвращаемое значение:
//   - ДоступноеПолеКомпоновкиДанных, ДоступноеПолеОтбораКомпоновкиДанных, Неопределено   - Найденное поле
//
Функция НайтиДоступноеПолеКомпоновкиДанных(Знач Поле, Знач КоллекцияДоступныхПолей)

	ОчередьПолей = Новый Массив;
	Поле = Строка(Поле);
	Пока Истина Цикл
		ОчередьПолей.Вставить(0, Поле);
		ПозицияТочки = СтрНайти(Поле, ".", НаправлениеПоиска.СКонца);
		Если ПозицияТочки = 0 Тогда Прервать КонецЕсли; 
		Поле = Лев(Поле, ПозицияТочки - 1);
	КонецЦикла; 
	ДоступноеПоле = Неопределено;

	Для каждого Поле Из ОчередьПолей Цикл
		ДоступноеПоле = КоллекцияДоступныхПолей.Найти(Поле);
		Если ДоступноеПоле = Неопределено Тогда
			Прервать;
		КонецЕсли; 
		КоллекцияДоступныхПолей = ДоступноеПоле.Элементы;
	КонецЦикла; 
	
	Возврат ДоступноеПоле;

КонецФункции // НайтиДоступноеПолеКомпоновкиДанных()

// Удаляет псевдонимы, автоматически генерируемые для условий секции {ГДЕ ...} текста запроса.
//
// Параметры:
//  ИсходныйТекстЗапроса - Строка	 - Валидный текст запроса.
//
// Возвращаемое значение:
//	Строка - Изменённый текст запроса
//
// Пример:
//	УдалитьАвтоПсевдонимыПолейРасширенияУсловийТекстаЗапроса("... {ГДЕ (Истина) КАК Поле1}") // "... {ГДЕ (Истина)}"
//
Функция УдалитьАвтоПсевдонимыПолейРасширенияУсловийТекстаЗапроса(Знач ИсходныйТекстЗапроса)

	ПробельныеСимволы = Новый Массив;
	ПробельныеСимволы.Добавить(" ");
	ПробельныеСимволы.Добавить(Символы.НПП);
	ПробельныеСимволы.Добавить(Символы.Таб);
	ПробельныеСимволы.Добавить(Символы.ВТаб);
	ПробельныеСимволы.Добавить(Символы.ВК);
	ПробельныеСимволы.Добавить(Символы.ПС);
	ПробельныеСимволы.Добавить(Символы.ПФ);
	
	СекцииУсловий = Новый ТаблицаЗначений;
	
	РезультирующийТекстЗапроса = "";
	Буфер = "";
	
	НачалоФрагмента = 0;
	КонецФрагмента = 0;
	ДлинаИсходногоТекстаЗапроса = СтрДлина(ИсходныйТекстЗапроса);
	Для ПозицияКурсора = 1 по ДлинаИсходногоТекстаЗапроса Цикл
		
		Если не ЗначениеЗаполнено(НачалоФрагмента) Тогда НачалоФрагмента = ПозицияКурсора КонецЕсли;
		
		СимволПодКурсором = Сред(ИсходныйТекстЗапроса, ПозицияКурсора, 1);
		
		// Проверяем, начало секции {ГДЕ}
		ЭтоСекцияУсловие = Ложь;
		Если СимволПодКурсором = "{" Тогда
			НачалоСекции = ПозицияКурсора;
			КонецСекции = СтрНайти(ИсходныйТекстЗапроса, "}",,НачалоСекции);
			СекцияИсходная = Сред(ИсходныйТекстЗапроса, НачалоСекции, КонецСекции - НачалоСекции + 1);
			СекцияИсходнаяЛинейно = СтрЗаменить(СекцияИсходная, Символы.ПС, "");	// Исходная секция, в одну строку.
			Пока ПробельныеСимволы.Найти(Сред(СекцияИсходнаяЛинейно, 2, 1)) <> Неопределено и СтрДлина(СекцияИсходнаяЛинейно) > 2 Цикл	// Убираем пробельные символы между скобкой и ключевым словом.
				СекцияИсходнаяЛинейно = Лев(СекцияИсходнаяЛинейно, 1) + Сред(СекцияИсходнаяЛинейно, 3);
			КонецЦикла; 
			Если СтрНачинаетсяС(ВРег(СекцияИсходнаяЛинейно), "{ГДЕ") и ПробельныеСимволы.Найти(Сред(СекцияИсходнаяЛинейно, 5, 1)) <> Неопределено Тогда
				ЭтоСекцияУсловие = Истина;
			КонецЕсли; 
		КонецЕсли; 
		
		ЭтоКонецИсходногоТекста = ПозицияКурсора = ДлинаИсходногоТекстаЗапроса;
		Если ЭтоСекцияУсловие Или ЭтоКонецИсходногоТекста Тогда
			
			// Скидываем накопленное до секции в результат
			КонецФрагмента = ?(ЭтоКонецИсходногоТекста, ПозицияКурсора, НачалоСекции - 1);
			РезультирующийТекстЗапроса = РезультирующийТекстЗапроса + Сред(ИсходныйТекстЗапроса, НачалоФрагмента, КонецФрагмента - НачалоФрагмента + 1);
			
			Если ЭтоСекцияУсловие Тогда
				// Модифицируем условия секции
				РезультирующийТекстСекции = СекцияИсходная;
				#Область МодификацияУсловий
				СодержимоеСекции = Сред(СекцияИсходная, 2, СтрДлина(СекцияИсходная) - 2);
				ФрагментыСекции = СтрРазделить(СодержимоеСекции, ",", Ложь);
				Для каждого ФрагментСекции Из ФрагментыСекции Цикл
					
					#Область ПроверкаНаличияАвтоПсевдонима
					ИскомыйТекст = " КАК Поле";
					ПозицияИскомогоТекста = СтрНайти(ФрагментСекции, ИскомыйТекст);
					Если не ЗначениеЗаполнено(ПозицияИскомогоТекста) Тогда Продолжить КонецЕсли; 			
					Суффикс = Сред(ФрагментСекции, ПозицияИскомогоТекста + СтрДлина(ИскомыйТекст));
					Если не ЗначениеЗаполнено(Суффикс) Тогда Продолжить КонецЕсли;	// "Поле" (без суффикса)
					СуффиксЭтоЧисло = Истина;
					Для НомерСимвола = 1 По СтрДлина(Суффикс) Цикл
						СуффиксЭтоЧисло = Булево(СтрНайти("1234567890", Сред(Суффикс, ПозицияКурсора, 1)));
					    Если не СуффиксЭтоЧисло Тогда Прервать КонецЕсли; 
					КонецЦикла;
					Если не СуффиксЭтоЧисло Тогда Продолжить КонецЕсли; // Пропускаем этот фрагмент
					#КонецОбласти // ПроверкаНаличияАвтоПсевдонима 
					
					РезультирующийТекстСекции = СтрЗаменить(
					РезультирующийТекстСекции,
					ФрагментСекции,
					Лев(ФрагментСекции, ПозицияИскомогоТекста - 1));
					
				КонецЦикла; 
				#КонецОбласти // МодификацияУсловий 
			
				// Добавляем изменённую секцию в результат
				РезультирующийТекстЗапроса = РезультирующийТекстЗапроса + РезультирующийТекстСекции;
			КонецЕсли;
			
			// устанавливаем курсор на конец секции чтобы продолжить по нормальному тексту
			Если ЭтоСекцияУсловие Тогда
				ПозицияКурсора = КонецСекции;
				НачалоФрагмента	 = 0;
				КонецФрагмента	 = 0;
			КонецЕсли; 
		
		КонецЕсли; 
		
	КонецЦикла;
	
	Возврат РезультирующийТекстЗапроса;

КонецФункции // УдалитьАвтоПсевдонимыПолейРасширенияУсловийТекстаЗапроса()

// Устанавливает значение параметра данных с учётом возможного нахождения параметра в пользовательских настройках
//
// Параметры:
//  КомпоновщикНастроек	 - КомпоновщикНастроекКомпоновкиДанных	 - Компоновщик настроек, в настройках которого устанавливается параметр
//  ПараметрДанных		 - Строка,  ПараметрКомпоновкиДанных	 - Устанавливаемый параметр
//  НовоеЗначение		 - Произвольный							 - Устанавливаемое значение
//
Процедура УстановитьЗначениеПараметраДанныхКомпоновкиДанных(Знач КомпоновщикНастроек, Знач ПараметрДанных, Знач НовоеЗначение)
	
	Если ТипЗнч(ПараметрДанных) = Тип("Строка") Тогда
		ПараметрДанных = Новый ПараметрКомпоновкиДанных("ПараметрДанных");
	КонецЕсли;

	ПараметрыДанных = КомпоновщикНастроек.Настройки.ПараметрыДанных;

	ЗначениеПараметраДанных = ПараметрыДанных.НайтиЗначениеПараметра(ПараметрДанных);

	Если ЗначениеЗаполнено(ЗначениеПараметраДанных.ИдентификаторПользовательскойНастройки) Тогда
		Для Каждого ПользовательскаяНастройка Из КомпоновщикНастроек.ПользовательскиеНастройки.Элементы Цикл
			Если ТипЗнч(ПользовательскаяНастройка) = Тип("ЗначениеПараметраКомпоновкиДанных")
				И ПользовательскаяНастройка.ИдентификаторПользовательскойНастройки = ЗначениеПараметраДанных.ИдентификаторПользовательскойНастройки Тогда
				ПользовательскаяНастройка.Значение = НовоеЗначение;
			    ПользовательскаяНастройка.Использование = Истина;
			КонецЕсли; 
		КонецЦикла; 
	Иначе
		ПараметрыДанных.УстановитьЗначениеПараметра(ПараметрДанных, НовоеЗначение);
	КонецЕсли; 

КонецПроцедуры // УстановитьЗначениеПараметраДанныхКомпоновкиДанных()

// Переносит элементы отбора из одной коллекции отборов в другую.
// Переносятся только элементы отбора, которые могут применяться в компоновщике-приёмнике.
//
// Параметры:
//  ДоступныеПоляОтбора	 - ДоступныеПоляКомпоновкиДанных  - Доступные, в рамках компоновщика, поля отбора.
//  ОтборИсточник		 - ОтборКомпоновкиДанных, ГруппаЭлементовОтбораКомпоновкиДанных	 - Копируемый отбор
//  ОтборПриемник		 - ОтборКомпоновкиДанных, ГруппаЭлементовОтбораКомпоновкиДанных	 - Заполняемый отбор
//
Процедура СкопироватьПрименимыеОтборыКомпоновки(Знач ОтборИсточник, Знач ОтборПриемник, Знач ДоступныеПоляОтбора)

	// #СДЕЛАТЬ рекурсивное заполнение групп отборов
	// при рекурсивном заполнении, переносятся только те группы, количество используемых отборов в которых совпадает.
	
	Для каждого ЭлементОтбораИсходный Из ОтборИсточник.Элементы Цикл
		Если ТипЗнч(ЭлементОтбораИсходный) = Тип("ОтборКомпоновкиДанных") 
			И ЭлементОтбораИсходный.Использование
			И ТипЗнч(ЭлементОтбораИсходный.ЛевоеЗначение) = Тип("ПолеКомпоновкиДанных")
			И ДоступныеПоляОтбора.НайтиПоле(ЭлементОтбораИсходный.ЛевоеЗначение)  Тогда
			
			ЭлементОтбора = ОтборПриемник.Элементы.Добавить(тип("ЭлементОтбораКомпоновкиДанных"));
			ЭлементОтбора.ЛевоеЗначение	 = ЭлементОтбораИсходный.ЛевоеЗначение;
			ЭлементОтбора.ВидСравнения	 = ЭлементОтбораИсходный.ВидСравнения;
			ЭлементОтбора.ПравоеЗначение = ЭлементОтбораИсходный.ПравоеЗначение;
			ЭлементОтбора.Использование	 = ЭлементОтбораИсходный.Использование;
			
		КонецЕсли; 
	КонецЦикла;

КонецПроцедуры // СкопироватьПрименимыеОтборыКомпоновки()
