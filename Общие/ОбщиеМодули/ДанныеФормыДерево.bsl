#Область КоллекцииДанных
	
// Получает коллекцию подчиненных элементов
//
// Параметры:
//  Узел - ДанныеФормыДерево, ДанныеФормыЭлементДерева, ДеревоЗначений, СтрокаДереваЗначений - Узел или корень дерева
// 
// Возвращаемое значение:
//   - ДанныеФормыКоллекцияЭлементовДерева, КоллекцияСтрокДереваЗначений
//
&НаКлиентеНаСервереБезКонтекста
Функция ПолучитьВетви(Узел)

	Возврат ?(ЭтоЭлементДереваФормы(Узел), Узел.ПолучитьЭлементы(), Узел.Строки)

КонецФункции // ПолучитьВетви()

// Проверяет, является ли Узел элементом древовидной коллекции
//
// Параметры:
//  Узел - Произвольный - Узел или корень дерева
// 
// Возвращаемое значение:
//   - Булево
//
&НаКлиентеНаСервереБезКонтекста
Функция ЭтоУзелДерева(Узел)
	ЭтоУзелДерева = ТипЗнч(Узел) = Тип("ДанныеФормыЭлементДерева");
	#Если Сервер Тогда
		ЭтоУзелДерева = ЭтоУзелДерева ИЛИ ТипЗнч(Узел) = Тип("СтрокаДереваЗначений");
	#КонецЕсли 
	Возврат ЭтоУзелДерева
КонецФункции	// ЭтоУзелДерева()

// Проверяет, является ли Узел листом древовидной коллекции
//
// Параметры:
//  Узел - ДанныеФормыДерево, ДанныеФормыЭлементДерева, ДеревоЗначений, СтрокаДереваЗначений - Узел или корень дерева
// 
// Возвращаемое значение:
//   - Булево
//
&НаКлиентеНаСервереБезКонтекста
Функция ЭтоЛистДерева(Узел)
	
	Возврат ЭтоУзелДерева(Узел) и не ПолучитьВетви(Узел).Количество()
	
КонецФункции	// ЭтоЛистДерева()

// Проверяет, является ли Узел элементом древовидной коллекции формы
//
// Параметры:
//  Узел - ДанныеФормыДерево, ДанныеФормыЭлементДерева, ДеревоЗначений, СтрокаДереваЗначений - Узел или корень дерева
// 
// Возвращаемое значение:
//   - Булево
//
&НаКлиентеНаСервереБезКонтекста
Функция ЭтоЭлементДереваФормы(Узел)

	Возврат ТипЗнч(Узел) = Тип("ДанныеФормыЭлементДерева")
		ИЛИ ТипЗнч(Узел) = Тип("ДанныеФормыДерево")

КонецФункции // ЭтоЭлементДереваФормы()
 
// Проверяет, является ли текущий узел ветвью дерева, в которую ещё не загружены дочерние элементы
//
// Параметры:
//  Узел - ДанныеФормыЭлементКоллекции	 - 
// 
// Возвращаемое значение:
//   - Булево
//
&НаКлиентеНаСервереБезКонтекста
Функция ЭтоНезагруженнаяВетвьДереваФормы(Узел)

	Если ТипЗнч(Узел) <> Тип("ДанныеФормыДерево") И ТипЗнч(Узел) <> Тип("ДанныеФормыЭлементДерева")  Тогда Возврат Ложь КонецЕсли;
	Коллекция = Узел.ПолучитьЭлементы();
	Если Коллекция.Количество() <> 1  Тогда Возврат Ложь КонецЕсли;
	
	Возврат Коллекция[0].Служебная;

КонецФункции // ЭтоНезагруженнаяВетвьДереваФормы()

// Получает конечные элементы предоставленной коллекции
//
// Параметры:
//  Узел - ДанныеФормыДерево, ДанныеФормыЭлементДерева, ДеревоЗначений, СтрокаДереваЗначений	 - 
// 
// Возвращаемое значение:
//   - Массив{ДанныеФормыЭлементДерева, СтрокаДереваЗначений}
//
&НаКлиентеНаСервереБезКонтекста
Функция ПолучитьЛистьяДереваРекурсивно(Узел, Отбор = Неопределено)
	
	ВозвращаемоеЗначение = Новый Массив;
	Коллекция = ПолучитьВетви(Узел);
	Если Коллекция.Количество() Тогда
		Для каждого Ветвь Из Коллекция Цикл
			Для каждого Лист Из ПолучитьЛистьяДереваРекурсивно(Ветвь, Отбор) Цикл  ВозвращаемоеЗначение.Добавить(Лист) КонецЦикла; 		
		КонецЦикла; 	
	ИначеЕсли ЭтоУзелДерева(Узел) Тогда 
		Если Отбор = Неопределено Тогда
			ВозвращаемоеЗначение.Добавить(Узел) 
		Иначе
			УзелСоответстветОтбору = Истина;
			Для каждого Элемент Из Отбор Цикл
				Если Узел[Элемент.Ключ] <> Элемент.Значение Тогда
					УзелСоответстветОтбору = Ложь;
					Прервать
				КонецЕсли; 			
			КонецЦикла; 
			Если УзелСоответстветОтбору Тогда
				ВозвращаемоеЗначение.Добавить(Узел) 
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	
	Возврат ВозвращаемоеЗначение

КонецФункции // ПолучитьЛистьяДереваЗначенийРекурсивно()

// → ПолучитьПоляЛистьевДерева()
//  В качестве узла может быть передан адрес во временном хранилище
//
// Параметры:
//  Адрес			 - Строка	 - Адрес дерева во временном хранилище
//  Идентификатор	 - УникальныйИдентификатор	 - Используется, если в качеств
//  Поля			 - Строка	 - 
//  Отбор			 - Структура	 - 
// 
// Возвращаемое значение:
//   - Массив
//
&НаСервереБезКонтекста
Функция ПолучитьПоляЛистьевДереваНаСервере(Адрес, Идентификатор = Неопределено, Поля = "Идентификатор", Отбор = Неопределено)

	ВозвращаемоеЗначение = Новый Массив;
	
	Если ЭтоАдресВременногоХранилища(Адрес) Тогда
		ДеревоДанных = ПолучитьИзВременногоХранилища(Адрес);
		Если ДеревоДанных = Неопределено Тогда Возврат ВозвращаемоеЗначение КонецЕсли; 
		Если Идентификатор = Неопределено Тогда
			ВозвращаемоеЗначение = ПолучитьПоляЛистьевДерева(ДеревоДанных, Поля, Отбор);
		Иначе	
			Узел = ДеревоДанных.Строки.Найти(Идентификатор, "Идентификатор", Истина);
			Если Узел <> Неопределено Тогда
				ВозвращаемоеЗначение = ПолучитьПоляЛистьевДерева(Узел, Поля, Отбор);
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	
	Возврат ВозвращаемоеЗначение;

КонецФункции // ПолучитьПоляЛистьевДереваНаСервере()

// Получает поля листьев дерева
//
// Параметры:
//  Узел						 - ДанныеФормыДерево, ДанныеФормыЭлементДерева	 - 
//  Поля						 - Строка										 - Имена полей
//  Отбор						 - Структура									 - Какие элементы опрашиваются
// 
// Возвращаемое значение:
//  Массив - Структуры данных
//
&НаКлиентеНаСервереБезКонтекста
Функция ПолучитьПоляЛистьевДерева(Узел, Поля = "Идентификатор, ИдентификаторСтроки", Отбор = Неопределено)

	ЕстьОтбор = Отбор <> Неопределено;
	
	КоллекцияДанных = Новый Массив;                                        
	КоллекцияПодчиненных = ПолучитьВетви(Узел);
	
	Листья = ?(ЕстьОтбор, КоллекцияПодчиненных.НайтиСтроки(Отбор, Истина), ПолучитьЛистьяДереваРекурсивно(Узел));
	
	Для каждого Лист Из Листья Цикл
		Если ЕстьОтбор И не ЭтоЛистДерева(Лист) Тогда Продолжить КонецЕсли;	// По отбору могут быть подобраны узлы, имеющие подчиненные элементы.
		СтруктураДанных = Новый Структура(Поля);
		ЗаполнитьЗначенияСвойств(СтруктураДанных, Лист);
		КоллекцияДанных.Добавить(СтруктураДанных);
	КонецЦикла; 
	
	Возврат КоллекцияДанных;
	
КонецФункции // ПолучитьПоляЛистьевДерева()

// → ПолучитьПоляДанныхДереваРекурсивно()
// В качестве узла может быть передан адрес во временном хранилище
//
&НаСервереБезКонтекста
Функция ПолучитьПоляДанныхДереваНаСервере(Узел, Поля = "Идентификатор", Отбор = Неопределено)

	Если ЭтоАдресВременногоХранилища(Строка(Узел)) Тогда
		ДеревоДанных = ПолучитьИзВременногоХранилища(Узел);
		Возврат ПолучитьПоляДанныхДереваРекурсивно(ДеревоДанных, Поля, Отбор);
	КонецЕсли; 
	
	Возврат ПолучитьПоляДанныхДереваРекурсивно(Узел, Поля, Отбор);

КонецФункции // ПолучитьПоляДанныхДереваНаСервере()

// Получает поля элементов дерева
//
// Параметры:
//  Узел						 - ДанныеФормыДерево, ДанныеФормыЭлементДерева	 - 
//  Поля						 - Строка										 - Имена полей
//  Отбор						 - Структура									 - Какие элементы опрашиваются
// 
// Возвращаемое значение:
//  Массив - Структуры данных
//
&НаКлиентеНаСервереБезКонтекста
Функция ПолучитьПоляДанныхДереваРекурсивно(Узел, Поля = "Идентификатор, ИдентификаторСтроки", Отбор = Неопределено)

	КоллекцияДанных = Новый Массив;
	
	Если ЭтоУзелДерева(Узел) и ЭлементСоответствуетОтбору(Узел, Отбор) Тогда
		СтруктураДанных = Новый Структура(Поля);
		ЗаполнитьЗначенияСвойств(СтруктураДанных, Узел);
		Если СтруктураДанных.Свойство("ИдентификаторСтроки") и ЭтоЭлементДереваФормы(Узел) Тогда
			СтруктураДанных.ИдентификаторСтроки = Узел.ПолучитьИдентификатор();
		КонецЕсли; 
		КоллекцияДанных.Добавить(СтруктураДанных);
	КонецЕсли; 
	
	Коллекция = ПолучитьВетви(Узел);
	
	Для каждого Ветвь Из Коллекция Цикл
		ДанныеПодчиненных = ПолучитьПоляДанныхДереваРекурсивно(Ветвь, Поля, Отбор);
		Для каждого СтруктураДанных Из ДанныеПодчиненных Цикл
			КоллекцияДанных.Добавить(СтруктураДанных);
		КонецЦикла;	
	КонецЦикла; 
	
	Возврат КоллекцияДанных;
	
КонецФункции // ПолучитьПоляДанныхДереваРекурсивно()

// Получает поля элементов дерева в иерархическом виде
//
// Параметры:
//  Узел						 - ДанныеФормыДерево, ДанныеФормыЭлементДерева	 - 
//  Поля						 - Строка										 - Имена полей
//  ИмяКоллекцииВложенныхСтрок	 - Строка										 - Имя массива вложенных строк 
// 
// Возвращаемое значение:
//  Структура{[ИмяПоля], ИмяКоллекцииВложенныхСтрок} данных
//
&НаКлиентеНаСервереБезКонтекста
Функция ПолучитьПоляДанныхДереваФормыИерархическиРекурсивно(Узел, Поля = "Идентификатор, ИдентификаторСтроки", ИмяКоллекцииВложенныхСтрок = "Строки", ИсключаяСлужебные = Истина)

	СтруктураДанных = Новый Структура(Поля);
	
	Если ТипЗнч(Узел) = Тип("ДанныеФормыЭлементДерева") Тогда
		ЗаполнитьЗначенияСвойств(СтруктураДанных, Узел);
		Если СтруктураДанных.Свойство("ИдентификаторСтроки") Тогда
			СтруктураДанных.ИдентификаторСтроки = Узел.ПолучитьИдентификатор();
		КонецЕсли; 
	КонецЕсли; 
	
	СтруктураДанных.Вставить(ИмяКоллекцииВложенныхСтрок, Новый Массив);
	
	Для каждого Ветвь Из Узел.ПолучитьЭлементы() Цикл
		Если ИсключаяСлужебные и Ветвь.Служебная Тогда Продолжить КонецЕсли; 
		СтруктураДанных[ИмяКоллекцииВложенныхСтрок].Добавить(ПолучитьПоляДанныхДереваФормыИерархическиРекурсивно(Ветвь, Поля, ИмяКоллекцииВложенныхСтрок));
	КонецЦикла;
	
	Возврат СтруктураДанных;
	
КонецФункции // ПолучитьПоляДанныхДереваФормыИерархическиРекурсивно()

#Область ДеревоЗначений

&НаКлиенте
Функция АдресХранилищаДереваДанныхРеестра()

	Возврат НастройкиРеестра.АдресХранилища

КонецФункции // ПолучитьАдресХранилищаДереваДанных()

#КонецОбласти	// ДеревоЗначений 

#Область КэшИдентификаторов

// Производит поиск по идентификатору с учетом кэша
//
// Параметры:
//  Идентификатор			 - УникальныйИдентификатор	 - Соответствует идентификатору реестра
//  ИспользоватьКэш			 - Булево							 - 
//  ПродолжитьПоискВнеКэша	 - Булево							 - 
// 
// Возвращаемое значение:
//  ДанныеФормыЭлементКоллекции, Неопределено - Элемент реестра платежей
//
&НаКлиенте
Функция НайтиСтрокуРеестраПоИдентификатору(Идентификатор, ИспользоватьКэш = Истина, ПродолжитьПоискВнеКэша = Истина)
	
	Реестр = РеестрРаспоряжений;
	Позиция = Неопределено;
	
	Если ИспользоватьКэш Тогда
		
		ИдентификаторСтроки = Неопределено;
		СтрокиКэша = КэшИдентификаторовРеестра.НайтиСтроки(Новый Структура("Идентификатор", Идентификатор));
		Если ЗначениеЗаполнено(СтрокиКэша) Тогда
			ИдентификаторСтроки = СтрокиКэша[0].ИдентификаторСтроки
		КонецЕсли; 
		
		Если ИдентификаторСтроки = Неопределено Тогда // Промах по кэшу
			Если ПродолжитьПоискВнеКэша Тогда
				ИдентификаторыСтрок = НайтиСтрокиДереваФормы(Реестр, Новый Структура("Идентификатор", Идентификатор), Истина);
				Если ЗначениеЗаполнено(ИдентификаторыСтрок) Тогда
					ИдентификаторСтроки = ИдентификаторыСтрок[0];
					КэшироватьИдентификатор(ИдентификаторСтроки, Идентификатор);
					Позиция = Реестр.НайтиПоИдентификатору(ИдентификаторыСтрок[0]);
				КонецЕсли; 
			КонецЕсли; 
		Иначе
			Позиция = Реестр.НайтиПоИдентификатору(ИдентификаторСтроки);
			Если Позиция = Неопределено Тогда	// Кэш врёт
				ОчиститьКэшИдентификаторов();
				Позиция = НайтиСтрокуРеестраПоИдентификатору(Идентификатор, ИспользоватьКэш, Истина)	// При пустом кэше будет поиск по дереву
			КонецЕсли; 
		КонецЕсли; 
		
	Иначе
		
		Позиции = НайтиСтрокиДереваФормы(Реестр, Новый Структура("Идентификатор", Идентификатор), Истина);
		Если ЗначениеЗаполнено(Позиции) Тогда Позиция = Реестр.НайтиПоИдентификатору(Позиции[0]) КонецЕсли; 
		
	КонецЕсли; 
		
	Возврат Позиция
	
КонецФункции // НайтиСтрокуРеестраПоИдентификатору()

#КонецОбласти	// КоллекцииДанных 
