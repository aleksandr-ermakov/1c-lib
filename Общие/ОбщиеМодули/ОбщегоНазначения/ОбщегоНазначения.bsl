#Область OneScript

// BSLLS:CognitiveComplexity-off
// BSLLS:CyclomaticComplexity-off

Перем Метаданные;
Перем Справочники, Документы, Перечисления, БизнесПроцессы, Задачи;
Перем ПланыВидовХарактеристик, ПланыСчетов, ПланыВидовРасчета, ПланыОбмена;
Перем РежимЗаписиДокумента, РежимПроведенияДокумента;

#КонецОбласти // OneScript

#Область Данные

// Устанавливает значения реквизитов и записывает прикладной объект.
//
// Параметры:
//	Ссылка						 - ЛюбаяСсылка		 - Ссылка на объект.
//	ЗначенияРеквизитов			 - Структура		 - Ключ - Имя реквизита, Значение - Значение реквизита.
//												Если реквизит отсутствует в объекте - будет выдано исключение.
//	ДополнительныеСвойства 		 - Структура		 - Дополнительные свойства объекта. Транслируется в объект.
//	ПараметрыЗаписиДокумента	 - Структура		 - Параметры метода Записать() для документов:
//									* РежимЗаписи		 - РежимЗаписиДокумента		 - Если не указан - "Запись".
//									* РежимПроведения	 - РежимПроведенияДокумента	 - Если не указан - "Неопретивный"
//								 - Булево			 - Предустановки параметров записи:
//									* Истина			 - Перепроведение проведенных документов. 
//															Документы будущей даты проводятся оперативно.
//									* Ложь				 - Запись документа без перепроведения.
//	ОбменДанными				 - Булево			 - Интерпретируется как ОбменДанными.Загрузка. 
//								 - Структура		 - Транслируется в одноименное свойство объекта. 
//									Элементы не обязательные, соответствуют свойствам объекта ПараметрыОбменаДанными:
//									* Загрузка		 - Булево
//									* Отправитель	 - ПланОбменаСсылка, Неопределено
//									* Получатели	 - Массив из ПланОбменаСсылка
//									* АвтоЗаполнение - Булево - Транслируется в Получатели.АвтоЗаполнение
//
Процедура УстановитьЗначенияРеквизитовОбъекта(
	Ссылка, 
	ЗначенияРеквизитов, 
	ДополнительныеСвойства = Неопределено, 
	ПараметрыЗаписиДокумента = Неопределено,
	ОбменДанными = Неопределено) Экспорт

	ЭтоДокументСсылка = Ложь;
	ТипСсылки = ТипЗнч(Ссылка);
	Если Документы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		ЭтоДокументСсылка = Истина;
	ИначеЕсли Справочники				.ТипВсеСсылки().СодержитТип(ТипСсылки)
		Или Задачи						.ТипВсеСсылки().СодержитТип(ТипСсылки)
		Или ПланыВидовХарактеристик		.ТипВсеСсылки().СодержитТип(ТипСсылки)
		Или ПланыСчетов					.ТипВсеСсылки().СодержитТип(ТипСсылки)
		Или ПланыВидовРасчета			.ТипВсеСсылки().СодержитТип(ТипСсылки)
		Или ПланыОбмена					.ТипВсеСсылки().СодержитТип(ТипСсылки)
		Или БизнесПроцессы				.ТипВсеСсылки().СодержитТип(ТипСсылки)
		Или Задачи						.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		ЭтоДокументСсылка = Ложь;
	Иначе
		ВызватьИсключение "Параметр Ссылка: Неожиданный тип";
	КонецЕсли;

	Если ТипЗнч(ЗначенияРеквизитов) <> Тип("Структура") Тогда
		ВызватьИсключение "Параметр ЗначенияРеквизитов: Ожидается Структура";
	КонецЕсли;

	Объект = Ссылка.ПолучитьОбъект();

	Для Каждого Элемент Из ЗначенияРеквизитов Цикл
		Объект[Элемент.Ключ] = Элемент.Значение;
	КонецЦикла;

	Если ТипЗнч(ОбменДанными) = Тип("Булево") Тогда
		Объект.ОбменДанными.Загрузка = ОбменДанными;
	КонецЕсли;
	Если ТипЗнч(ОбменДанными) = Тип("Структура") Тогда
		ОбменДаннымиЗаполняемый = Новый Структура(
			"Загрузка, Отправитель, Получатели, АвтоЗаполнение",
			Ложь,
			Неопределено,
			Новый Массив,
			Неопределено
		);
		ЗаполнитьЗначенияСвойств(ОбменДаннымиЗаполняемый, ОбменДанными);
		Объект.ОбменДанными.Загрузка	 = ОбменДаннымиЗаполняемый["Загрузка"];
		Объект.ОбменДанными.Отправитель	 = ОбменДаннымиЗаполняемый["Отправитель"];
		Для каждого Получатель Из ОбменДаннымиЗаполняемый["Получатели"] Цикл
			Объект.ОбменДанными.Получатели.Добавить(Получатель);
		КонецЦикла;
		Если ОбменДаннымиЗаполняемый["АвтоЗаполнение"] <> Неопределено Тогда
			Объект.ОбменДанными.Получатели.АвтоЗаполнение = ОбменДаннымиЗаполняемый["АвтоЗаполнение"];
		КонецЕсли;
	КонецЕсли;

	Если ТипЗнч(ДополнительныеСвойства) = Тип("Структура") Тогда
		Для Каждого ДополнительноеСвойство Из ДополнительныеСвойства Цикл
			Объект.ДополнительныеСвойства[ДополнительноеСвойство.Ключ] = ДополнительноеСвойство.Значение;
		КонецЦикла;
	КонецЕсли;

	Если ЭтоДокументСсылка Тогда

		ПараметрыЗаписиДокументаДокумента = Новый Структура(
			"РежимЗаписи, РежимПроведения",
			РежимЗаписиДокумента.Запись,
			РежимПроведенияДокумента.Неоперативный
		);
		Если ТипЗнч(ПараметрыЗаписиДокумента) = Тип("Структура") Тогда
			ЗаполнитьЗначенияСвойств(ПараметрыЗаписиДокументаДокумента, ПараметрыЗаписиДокумента)
		КонецЕсли;
		Если ТипЗнч(ПараметрыЗаписиДокумента) = Тип("Булево") И ПараметрыЗаписиДокумента = Истина Тогда
			Если Объект.Проведен Тогда
				ПараметрыЗаписиДокументаДокумента["РежимЗаписи"] = РежимЗаписиДокумента.Проведение;
			КонецЕсли;
			Если Объект.Дата >= ТекущаяДатаСеанса() Тогда
				ВариантыОперативногоПроведения = Метаданные.СвойстваОбъектов.ОперативноеПроведение;
				Если Ссылка.Метаданные().ОперативноеПроведение = ВариантыОперативногоПроведения.Разрешить Тогда
					ПараметрыЗаписиДокументаДокумента["РежимПроведения"] = РежимПроведенияДокумента.Оперативный;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		Объект.Записать(ПараметрыЗаписиДокументаДокумента.РежимЗаписи, ПараметрыЗаписиДокументаДокумента.РежимПроведения);

	Иначе
		Объект.Записать();

	КонецЕсли;	
	
КонецПроцедуры // УстановитьЗначенияРеквизитовОбъекта()

#КонецОбласти // Данные

#Область Картинки

// Получает имя переданной стандартной картинки, заданное в конфигурации.
//
// Параметры:
//	Картинка - Картинка
//
// Возвращаемое значение:
//	Строка - Имя картинки. Для картинок, не являющихся библиотечными, возвращается пустая строка.
//
Функция ИмяКартинкиИзБиблиотеки(Картинка) Экспорт

	Если Картинка.Вид <> ВидКартинки.ИзБиблиотеки Тогда
		Возврат "";
	КонецЕсли;
	
	ЗаписьXML = Новый ЗаписьXML();
	ЗаписьXML.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(ЗаписьXML, Картинка);
	Результат = ЗаписьXML.Закрыть();

	Регулярка = "ref=""([^""]+)""";	// ref="ИмяКартинки"
	Совпадение = СтрНайтиПоРегулярномуВыражению(Результат, Регулярка);
	Группы = Совпадение.ПолучитьГруппы();
	Если ЗначениеЗаполнено(Группы) Тогда
		ИмяКартинки = Группы[0].Значение;
	Иначе
		ИмяКартинки = "";	
	КонецЕсли;

	Возврат ИмяКартинки; 

КонецФункции

#КонецОбласти // Картинки

#Область Ссылка

// Проверяет существование ссылки в ИБ.
//	Функция - аналог БСП.СсылкаСуществует()
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - значение любой ссылки информационной базы данных
// 
// Возвращаемое значение:
//	Булево - Истина, если ссылка физически существует
//
Функция СсылкаСуществует(Ссылка)
	
    ТекстЗапроса = "
	|ВЫБРАТЬ ПЕРВЫЕ 1	ИСТИНА
	|ИЗ					&ИмяТаблицы
	|ГДЕ				Ссылка = &Ссылка
	|";
	
    ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяТаблицы", Метаданные.НайтиПоТипу(ТипЗнч(Ссылка)).ПолноеИмя());
    
    Запрос = Новый Запрос;
    Запрос.Текст = ТекстЗапроса;
    Запрос.УстановитьПараметр("Ссылка", Ссылка);
    
    УстановитьПривилегированныйРежим(Истина);
    
    Возврат НЕ Запрос.Выполнить().Пустой();
    
КонецФункции // СсылкаСуществует()

// По навигационной ссылке получает ссылку на объект.
//
// Параметры:
//  НавигационнаяСсылка		 - Строка					 - Навигационная ссылка
//	УникальныйИдентификатор	 - УникальныйИдентификатор	 - Возвращаемый. Уникальный идентификатор объекта из навигационной ссылки.
//  ИмяРеквизита			 - Строка					 - Возвращаемый. Имя реквизита объекта или колонки табличной части, если указано в навигационной ссылке.
//  ИмяТабличнойЧасти		 - Строка					 - Возвращаемый. Имя табличной части, если указано в навигационной ссылке.
//  ИндексТабЧасти			 - Число					 - Возвращаемый. Индекс в табличной части, если указан в навигационной ссылке.
// 
// Возвращаемое значение:
//  Ссылка - Если определить ссылку не удалось - возвращается Неопределено.
//
Функция СсылкаИзНавигационнойСсылки(
	НавигационнаяСсылка,
	УникальныйИдентификатор = Неопределено, 
	ИмяРеквизита = Неопределено, 
	ИмяТабличнойЧасти = Неопределено, 
	ИндексТабЧасти = Неопределено)	
	// Форматы ссылок (см. https://its.1c.ru/db/v8doc):
	// e1cib/data/<путькметаданным>?ref=<идентификаторссылки>
	// e1cib/data/<путькметаданным>.<имяреквизита>?ref=<идентификаторссылки>
	// e1cib/data/<путькметаданным>.<имятабличнойчасти>.<имяреквизита>?ref=<идентификаторссылки>&index=<индексстрокитабличнойчасти>
	
	ОперандДанных	 = "e1cib/data/";
	ОперандСсылки	 = "?ref=";
	ОперандИндекса	 = "&index=";
	
	ПозицияОперандаДанных	 = СтрНайти(НавигационнаяСсылка, ОперандДанных);
	ПозицияОперандаСсылки	 = СтрНайти(НавигационнаяСсылка, ОперандСсылки);
	ПозицияОперандаИндекса	 = СтрНайти(НавигационнаяСсылка, ОперандИндекса);
	
	ЕстьСсылка = Булево(ПозицияОперандаДанных) и Булево(ПозицияОперандаСсылки); 		
	Если не ЕстьСсылка Тогда Возврат Неопределено КонецЕсли;
	
	ПолноеИмяМетаданныхСсылки = Сред(
	НавигационнаяСсылка, 
	ПозицияОперандаДанных + СтрДлина(ОперандДанных),
	(ПозицияОперандаСсылки - 1) - (ПозицияОперандаДанных - 1 + СтрДлина(ОперандДанных))
	);
	
	СтекИмени = СтрРазделить(ПолноеИмяМетаданныхСсылки, ".", Ложь);
	Если СтекИмени.ВГраница() < 1 Тогда Возврат Неопределено КонецЕсли; 
	
	ИмяОбъектаМетаданных = СтекИмени[1];
	ПолноеИмяМетаданного = СтекИмени[0] + "." + СтекИмени[1];	// напр. Документ.ИмяДокумента
	
	ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ПолноеИмяМетаданного);
	Если ОбъектМетаданных = Неопределено Тогда Возврат Неопределено КонецЕсли; 
	
	ДлинаУникальногоИдентификатораШестнЧисло = 32;
	УникальныйИдентификаторШестнЧисло = Сред(
		НавигационнаяСсылка, 
		ПозицияОперандаСсылки + СтрДлина(ОперандСсылки), 
		ДлинаУникальногоИдентификатораШестнЧисло
	); 														// 1   5           17  21  25
															// 8899aabbccddeeff6677445500112233
	УникальныйИдентификаторСтрокой = СтрШаблон(
		"%5-%4-%3-%1-%2",									// 00112233-4455-6677-8899-aabbccddeeff
		Сред(УникальныйИдентификаторШестнЧисло, 1,	 4),	// 8899
		Сред(УникальныйИдентификаторШестнЧисло, 5,	 12),	// aabbccddeeff
		Сред(УникальныйИдентификаторШестнЧисло, 17,	 4),	// 6677
		Сред(УникальныйИдентификаторШестнЧисло, 21,	 4),	// 4455
		Сред(УникальныйИдентификаторШестнЧисло, 25,	 8)		// 00112233
	);
	УникальныйИдентификатор = Новый УникальныйИдентификатор(УникальныйИдентификаторСтрокой);	// см. ОбщегоНазначенияКлиентСервер
	Если УникальныйИдентификатор = Неопределено Тогда Возврат Неопределено КонецЕсли; 
	
	Если		 Метаданные.Документы				.Содержит(ОбъектМетаданных) Тогда Ссылка = Документы				[ИмяОбъектаМетаданных].ПолучитьСсылку(УникальныйИдентификатор);
	ИначеЕсли	 Метаданные.Справочники				.Содержит(ОбъектМетаданных) Тогда Ссылка = Справочники				[ИмяОбъектаМетаданных].ПолучитьСсылку(УникальныйИдентификатор);
	ИначеЕсли	 Метаданные.ПланыВидовХарактеристик	.Содержит(ОбъектМетаданных) Тогда Ссылка = ПланыВидовХарактеристик	[ИмяОбъектаМетаданных].ПолучитьСсылку(УникальныйИдентификатор);
	ИначеЕсли	 Метаданные.ПланыСчетов				.Содержит(ОбъектМетаданных) Тогда Ссылка = ПланыСчетов				[ИмяОбъектаМетаданных].ПолучитьСсылку(УникальныйИдентификатор);
	ИначеЕсли	 Метаданные.ПланыВидовРасчета		.Содержит(ОбъектМетаданных) Тогда Ссылка = ПланыВидовРасчета		[ИмяОбъектаМетаданных].ПолучитьСсылку(УникальныйИдентификатор);
	ИначеЕсли	 Метаданные.ПланыОбмена				.Содержит(ОбъектМетаданных) Тогда Ссылка = ПланыОбмена				[ИмяОбъектаМетаданных].ПолучитьСсылку(УникальныйИдентификатор);
	ИначеЕсли	 Метаданные.Задачи					.Содержит(ОбъектМетаданных) Тогда Ссылка = Задачи					[ИмяОбъектаМетаданных].ПолучитьСсылку(УникальныйИдентификатор);
	ИначеЕсли	 Метаданные.БизнесПроцессы			.Содержит(ОбъектМетаданных) Тогда Ссылка = БизнесПроцессы			[ИмяОбъектаМетаданных].ПолучитьСсылку(УникальныйИдентификатор);
	Иначе Возврат Неопределено;
	КонецЕсли; 	
	
	ЕстьИмяТабличнойЧасти	 = СтекИмени.ВГраница() = 3;
	ЕстьРеквизит			 = СтекИмени.ВГраница() >= 2;

	Если ЕстьИмяТабличнойЧасти и ЕстьРеквизит Тогда	
		ИмяРеквизита		 = СтекИмени[3];
		ИмяТабличнойЧасти	 = СтекИмени[2];
		ЕстьИндекс = Булево(ПозицияОперандаИндекса);
		Если ЕстьИндекс Тогда
			ИндексТабЧастиСтрокой = Сред(НавигационнаяСсылка, ПозицияОперандаИндекса + СтрДлина(ОперандИндекса));
			Если ЗначениеЗаполнено(ИндексТабЧастиСтрокой) Тогда
				ИндексТабЧасти = Число(ИндексТабЧастиСтрокой);
			иначе
				ИндексТабЧасти = 0;
			КонецЕсли; 
		КонецЕсли; 
	ИначеЕсли ЕстьРеквизит Тогда
		ИмяРеквизита = СтекИмени[2];
	КонецЕсли;
	
	Возврат Ссылка;
	
КонецФункции // СсылкаИзНавигационнойСсылки()

// Получает ссылку на объект из навигационной ссылки
// с использованием ЗначениеВСторкуВнутр(), ЗначениеИзСтрокиВнутр(),
// без проверки на корректность.
// Методика: https://1c-bezproblem.ru/blog/v-pomoshch-1s-programmistu/1s-poluchit-ssylku-na-ob-ekt-po-navigatsionnoj-ssylke
//
// Параметры:
//  НавигационнаяСсылка	 - Строка	 - НавигационнаяСсылка
// 
// Возвращаемое значение:
//   - ЛюбаяСсылка   - Полученная ссылка
//
Функция СсылкаИзНавигационнойСсылкиВнутр(НавигационнаяСсылка)

 	// e1cib/data/<путькметаданным>?ref=<идентификаторссылки>
	
	ОперандДанных	 = "e1cib/data/";
	ОперандСсылки	 = "?ref=";
	НавигационнаяСсылкаЛокальная = Сред(НавигационнаяСсылка, СтрНайти(НавигационнаяСсылка, ОперандДанных));
	НавигационнаяСсылкаПоЧастям = СтрРазделить(НавигационнаяСсылкаЛокальная, "/?=", Ложь);
	ПолноеИмяМетаданныхСсылки = НавигационнаяСсылкаПоЧастям[2];
	ИдШестнадцатиричный = НавигационнаяСсылкаПоЧастям[4];
	
    СтрокаВнутр = ЗначениеВСтрокуВнутр(ПредопределенноеЗначение(ПолноеИмяМетаданныхСсылки + ".ПустаяСсылка"));
	ТридцатьДваНуля = "00000000000000000000000000000000";
    СтрокаВнутр = СтрЗаменить(СтрокаВнутр, ТридцатьДваНуля, ИдШестнадцатиричный);
	
	Возврат ЗначениеИзСтрокиВнутр(СтрокаВнутр);

КонецФункции // СсылкаИзНавигационнойСсылкиВнутр()

#КонецОбласти // Ссылка

#Область ОписанияТипов

// Формирует строковое представление списка типов.
// Работает только с хранимыми типами данных (примитивные и ссылочные типы).
//
// Параметры:
//	ОписаниеТипов	 - ОписаниеТипов	 - Описание типов для разбора.
//	Разделитель		 - Строка			 - Разделитель типов в строковом представлении.
//	Кратко	- Булево - Если Истина, то вместо полного представления параметра квалификатора формируется краткое:
//						"ДопустимаяДлина.Фиксированная" → "Фиксированная"
//
// Возвращаемое значение:
//	Строка - Представление типа.
//
// Примеры:
//	ОписаниеХранимыхТиповСтрокой(ОписаниеТипов, "; ", Истина) // "Число; Строка(12, Переменная)"
//
Функция ОписаниеХранимыхТиповСтрокой(ОписаниеТипов, Разделитель = "; ", Кратко = Ложь) Экспорт
	
	ПростыеТипы = Новый Массив;
	ПростыеТипы.Добавить(Тип("Число"));
	ПростыеТипы.Добавить(Тип("Строка"));
	ПростыеТипы.Добавить(Тип("Дата"));
	ПростыеТипы.Добавить(Тип("Булево"));
	ПростыеТипы.Добавить(Тип("ХранилищеЗначения"));
	ПростыеТипы.Добавить(Тип("УникальныйИдентификатор"));
	ДопустимыеТипы = Новый Массив;
	Для Каждого ТекущийТип Из ПростыеТипы Цикл
		ДопустимыеТипы.Добавить(ТекущийТип);
	КонецЦикла;
	ТипВсеСсылки = ТипВсеСсылки();
	Для Каждого ТекущийТип Из ТипВсеСсылки.Типы() Цикл
		ДопустимыеТипы.Добавить(ТекущийТип);
	КонецЦикла;	

	ВычитаемыеТипы = Новый Массив;
	Для каждого ТекущийТип Из ОписаниеТипов.Типы() Цикл
		Если ДопустимыеТипы.Найти(ТекущийТип) = Неопределено Тогда
			ВычитаемыеТипы.Добавить(ТекущийТип);
		КонецЕсли;
	КонецЦикла;

	ОписаниеХранимыхТипов = Новый ОписаниеТипов(ОписаниеТипов, , ВычитаемыеТипы);  
	
	ТипыСтроками = Новый Массив;
	ИменаТипов = Новый Соответствие;
	ИменаТипов[Тип("Число")]			 = "Число";
	ИменаТипов[Тип("Строка")]			 = "Строка";
	ИменаТипов[Тип("Дата")]				 = "Дата";
	СписокТипов = Новый СписокЗначений;
	Для каждого ТекущийТип Из ОписаниеХранимыхТипов.Типы() Цикл
		ИмяТипа = ИменаТипов[ТекущийТип];
		Если ИмяТипа <> Неопределено Тогда
			ОписаниеТипа = Новый ОписаниеТипов(
				ИмяТипа, 
				ОписаниеТипов.КвалификаторыЧисла,
				ОписаниеТипов.КвалификаторыСтроки,
				ОписаниеТипов.КвалификаторыДаты,
				ОписаниеТипов.КвалификаторыДвоичныхДанных
			);
			ТипСтрокой = ОписаниеХранимогоТипаСтрокой(ОписаниеТипа, Кратко);
		Иначе
			ТипСтрокой = ОписаниеХранимогоТипаСтрокой(ТекущийТип);
		КонецЕсли;
		СписокТипов.Добавить(ТекущийТип, ТипСтрокой);
		ТипыСтроками.Добавить(ТипСтрокой);
	КонецЦикла;

	// Сортировка. Простые типы выставляем раньше ссылочных для удобного отображения:
	ТипыПоПорядку = Новый Массив;
	Для Каждого ТекущийТип Из ПростыеТипы Цикл
		Если СписокТипов.НайтиПоЗначению(ТекущийТип) <> Неопределено Тогда
			ТипыПоПорядку.Добавить(ТекущийТип);
		КонецЕсли;
	КонецЦикла;
	Для Индекс = 0 По СписокТипов.Количество() - 1 Цикл
		ЭлементСписка = СписокТипов[Индекс];
		ТекущийТип = ЭлементСписка.Значение;
		ИндексТипа = ТипыПоПорядку.Найти(ТекущийТип);
		Если ИндексТипа <> Неопределено И ИндексТипа < Индекс Тогда
			СписокТипов.Сдвинуть(Индекс, ИндексТипа - Индекс);
		КонецЕсли;
	КонецЦикла;
	ТипыСтроками = Новый Массив;
	Для Каждого ЭлементСписка Из СписокТипов Цикл
		ТипыСтроками.Добавить(ЭлементСписка.Представление);
	КонецЦикла;

	ТипыСтрокой = СтрСоединить(ТипыСтроками, Разделитель);
	Возврат ТипыСтрокой;

КонецФункции // ОписаниеХранимыхТиповСтрокой() 

// Формирует строковое представление типа.
// Работает только с хранимыми типами данных (примитивные и ссылочные типы).
// Если примитивный тип содержит квалификаторы по умолчанию, они не детализируются.
//
// Параметры:
//	Тип		- Тип			 - Тип для получения представления.
//			- ОписаниеТипов	 - Тип для получения представления с квалификаторами.
//	Кратко	- Булево		 - Если Истина, то вместо полного представления перечисления формируется краткое:
//								"ДопустимаяДлина.Фиксированная" → "Фиксированная"
//
// Возвращаемое значение:
//	Строка - Представление типа.
//
// Примеры:
//	ОписаниеХранимыхТиповСтрокой(ОписаниеТипов, Истина) // "Строка(12, Переменная)"
//	ОписаниеХранимыхТиповСтрокой(Тип("ХранилищеЗначения")) // "ХранилищеЗначения"
//	ОписаниеХранимыхТиповСтрокой(Новый ОписаниеТипов("СправочникСсылка.ИмяСправочника")) // "СправочникСсылка.ИмяСправочника"
//
Функция ОписаниеХранимогоТипаСтрокой(Знач Тип, Кратко = Ложь) Экспорт

	Если ТипЗнч(Тип) = Тип("Тип") Тогда
		Типы = Новый Массив(1);
		Типы[0] = Тип;
		ОписаниеТипа = Новый ОписаниеТипов(Типы);
		ЕстьКвалификаторы = Ложь;
	ИначеЕсли ТипЗнч(Тип) = Тип("ОписаниеТипов") Тогда
		ОписаниеТипа = Тип;
		ЕстьКвалификаторы = Истина;
	Иначе
		ВызватьИсключение "Параметр Тип: Ожидается Тип или ОписаниеТипов.";
	КонецЕсли;

	КоличествоТипов = ОписаниеТипа.Типы().Количество();
	Если КоличествоТипов = 1 Тогда
		Тип = ОписаниеТипа.Типы()[0];
	ИначеЕсли КоличествоТипов = 0 Тогда
		Тип = Тип("Неопределено");
	Иначе
		ВызватьИсключение "ОписаниеТипов должно содержать только один тип.";
	КонецЕсли;

	Русский = Метаданные.СвойстваОбъектов.ВариантВстроенногоЯзыка.Русский;
	Если Метаданные.ВариантВстроенногоЯзыка = Русский Тогда
		КодЯзыка = "ru";
	Иначе
		КодЯзыка = "en";
	КонецЕсли;

	ИменаТипов = Новый Соответствие;
	ИменаТипов[Тип("Неопределено")]				 = "ru='Неопределено';				 en='Undefined'";
	ИменаТипов[Тип("Число")]					 = "ru='Число';						 en='Number'";
	ИменаТипов[Тип("Строка")]					 = "ru='Строка';					 en='String'";
	ИменаТипов[Тип("Дата")]						 = "ru='Дата';						 en='Date'";
	ИменаТипов[Тип("Булево")]					 = "ru='Булево';					 en='Boolean'";
	ИменаТипов[Тип("ХранилищеЗначения")]		 = "ru='ХранилищеЗначения';			 en='ValueStorage'";
	ИменаТипов[Тип("УникальныйИдентификатор")]	 = "ru='УникальныйИдентификатор';	 en='UUID'";

	ИмяТипа = ИменаТипов[Тип];
	Если ИмяТипа <> Неопределено И Не ЕстьКвалификаторы Тогда
		Возврат НСтр(ИмяТипа, КодЯзыка);
	КонецЕсли;

	#Область КвалифицируемыеТипы

	Представления = Новый Соответствие;
	Если Кратко Тогда
		Представления[ДопустимыйЗнак.Любой]				 = "ru='Любой';				 en='Any';";
		Представления[ДопустимыйЗнак.Неотрицательный]	 = "ru='Неотрицательный';	 en='Nonnegative';";
		Представления[ДопустимаяДлина.Переменная]		 = "ru='Переменная';		 en='Variable';";
		Представления[ДопустимаяДлина.Фиксированная]	 = "ru='Фиксированная';		 en='Fixed';";
		Представления[ЧастиДаты.Дата]					 = "ru='Дата';				 en='Date';";
		Представления[ЧастиДаты.Время]					 = "ru='Время';				 en='Time';";
		Представления[ЧастиДаты.ДатаВремя]				 = "ru='ДатаВремя';			 en='DateTime';";
	Иначе
		Представления[ДопустимыйЗнак.Любой]				 = "ru='ДопустимыйЗнак.Любой';			 en='AllowedSign.Any';";
		Представления[ДопустимыйЗнак.Неотрицательный]	 = "ru='ДопустимыйЗнак.Неотрицательный'; en='AllowedSign.Nonnegative';";
		Представления[ДопустимаяДлина.Переменная]		 = "ru='ДопустимаяДлина.Переменная';	 en='AllowedLength.Variable';";
		Представления[ДопустимаяДлина.Фиксированная]	 = "ru='ДопустимаяДлина.Фиксированная';	 en='AllowedLength.Fixed';";
		Представления[ЧастиДаты.Дата]					 = "ru='ЧастиДаты.Дата';				 en='DateFractions.Date';";
		Представления[ЧастиДаты.Время]					 = "ru='ЧастиДаты.Время';				 en='DateFractions.Time';";
		Представления[ЧастиДаты.ДатаВремя]				 = "ru='ЧастиДаты.ДатаВремя';			 en='DateFractions.DateTime';";
	КонецЕсли;

	Если Тип = Тип("Число") Тогда
		ОписаниеТиповПоУмолчанию = Новый ОписаниеТипов("Число");
		КвалификаторыЧислаПоУмолчанию = ОписаниеТиповПоУмолчанию.КвалификаторыЧисла;
		КвалификаторыЧисла = ОписаниеТипа.КвалификаторыЧисла;
		Если КвалификаторыЧисла.Разрядность = КвалификаторыЧислаПоУмолчанию.Разрядность
			И КвалификаторыЧисла.РазрядностьДробнойЧасти = КвалификаторыЧислаПоУмолчанию.РазрядностьДробнойЧасти
			И КвалификаторыЧисла.ДопустимыйЗнак = КвалификаторыЧислаПоУмолчанию.ДопустимыйЗнак Тогда
			Возврат НСтр(ИмяТипа, КодЯзыка);
		КонецЕсли;
		Возврат СтрШаблон(
			"%1(%2, %3, %4)",
			НСтр(ИменаТипов[Тип], КодЯзыка),
			XMLСтрока(КвалификаторыЧисла.Разрядность),
			XMLСтрока(КвалификаторыЧисла.РазрядностьДробнойЧасти),
			НСтр(Представления[КвалификаторыЧисла.ДопустимыйЗнак], КодЯзыка)
		);
	КонецЕсли;

	Если Тип = Тип("Строка") Тогда
		ОписаниеТиповПоУмолчанию = Новый ОписаниеТипов("Строка");
		КвалификаторыСтрокиПоУмолчанию = ОписаниеТиповПоУмолчанию.КвалификаторыСтроки;
		КвалификаторыСтроки = ОписаниеТипа.КвалификаторыСтроки;
		Если КвалификаторыСтроки.Длина = КвалификаторыСтрокиПоУмолчанию.Длина
			И КвалификаторыСтроки.ДопустимаяДлина = КвалификаторыСтрокиПоУмолчанию.ДопустимаяДлина Тогда
			Возврат НСтр(ИмяТипа, КодЯзыка);
		КонецЕсли;
		Возврат СтрШаблон(
			"%1(%2, %3)",
			НСтр(ИменаТипов[Тип], КодЯзыка),
			XMLСтрока(КвалификаторыСтроки.Длина),
			НСтр(Представления[КвалификаторыСтроки.ДопустимаяДлина], КодЯзыка)
		);
	КонецЕсли;
	
	Если Тип = Тип("Дата") Тогда
		ОписаниеТиповПоУмолчанию = Новый ОписаниеТипов("Дата");
		КвалификаторыДатыПоУмолчанию = ОписаниеТиповПоУмолчанию.КвалификаторыДаты;
		КвалификаторыДаты = ОписаниеТипа.КвалификаторыДаты;
		Если КвалификаторыДаты.ЧастиДаты = КвалификаторыДатыПоУмолчанию.ЧастиДаты Тогда
			Возврат НСтр(ИмяТипа, КодЯзыка);
		КонецЕсли;
		Возврат СтрШаблон(
			"%1(%2)",
			НСтр(ИменаТипов[Тип], КодЯзыка),
			НСтр(Представления[КвалификаторыДаты.ЧастиДаты], КодЯзыка)
		);
	КонецЕсли;

	// ДвоичныеДанные не хранятся, поэтому их тут нет.
	
	#КонецОбласти // КвалифицируемыеТипы

	#Область СсылочныеТипы
	
	МетаОбъект = Метаданные.НайтиПоТипу(Тип);
	
	Коллекции = Новый СписокЗначений;
	Коллекции.Добавить(Справочники,				"ru='СправочникСсылка';				 en='CatalogRef';");
	Коллекции.Добавить(Документы,				"ru='ДокументСсылка';				 en='DocumentRef';");
	Коллекции.Добавить(Перечисления,			"ru='ПеречислениеСсылка';			 en='EnumRef';");
	Коллекции.Добавить(ПланыВидовХарактеристик,	"ru='ПланВидовХарактеристикСсылка';	 en='ChartOfCharacteristicTypesRef';");
	Коллекции.Добавить(ПланыСчетов,				"ru='ПланСчетовСсылка';				 en='ChartOfAccountsRef';");
	Коллекции.Добавить(ПланыВидовРасчета,		"ru='ПланВидовРасчетаСсылка';		 en='ChartOfCalculationTypesRef';");
	Коллекции.Добавить(ПланыОбмена,				"ru='ПланОбменаСсылка';				 en='ExchangePlanRef';");
	Коллекции.Добавить(БизнесПроцессы,			"ru='БизнесПроцессСсылка';			 en='BusinessProcessRef';");
	Коллекции.Добавить(Задачи,					"ru='ЗадачаСсылка';					 en='TaskRef';");
	Для каждого ЭлементКоллекции Из Коллекции Цикл
		Коллекция = ЭлементКоллекции.Значение;
		Если Коллекция.ТипВсеСсылки().СодержитТип(Тип) Тогда
			Возврат НСтр(ЭлементКоллекции.Представление, КодЯзыка) + "." + МетаОбъект.Имя;
		КонецЕсли;
	КонецЦикла;   
	
	// Точки маршрута:
	Если БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(Тип) Тогда
		ИсходнаяСтрока = "ru='ТочкаМаршрутаБизнесПроцессаСсылка'; en='BusinessProcessRoutePointRef';";
		Возврат НСтр(ИсходнаяСтрока, КодЯзыка) + "." + МетаОбъект.Имя;
	КонецЕсли;

	#КонецОбласти // СсылочныеТипы

	ВызватьИсключение "Переданный тип не является хранимым.";
	
КонецФункции // ОписаниеХранимогоТипаСтрокой()

// Получает все возможные типы ссылок в текущей базе.
//
// Возвращаемое значение:
//	ОписаниеТипов - Все ссылки.
//
Функция ТипВсеСсылки() Экспорт

	ВсеТипы = Новый Массив;
	НаборыТипов = Новый Массив;
	НаборыТипов.Добавить(Справочники				.ТипВсеСсылки());
	НаборыТипов.Добавить(Документы					.ТипВсеСсылки());
	НаборыТипов.Добавить(Перечисления				.ТипВсеСсылки());
	НаборыТипов.Добавить(ПланыВидовХарактеристик	.ТипВсеСсылки());
	НаборыТипов.Добавить(ПланыСчетов				.ТипВсеСсылки());
	НаборыТипов.Добавить(ПланыВидовРасчета			.ТипВсеСсылки());
	НаборыТипов.Добавить(БизнесПроцессы				.ТипВсеСсылки());
	НаборыТипов.Добавить(БизнесПроцессы				.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов());
	НаборыТипов.Добавить(Задачи						.ТипВсеСсылки());
	НаборыТипов.Добавить(ПланыОбмена				.ТипВсеСсылки());

	Для каждого ОписаниеТипов Из НаборыТипов Цикл
		Для каждого ТекущийТип Из ОписаниеТипов.Типы() Цикл
			ВсеТипы.Добавить(ТекущийТип);
		КонецЦикла;
	КонецЦикла;

	Возврат Новый ОписаниеТипов(ВсеТипы);
	
КонецФункции // ТипВсеСсылки()

#КонецОбласти // ОписанияТипов

#Область РегулярныеВыражения

// Разбивает каждую подстроку указанной строки так, то её длина вписывается в указанный лимит.
//
// Параметры:
//	ИсходнаяСтрока			 - Строка
//	МаксимальнаяДлинаСтроки	 - Число  
//
// ВозвращаемоеЗначение:
//	Строка - Строка, разбитая через Символы.ПС.
//		Исходная строка может быть собрана обратно через СтрЗаменить(Символы.ПС, "").
//
Функция ФорматироватьТекстПоМаксимальнойДлинеСтрок(Знач ИсходнаяСтрока, МаксимальнаяДлинаСтроки) Экспорт

	СтрокаРезультат = "";  
	
	ИсходнаяСтрока = Строка(ИсходнаяСтрока);
	Абзацы = СтрРазделить(ИсходнаяСтрока, Символы.ПС, Истина);  
	
	РегулярноеВыражение = "(^\s+)?(\b\w+\b)*([^\w\s]*)(\s+)?";
	// Слова целиком, с заканчивающими их знаками препинания и пробелами.
	// (^\s+)?		 - Отступ с начала строки;
	// (\b\w+\b)*	 - Слово;
	// ([^\w\s]*)	 - Знаки препинания после слова;
	// (\s+)?		 - Отступы после слова  
	
	Для Индекс = 0 По Абзацы.ВГраница() Цикл  
		
		Абзац = Абзацы[Индекс];
		Если СтрДлина(Абзац) <= МаксимальнаяДлинаСтроки Тогда
			Продолжить;
		КонецЕсли;	                        
		
		Совпадения = СтрНайтиВсеПоРегулярномуВыражению(Абзац, РегулярноеВыражение, Истина, Ложь);
		Слова = Новый Массив;
		Для каждого Совпадение Из Совпадения Цикл
			
			Слово = Совпадение.Значение;
			Если СтрДлина(Слово) > МаксимальнаяДлинаСтроки Тогда 
				ДлинаСловаБезПоследующихПробелов = СтрДлина(СокрП(Слово));
				Если ДлинаСловаБезПоследующихПробелов <= МаксимальнаяДлинаСтроки Тогда
					// Для случаев, если от слова можно отрезать последующие пробелы. 
					Слова.Добавить(Лев(Слово, ДлинаСловаБезПоследующихПробелов));
					Слова.Добавить(Сред(Слово, ДлинаСловаБезПоследующихПробелов + 1));
				Иначе
					ВызватьИсключение СтрШаблон("Длина слова с последующими отступами превышает %1 симв.:
					|«%2»",
					МаксимальнаяДлинаСтроки,
					Слово);			
				КонецЕсли;
			Иначе
				Слова.Добавить(Слово);
			КонецЕсли;
			
		КонецЦикла;  
		
		СтрокиАбзаца = Новый Массив;
		СтрокаАбзаца = "";
		Для каждого Слово Из Слова Цикл
			Если СтрДлина(СтрокаАбзаца) + СтрДлина(Слово) <= МаксимальнаяДлинаСтроки Тогда
				СтрокаАбзаца = СтрокаАбзаца + Слово;
			Иначе
				СтрокиАбзаца.Добавить(СтрокаАбзаца);
				СтрокаАбзаца = Слово;
			КонецЕсли;		   
		КонецЦикла;            
		СтрокиАбзаца.Добавить(СтрокаАбзаца);
		Абзацы[Индекс] = СтрСоединить(СтрокиАбзаца, Символы.ПС);
		
	КонецЦикла; 
	
	СтрокаРезультат = СтрСоединить(Абзацы, Символы.ПС);
	Возврат СтрокаРезультат;

КонецФункции // ФорматироватьТекстПоМаксимальнойДлинеСтрок()

#КонецОбласти // РегулярныеВыражения

#Область ТаблицаЗначений

// Формирует пустую таблицу значений из запроса без его выполнения.
//
// Параметры:
//	Запрос - Запрос
//
// Возвращаемое значение:
//	ТаблицаЗначений - Сформированная таблица значений
//
Функция ТаблицаЗначенийИзЗапроса(Запрос) Экспорт

	СхемаЗапроса = Новый СхемаЗапроса();
	СхемаЗапроса.УстановитьТекстЗапроса(Запрос.Текст);
	ЗапросПакета = СхемаЗапроса.ПакетЗапросов[СхемаЗапроса.ПакетЗапросов.Количество() - 1];

	Если ТипЗнч(ЗапросПакета) <> Тип("ЗапросВыбораСхемыЗапроса") Тогда
		ВызватьИсключение "Последний запрос пакета не является запросом выбора";
	КонецЕсли;

	ВозвращаемаяТаблица = Новый ТаблицаЗначений;
	Для каждого Колонка Из ЗапросПакета.Колонки Цикл
		ИмяКолонки = Колонка.Псевдоним;
		Если ТипЗнч(Колонка) = Тип("КолонкаСхемыЗапроса") Тогда
			ТипКолонки = Колонка.ТипЗначения;
		ИначеЕсли ТипЗнч(Колонка) = Тип("КолонкаВложеннаяТаблицаСхемыЗапроса") Тогда
			ТипКолонки = Новый ОписаниеТипов("ТаблицаЗначений");
		Иначе
			ВызватьИсключение СтрШаблон("Неожиданный тип значения колонки %1", ИмяКолонки);
		КонецЕсли;
		ВозвращаемаяТаблица.Колонки.Добавить(ИмяКолонки, ТипКолонки);
	КонецЦикла;

	Возврат ВозвращаемаяТаблица;

КонецФункции // ТаблицаЗначенийИзЗапроса()

// Проверяет равенство таблиц.
// Таблицы равны, когда:
//	- Состав и порядок колонок одинаковый
//	- Количество срок одинаковое
//	- Состав данных одинаковый
//
// Параметры:
//	ПерваяТаблица	 - ТаблицаЗначений	 - Первая таблица для сравнения.
//	ВтораяТаблица	 - ТаблицаЗначений	 - Вторая таблица для сравнения.
//	ТекстОшибки		 - Строка			 - Текст сообщения об ошибке.
//
// Возвращаемое значение:
//	Булево - Истина, если таблицы равны.
//
Функция ТаблицыЗначенийРавны(ПерваяТаблица, ВтораяТаблица, ТекстОшибки = "") Экспорт
	
	Если ПерваяТаблица.Колонки.Количество() <> ВтораяТаблица.Колонки.Количество() Тогда
		ТекстОшибки = "Количество колонок различается";
		Возврат Ложь;
	КонецЕсли;

	Для ИндексКолонки = 0 По ПерваяТаблица.Колонки.Количество() - 1 Цикл
		Если ПерваяТаблица.Колонки[ИндексКолонки].Имя <> ВтораяТаблица.Колонки[ИндексКолонки].Имя Тогда
			ТекстОшибки = "Состав колонок различается";
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;

	Если ПерваяТаблица.Количество() <> ВтораяТаблица.Количество() Тогда
		ТекстОшибки = "Количество строк различается";
		Возврат Ложь;
	КонецЕсли;

	ВерхняяГраницаКолонок = ПерваяТаблица.Колонки.Количество() - 1;
	Для ИндексСтроки = 0 По ПерваяТаблица.Количество() - 1 Цикл
		Для ИндексКолонки = 0 По ВерхняяГраницаКолонок Цикл
			ПервоеЗначение = ПерваяТаблица[ИндексСтроки][ИндексКолонки];
			ВтороеЗначение = ВтораяТаблица[ИндексСтроки][ИндексКолонки];
			ИмяКолонки = ПерваяТаблица.Колонки[ИндексКолонки].Имя;
			ТипПервогоЗначения = ТипЗнч(ПервоеЗначение);
			ТипВторогоЗначения = ТипЗнч(ВтороеЗначение);
			Если ТипПервогоЗначения <> ТипВторогоЗначения Тогда
				ТекстОшибки = СтрШаблон(
					"Типы значений отличаются:
					|Строка [%1], Колонка [%2] (%3)
					|%4 <> %5",
					ИндексСтроки,
					ИндексКолонки,
					ИмяКолонки,
					ТипПервогоЗначения,
					ТипВторогоЗначения);
				Возврат Ложь;
			КонецЕсли;
			Если ПервоеЗначение <> ВтороеЗначение Тогда
				ТекстОшибки = СтрШаблон(
					"Значения отличаются:
					|Строка [%1], Колонка [%2] (%3)
					|%4 <> %5",
					ИндексСтроки,
					ИндексКолонки,
					ИмяКолонки,
					ПервоеЗначение,
					ВтороеЗначение);
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;

	Возврат Истина;

КонецФункции // ТаблицыЗначенийРавны()

#КонецОбласти // ТаблицаЗначений

// Получает программный код для получения указанной ссылки через уникальный идентификатор
//
// Параметры:
//  СсылкаНаОбъект	 - ЛюбаяСсылка	 - Ссылка на объект.
// 
// Возвращаемое значение:
//  Строка - Команда для получения ссылки. Например: "Справочники.Номенклатура.ПолучитьСсылку(Новый УникальныйИдентификатор("00112233-4455-6677-8899-aabbccddeeff"))"
//
Функция ТекстМодуляПолученияСсылки(СсылкаНаОбъект)
	
	ТекстМодуля = "Неопределено";
		
	ОбъектМетаданных = СсылкаНаОбъект.Метаданные();
	
	Если		 Метаданные.Документы				.Содержит(ОбъектМетаданных) Тогда ИмяМенеджера = "Документы";
	ИначеЕсли	 Метаданные.Справочники				.Содержит(ОбъектМетаданных) Тогда ИмяМенеджера = "Справочники";
	ИначеЕсли	 Метаданные.ПланыВидовХарактеристик	.Содержит(ОбъектМетаданных) Тогда ИмяМенеджера = "ПланыВидовХарактеристик";
	ИначеЕсли	 Метаданные.ПланыСчетов				.Содержит(ОбъектМетаданных) Тогда ИмяМенеджера = "ПланыСчетов";
	ИначеЕсли	 Метаданные.ПланыВидовРасчета		.Содержит(ОбъектМетаданных) Тогда ИмяМенеджера = "ПланыВидовРасчета";
	ИначеЕсли	 Метаданные.ПланыОбмена				.Содержит(ОбъектМетаданных) Тогда ИмяМенеджера = "ПланыОбмена";
	ИначеЕсли	 Метаданные.Задачи					.Содержит(ОбъектМетаданных) Тогда ИмяМенеджера = "Задачи";
	ИначеЕсли	 Метаданные.БизнесПроцессы			.Содержит(ОбъектМетаданных) Тогда ИмяМенеджера = "БизнесПроцессы";
	Иначе Возврат ТекстМодуля;
	КонецЕсли; 	
	
	Если Не СсылкаНаОбъект.Пустая() Тогда
		ТекстМодуля = СтрШаблон(
			"%1.%2.ПолучитьСсылку(Новый УникальныйИдентификатор(""%3""))",
			ИмяМенеджера,
			ОбъектМетаданных.Имя,
			СсылкаНаОбъект.УникальныйИдентификатор()
		);
	Иначе
		ТекстМодуля = СтрШаблон(
			"%1.%2.ПустаяСсылка()",
			ИмяМенеджера,
			ОбъектМетаданных.Имя
		);
	КонецЕсли;
	
	Возврат ТекстМодуля;

КонецФункции // ТекстМодуляПолученияСсылки()

// Извлекает ссылку представления "битой" ссылки.
//
// Параметры:
//	ТекстОбъектНеНайден - Строка - Строка вида "<Объект не найден> (247:b333271d065d39be4d0030cfbb003709)"
//
// Возвращаемое значение:
//	ЛюбаяСсылка - Извлеченная ссылка. 
//					Если извлечь ссылку не удалось - Неопределено
//
Функция СсылкаИзСтрокиОбъектНеНайден(ТекстОбъектНеНайден)
	
	Разделитель = ":";
	
	Если ПустаяСтрока(ТекстОбъектНеНайден) 
		Или Не СтрНайти(ТекстОбъектНеНайден, Разделитель) Тогда
		Возврат Неопределено;
	КонецЕсли; 
	
	СсылкаСырая = ТекстОбъектНеНайден;
	ПозицияСкобкиОткр = СтрНайти(СсылкаСырая, "(");
	ПозицияСкобкиЗакр = СтрНайти(СсылкаСырая, ")");
	Если ПозицияСкобкиОткр И ПозицияСкобкиЗакр Тогда
		СсылкаСырая = Сред(СсылкаСырая, ПозицияСкобкиОткр + 1, ПозицияСкобкиЗакр - ПозицияСкобкиОткр - 1);	// "123:778899aabb.."
	КонецЕсли; 
	
	ПозицияРазделитель = СтрНайти(СсылкаСырая, Разделитель);
	Если ПозицияРазделитель <= 1 Тогда	// Нет номера таблицы
		Возврат Неопределено;
	КонецЕсли; 
	
	НомерТаблицы = Лев(СсылкаСырая, ПозицияРазделитель - 1);
	ИдШестнадцатиричный = Сред(СсылкаСырая, ПозицияРазделитель + 1, 32);
	УникальныйИдентификаторСтрокой = СтрШаблон(
		"%5-%4-%3-%1-%2",
		Сред(ИдШестнадцатиричный, 1,	 4),	// 8899
		Сред(ИдШестнадцатиричный, 5,	 12),	// aabbccddeeff
		Сред(ИдШестнадцатиричный, 17,	 4),	// 6677
		Сред(ИдШестнадцатиричный, 21,	 4),	// 4455
		Сред(ИдШестнадцатиричный, 25,	 8)		// 00112233
	);
	УникальныйИдентификатор = Новый УникальныйИдентификатор(УникальныйИдентификаторСтрокой);
	
	Если УникальныйИдентификатор = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 

	РазделыМетаданных = Новый Массив;
	РазделыМетаданных.Добавить(Метаданные.Справочники);
	РазделыМетаданных.Добавить(Метаданные.Документы);
	
	// Префиксы: https://its.1c.ru/db/metod8dev/content/1798/hdoc
	РазделыМетаданныхПрефиксы = Новый ТаблицаЗначений;	// Чтобы соблюсти порядок, для производительности
	РазделыМетаданныхПрефиксы.Колонки.Добавить("РазделМетаданных");
	РазделыМетаданныхПрефиксы.Колонки.Добавить("Префикс");
	
	Таб = РазделыМетаданныхПрефиксы;
	Стр = Таб.Добавить(); Стр[0] = Метаданные.Справочники; 				 Стр[1] = "Reference";
	Стр = Таб.Добавить(); Стр[0] = Метаданные.Документы; 				 Стр[1] = "Document";
	Стр = Таб.Добавить(); Стр[0] = Метаданные.ПланыВидовХарактеристик; 	 Стр[1] = "Chrc";
	Стр = Таб.Добавить(); Стр[0] = Метаданные.ПланыСчетов; 				 Стр[1] = "Acc";
	Стр = Таб.Добавить(); Стр[0] = Метаданные.ПланыВидовРасчета; 		 Стр[1] = "CKind";
	Стр = Таб.Добавить(); Стр[0] = Метаданные.ПланыОбмена; 				 Стр[1] = "Node";
	Стр = Таб.Добавить(); Стр[0] = Метаданные.БизнесПроцессы; 			 Стр[1] = "BPr";
	Стр = Таб.Добавить(); Стр[0] = Метаданные.Задачи; 					 Стр[1] = "Task";
	// #СДЕЛАТЬ Перечисления? Там нет ПолучитьСсылку()	 // Enum
	// #СДЕЛАТЬ Точки маршрутов бизнес-процессов?		 // BPrPoints

	Для каждого РазделМетаданныхПрефикс Из РазделыМетаданныхПрефиксы Цикл
		
		РазделМетаданных = РазделМетаданныхПрефикс.РазделМетаданных;
		Префикс			 = РазделМетаданныхПрефикс.Префикс;
		
		ОбъектыМетаданных = Новый Массив;
		Для каждого ОбъектМетаданных Из РазделМетаданных Цикл
			ОбъектыМетаданных.Добавить(ОбъектМетаданных);
		КонецЦикла; 
		СтруктураХранения = ПолучитьСтруктуруХраненияБазыДанных(ОбъектыМетаданных, Ложь);
		СтруктураХранения = СтруктураХранения.Скопировать(Новый Структура("Назначение", "Основная"), "ИмяТаблицыХранения, Метаданные");
		СтруктураХранения.Индексы.Добавить("ИмяТаблицыХранения");
		
		ОписаниеТаблицы = СтруктураХранения.Найти(Префикс + НомерТаблицы, "ИмяТаблицыХранения");
		Если ОписаниеТаблицы = Неопределено Тогда
			Продолжить;
		КонецЕсли; 
		
		ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ОписаниеТаблицы.Метаданные);
		ИмяМетаданного = ОбъектМетаданных.Имя;
		Если	 РазделМетаданных = Метаданные.Справочники Тогда				Менеджер = Справочники[ИмяМетаданного];
		ИначеЕсли РазделМетаданных = Метаданные.Документы Тогда					Менеджер = Документы[ИмяМетаданного];
		ИначеЕсли РазделМетаданных = Метаданные.ПланыВидовХарактеристик Тогда	Менеджер = ПланыВидовХарактеристик[ИмяМетаданного];
		ИначеЕсли РазделМетаданных = Метаданные.ПланыСчетов Тогда				Менеджер = ПланыСчетов[ИмяМетаданного];
		ИначеЕсли РазделМетаданных = Метаданные.ПланыВидовРасчета Тогда			Менеджер = ПланыВидовРасчета[ИмяМетаданного];
		ИначеЕсли РазделМетаданных = Метаданные.БизнесПроцессы Тогда			Менеджер = БизнесПроцессы[ИмяМетаданного];
		ИначеЕсли РазделМетаданных = Метаданные.Задачи Тогда					Менеджер = Задачи[ИмяМетаданного];
			
		Иначе
			Возврат Неопределено;
			
		КонецЕсли; 
		
		Возврат Менеджер.ПолучитьСсылку(УникальныйИдентификатор);
		
	КонецЦикла; 
	
	Возврат Неопределено;

КонецФункции // СсылкаИзСтрокиОбъектНеНайден()

// Останавливает выполнение кода на заданное время.
// Из: http://forum.infostart.ru/forum9/topic263141/message2660525/#message2660525
//
// Параметры:
//  Секунд - Число - время ожидания в секундах.
//
Процедура Пауза(Секунд) Экспорт

    
	ИмяМодуля = "ОбщегоНазначения";	// Имя модуля, в котором расположена эта процедура

    ТекущийСеансИнформационнойБазы = ПолучитьТекущийСеансИнформационнойБазы();
    ФоновоеЗадание = ТекущийСеансИнформационнойБазы.ПолучитьФоновоеЗадание();
    
    Если ФоновоеЗадание = Неопределено Тогда
        Параметры = Новый Массив;
        Параметры.Добавить(Секунд);
        ФоновоеЗадание = ФоновыеЗадания.Выполнить(ИмяМодуля + ".Пауза", Параметры);
    КонецЕсли;
    
    ФоновоеЗадание.ОжидатьЗавершенияВыполнения(Секунд);
    
КонецПроцедуры // Пауза()

// Проверяет, является ли переданный тип ссылкой.
//
// Параметры:
//  ПроверяемыйТип					 - Тип
//	ОписаниеТиповВсеСсылкиПовтИсп	 - ОписаниеТипов - Описание типов всех возможных ссылок для повторного использования
//
// Возвращаемое значение:
//   Булево - Истина, если значение - это ссылка.
//
Функция ЭтоСсылка(ПроверяемыйТип, ОписаниеТиповВсеСсылкиПовтИсп = Неопределено) Экспорт

	Если ОписаниеТиповВсеСсылкиПовтИсп = Неопределено Тогда

		ОбъектыМетаданных = Новый Массив;
		ОбъектыМетаданных.Добавить(Справочники);
		ОбъектыМетаданных.Добавить(Документы);
		ОбъектыМетаданных.Добавить(ПланыОбмена);
		ОбъектыМетаданных.Добавить(Перечисления);
		ОбъектыМетаданных.Добавить(ПланыВидовХарактеристик);
		ОбъектыМетаданных.Добавить(ПланыСчетов);
		ОбъектыМетаданных.Добавить(ПланыВидовРасчета);
		ОбъектыМетаданных.Добавить(БизнесПроцессы);
		ОбъектыМетаданных.Добавить(Задачи);

		ОписаниеТиповВсеСсылкиПовтИсп = БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов();	// ОписаниеТипов
		Для каждого ОбъектМетаданных Из ОбъектыМетаданных Цикл
			ОписаниеТиповВсеСсылкиПовтИсп = Новый ОписаниеТипов(
				ОписаниеТиповВсеСсылкиПовтИсп, 
				ОбъектМетаданных.ТипВсеСсылки().Типы()
			);
		КонецЦикла;

	КонецЕсли;

	Возврат ПроверяемыйТип <> Тип("Неопределено") И ОписаниеТиповВсеСсылкиПовтИсп.СодержитТип(ПроверяемыйТип);
	
КонецФункции // ЭтоСсылка()

// Проверяет, является ли переданный тип ссылочным.
//
// Параметры:
//	ПроверяемыйТип - Тип
//
// Возвращаемое значение:
//	Булево - Истина, если проверяемый тип является ссылкой, или объектом ссылочного типа. Например, СправочникОбъект.
//
// Примеры:
//	ЭтоСсылочныйТип(ТипЗнч(123)) = Ложь;
//	ЭтоСсылочныйТип(ТипЗнч(Справочник.ЛюбойСправочник.ПустаяСсылка())) = Истина;
//	ЭтоСсылочныйТип(ТипЗнч(Справочник.ЛюбойСправочник.СоздатьЭлемент())) = Истина;
//
Функция ЭтоСсылочныйТип(ПроверяемыйТип) Экспорт
	
	ОбъектМетаданных = Метаданные.НайтиПоТипу(ПроверяемыйТип);
	Если ОбъектМетаданных = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;

	КоллекцииСсылочныхМетаданных = Новый Массив;
	КоллекцииСсылочныхМетаданных.Добавить(Метаданные.Справочники);
	КоллекцииСсылочныхМетаданных.Добавить(Метаданные.Документы);
	КоллекцииСсылочныхМетаданных.Добавить(Метаданные.ПланыВидовХарактеристик);
	КоллекцииСсылочныхМетаданных.Добавить(Метаданные.ПланыСчетов);
	КоллекцииСсылочныхМетаданных.Добавить(Метаданные.ПланыВидовРасчета);
	КоллекцииСсылочныхМетаданных.Добавить(Метаданные.БизнесПроцессы);
	КоллекцииСсылочныхМетаданных.Добавить(Метаданные.Задачи);

	Для Каждого КоллекцияСсылочныхМетаданных Из КоллекцииСсылочныхМетаданных Цикл
		Если КоллекцияСсылочныхМетаданных.Содержит(ОбъектМетаданных) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;

	Возврат Ложь;

КонецФункции

// Проверяет, имеет ли значение ссылочный тип,
// используя функцию ЗначениеВСтрокуВнутр().
//
// Параметры:
//  Значение - Произвольный
//
// Возвращаемое значение:
//   Булево - Истина, если значение - это ссылка.
//
Функция ЭтоСсылкаВнутр(Значение) Экспорт
	
	СтрокаВнутр = ЗначениеВСтрокуВнутр(Значение);
	// Пример ссылочного значения: {"#",a1e67513-8fde-4b86-8a14-990ca9d1a362,505:00000000000000000000000000000000}
	
	// Проверка префикса значения
	ПрефиксЗначения = "#";
	ЕстьПрефиксЗначения = СтрНайти(СтрокаВнутр, ПрефиксЗначения) = 3;
	Если Не ЕстьПрефиксЗначения Тогда
		Возврат Ложь;
	КонецЕсли;
	
	СтрокаВнутрБезСкобок = Сред(СтрокаВнутр, 2, СтрДлина(СтрокаВнутр) - 2);
	ЧастиСтрокиВнутр = СтрРазделить(СтрокаВнутрБезСкобок, ",");
	
	// После префикса ссылки
	// Проверка части ссылки. Её формат: <НомеТаблицы>:<32-разрядной шестнадцатеричное число>
	ЧастьЗначение = ЧастиСтрокиВнутр[2];
	ПозицияДвоеточия = СтрНайти(ЧастьЗначение, ":");
	Если ПозицияДвоеточия = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	ДесятеричныеЦифры = "0123456789";
	Для НомерСимвола = 1 По ПозицияДвоеточия - 1 Цикл
		ТекущийСимвол = Сред(ЧастьЗначение, НомерСимвола, 1);
		Если Не СтрНайти(ДесятеричныеЦифры, ТекущийСимвол) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	ШестнадцатеричныеЦифры = "0123456789abcdef";    
	ЧастьИдентификатор =  Сред(ПозицияДвоеточия + 1, НомерСимвола); 
	ДлинаИдентификатора = СтрДлина(ЧастьИдентификатор);
	Если ДлинаИдентификатора <> 32 Тогда
		Возврат Ложь;
	КонецЕсли;
	Для НомерСимвола = 1 По ДлинаИдентификатора Цикл
		ТекущийСимвол = Сред(ЧастьИдентификатор, НомерСимвола, 1);
		Если Не СтрНайти(ШестнадцатеричныеЦифры, ТекущийСимвол) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
		
	Возврат Истина;

КонецФункции // ЭтоСсылкаВнутр()

#Область OneScript

Процедура УстановитьПривилегированныйРежим(Включить = Истина)
	
КонецПроцедуры

Функция ПредопределенноеЗначение(Значение)
	Возврат Неопределено;
КонецФункции

Функция ЗначениеВСтрокуВнутр(Значение)
	Возврат Неопределено;
КонецФункции

Функция ЗначениеИзСтрокиВнутр(СтрокаВнутр)
	Возврат Неопределено;
КонецФункции

Функция ПолучитьСтруктуруХраненияБазыДанных(Парам1, Парам2)
	Возврат Неопределено;
КонецФункции

Функция ПолучитьТекущийСеансИнформационнойБазы()
	Возврат Неопределено;
КонецФункции

Функция ТекущаяДатаСеанса()
	Возврат ТекущаяДата();
КонецФункции

Функция СтрНайтиВсеПоРегулярномуВыражению(Строка, РегулярноеВыражение, ИгнорироватьРегистр, Многострочная)
	Возврат Новый Массив;
КонецФункции

#КонецОбласти // OneScript